(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{0:function(e,t,n){e.exports=n("zUnb")},zUnb:function(e,t,n){"use strict";function o(e){return"function"==typeof e}n.r(t);let a=!1;const r={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){if(e){const e=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+e.stack)}else a&&console.log("RxJS: Back to a better error behavior. Thank you. <3");a=e},get useDeprecatedSynchronousErrorHandling(){return a}};function s(e){setTimeout(()=>{throw e},0)}const i={closed:!0,next(e){},error(e){if(r.useDeprecatedSynchronousErrorHandling)throw e;s(e)},complete(){}},l=(()=>Array.isArray||(e=>e&&"number"==typeof e.length))();function u(e){return null!==e&&"object"==typeof e}const c=(()=>{function e(e){return Error.call(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e})();let p=(()=>{class e{constructor(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._unsubscribe=e)}unsubscribe(){let t;if(this.closed)return;let{_parentOrParents:n,_unsubscribe:a,_subscriptions:r}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof e)n.remove(this);else if(null!==n)for(let e=0;e<n.length;++e)n[e].remove(this);if(o(a))try{a.call(this)}catch(s){t=s instanceof c?d(s.errors):[s]}if(l(r)){let e=-1,n=r.length;for(;++e<n;){const n=r[e];if(u(n))try{n.unsubscribe()}catch(s){t=t||[],s instanceof c?t=t.concat(d(s.errors)):t.push(s)}}}if(t)throw new c(t)}add(t){let n=t;if(!t)return e.EMPTY;switch(typeof t){case"function":n=new e(t);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof e)){const t=n;n=new e,n._subscriptions=[t]}break;default:throw new Error("unrecognized teardown "+t+" added to Subscription.")}let{_parentOrParents:o}=n;if(null===o)n._parentOrParents=this;else if(o instanceof e){if(o===this)return n;n._parentOrParents=[o,this]}else{if(-1!==o.indexOf(this))return n;o.push(this)}const a=this._subscriptions;return null===a?this._subscriptions=[n]:a.push(n),n}remove(e){const t=this._subscriptions;if(t){const n=t.indexOf(e);-1!==n&&t.splice(n,1)}}}return e.EMPTY=function(e){return e.closed=!0,e}(new e),e})();function d(e){return e.reduce((e,t)=>e.concat(t instanceof c?t.errors:t),[])}const h=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class m extends p{constructor(e,t,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=i;break;case 1:if(!e){this.destination=i;break}if("object"==typeof e){e instanceof m?(this.syncErrorThrowable=e.syncErrorThrowable,this.destination=e,e.add(this)):(this.syncErrorThrowable=!0,this.destination=new f(this,e));break}default:this.syncErrorThrowable=!0,this.destination=new f(this,e,t,n)}}[h](){return this}static create(e,t,n){const o=new m(e,t,n);return o.syncErrorThrowable=!1,o}next(e){this.isStopped||this._next(e)}error(e){this.isStopped||(this.isStopped=!0,this._error(e))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(e){this.destination.next(e)}_error(e){this.destination.error(e),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:e}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this}}class f extends m{constructor(e,t,n,a){let r;super(),this._parentSubscriber=e;let s=this;o(t)?r=t:t&&(r=t.next,n=t.error,a=t.complete,t!==i&&(s=Object.create(t),o(s.unsubscribe)&&this.add(s.unsubscribe.bind(s)),s.unsubscribe=this.unsubscribe.bind(this))),this._context=s,this._next=r,this._error=n,this._complete=a}next(e){if(!this.isStopped&&this._next){const{_parentSubscriber:t}=this;r.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}}error(e){if(!this.isStopped){const{_parentSubscriber:t}=this,{useDeprecatedSynchronousErrorHandling:n}=r;if(this._error)n&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)n?(t.syncErrorValue=e,t.syncErrorThrown=!0):s(e),this.unsubscribe();else{if(this.unsubscribe(),n)throw e;s(e)}}}complete(){if(!this.isStopped){const{_parentSubscriber:e}=this;if(this._complete){const t=()=>this._complete.call(this._context);r.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?(this.__tryOrSetError(e,t),this.unsubscribe()):(this.__tryOrUnsub(t),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(e,t){try{e.call(this._context,t)}catch(n){if(this.unsubscribe(),r.useDeprecatedSynchronousErrorHandling)throw n;s(n)}}__tryOrSetError(e,t,n){if(!r.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,n)}catch(o){return r.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=o,e.syncErrorThrown=!0,!0):(s(o),!0)}return!1}_unsubscribe(){const{_parentSubscriber:e}=this;this._context=null,this._parentSubscriber=null,e.unsubscribe()}}const g=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function _(e){return e}function y(...e){return b(e)}function b(e){return 0===e.length?_:1===e.length?e[0]:function(t){return e.reduce((e,t)=>t(e),t)}}let v=(()=>{class e{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(t){const n=new e;return n.source=this,n.operator=t,n}subscribe(e,t,n){const{operator:o}=this,a=function(e,t,n){if(e){if(e instanceof m)return e;if(e[h])return e[h]()}return e||t||n?new m(e,t,n):new m(i)}(e,t,n);if(a.add(o?o.call(a,this.source):this.source||r.useDeprecatedSynchronousErrorHandling&&!a.syncErrorThrowable?this._subscribe(a):this._trySubscribe(a)),r.useDeprecatedSynchronousErrorHandling&&a.syncErrorThrowable&&(a.syncErrorThrowable=!1,a.syncErrorThrown))throw a.syncErrorValue;return a}_trySubscribe(e){try{return this._subscribe(e)}catch(t){r.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){const{closed:t,destination:n,isStopped:o}=e;if(t||o)return!1;e=n&&n instanceof m?n:null}return!0}(e)?e.error(t):console.warn(t)}}forEach(e,t){return new(t=x(t))((t,n)=>{let o;o=this.subscribe(t=>{try{e(t)}catch(a){n(a),o&&o.unsubscribe()}},n,t)})}_subscribe(e){const{source:t}=this;return t&&t.subscribe(e)}[g](){return this}pipe(...e){return 0===e.length?this:b(e)(this)}toPromise(e){return new(e=x(e))((e,t)=>{let n;this.subscribe(e=>n=e,e=>t(e),()=>e(n))})}}return e.create=t=>new e(t),e})();function x(e){if(e||(e=r.Promise||Promise),!e)throw new Error("no Promise impl found");return e}const w=(()=>{function e(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return e.prototype=Object.create(Error.prototype),e})();class C extends p{constructor(e,t){super(),this.subject=e,this.subscriber=t,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const e=this.subject,t=e.observers;if(this.subject=null,!t||0===t.length||e.isStopped||e.closed)return;const n=t.indexOf(this.subscriber);-1!==n&&t.splice(n,1)}}class T extends m{constructor(e){super(e),this.destination=e}}let k=(()=>{class e extends v{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[h](){return new T(this)}lift(e){const t=new P(this,this);return t.operator=e,t}next(e){if(this.closed)throw new w;if(!this.isStopped){const{observers:t}=this,n=t.length,o=t.slice();for(let a=0;a<n;a++)o[a].next(e)}}error(e){if(this.closed)throw new w;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:t}=this,n=t.length,o=t.slice();for(let a=0;a<n;a++)o[a].error(e);this.observers.length=0}complete(){if(this.closed)throw new w;this.isStopped=!0;const{observers:e}=this,t=e.length,n=e.slice();for(let o=0;o<t;o++)n[o].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new w;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new w;return this.hasError?(e.error(this.thrownError),p.EMPTY):this.isStopped?(e.complete(),p.EMPTY):(this.observers.push(e),new C(this,e))}asObservable(){const e=new v;return e.source=this,e}}return e.create=(e,t)=>new P(e,t),e})();class P extends k{constructor(e,t){super(),this.destination=e,this.source=t}next(e){const{destination:t}=this;t&&t.next&&t.next(e)}error(e){const{destination:t}=this;t&&t.error&&this.destination.error(e)}complete(){const{destination:e}=this;e&&e.complete&&this.destination.complete()}_subscribe(e){const{source:t}=this;return t?this.source.subscribe(e):p.EMPTY}}function S(e){return e&&"function"==typeof e.schedule}class M extends m{constructor(e,t,n){super(),this.parent=e,this.outerValue=t,this.outerIndex=n,this.index=0}_next(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)}_error(e){this.parent.notifyError(e,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}const O=e=>t=>{for(let n=0,o=e.length;n<o&&!t.closed;n++)t.next(e[n]);t.complete()};function I(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const F=I(),D=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function A(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}const E=e=>{if(e&&"function"==typeof e[g])return o=e,e=>{const t=o[g]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(D(e))return O(e);if(A(e))return n=e,e=>(n.then(t=>{e.closed||(e.next(t),e.complete())},t=>e.error(t)).then(null,s),e);if(e&&"function"==typeof e[F])return t=e,e=>{const n=t[F]();for(;;){const t=n.next();if(t.done){e.complete();break}if(e.next(t.value),e.closed)break}return"function"==typeof n.return&&e.add(()=>{n.return&&n.return()}),e};{const t=u(e)?"an invalid object":`'${e}'`;throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var t,n,o};function R(e,t,n,o,a=new M(e,n,o)){if(!a.closed)return t instanceof v?t.subscribe(a):E(t)(a)}class N extends m{notifyNext(e,t,n,o,a){this.destination.next(t)}notifyError(e,t){this.destination.error(e)}notifyComplete(e){this.destination.complete()}}function j(e,t){return function(n){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new z(e,t))}}class z{constructor(e,t){this.project=e,this.thisArg=t}call(e,t){return t.subscribe(new L(e,this.project,this.thisArg))}}class L extends m{constructor(e,t,n){super(e),this.project=t,this.count=0,this.thisArg=n||this}_next(e){let t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}function X(e,t){return new v(n=>{const o=new p;let a=0;return o.add(t.schedule((function(){a!==e.length?(n.next(e[a++]),n.closed||o.add(this.schedule())):n.complete()}))),o})}function U(e,t){return t?function(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[g]}(e))return function(e,t){return new v(n=>{const o=new p;return o.add(t.schedule(()=>{const a=e[g]();o.add(a.subscribe({next(e){o.add(t.schedule(()=>n.next(e)))},error(e){o.add(t.schedule(()=>n.error(e)))},complete(){o.add(t.schedule(()=>n.complete()))}}))})),o})}(e,t);if(A(e))return function(e,t){return new v(n=>{const o=new p;return o.add(t.schedule(()=>e.then(e=>{o.add(t.schedule(()=>{n.next(e),o.add(t.schedule(()=>n.complete()))}))},e=>{o.add(t.schedule(()=>n.error(e)))}))),o})}(e,t);if(D(e))return X(e,t);if(function(e){return e&&"function"==typeof e[F]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new v(n=>{const o=new p;let a;return o.add(()=>{a&&"function"==typeof a.return&&a.return()}),o.add(t.schedule(()=>{a=e[F](),o.add(t.schedule((function(){if(n.closed)return;let e,t;try{const n=a.next();e=n.value,t=n.done}catch(o){return void n.error(o)}t?n.complete():(n.next(e),this.schedule())})))})),o})}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}(e,t):e instanceof v?e:new v(E(e))}function B(e,t,n=Number.POSITIVE_INFINITY){return"function"==typeof t?o=>o.pipe(B((n,o)=>U(e(n,o)).pipe(j((e,a)=>t(n,e,o,a))),n)):("number"==typeof t&&(n=t),t=>t.lift(new V(e,n)))}class V{constructor(e,t=Number.POSITIVE_INFINITY){this.project=e,this.concurrent=t}call(e,t){return t.subscribe(new H(e,this.project,this.concurrent))}}class H extends N{constructor(e,t,n=Number.POSITIVE_INFINITY){super(e),this.project=t,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)}_tryNext(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(o){return void this.destination.error(o)}this.active++,this._innerSub(t,e,n)}_innerSub(e,t,n){const o=new M(this,t,n),a=this.destination;a.add(o);const r=R(this,e,void 0,void 0,o);r!==o&&a.add(r)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(e,t,n,o,a){this.destination.next(t)}notifyComplete(e){const t=this.buffer;this.remove(e),this.active--,t.length>0?this._next(t.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function q(e=Number.POSITIVE_INFINITY){return B(_,e)}function G(e,t){return t?X(e,t):new v(O(e))}function W(){return function(e){return e.lift(new $(e))}}class ${constructor(e){this.connectable=e}call(e,t){const{connectable:n}=this;n._refCount++;const o=new Z(e,n),a=t.subscribe(o);return o.closed||(o.connection=n.connect()),a}}class Z extends m{constructor(e,t){super(e),this.connectable=t}_unsubscribe(){const{connectable:e}=this;if(!e)return void(this.connection=null);this.connectable=null;const t=e._refCount;if(t<=0)return void(this.connection=null);if(e._refCount=t-1,t>1)return void(this.connection=null);const{connection:n}=this,o=e._connection;this.connection=null,!o||n&&o!==n||o.unsubscribe()}}class K extends v{constructor(e,t){super(),this.source=e,this.subjectFactory=t,this._refCount=0,this._isComplete=!1}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let e=this._connection;return e||(this._isComplete=!1,e=this._connection=new p,e.add(this.source.subscribe(new Q(this.getSubject(),this))),e.closed&&(this._connection=null,e=p.EMPTY)),e}refCount(){return W()(this)}}const J=(()=>{const e=K.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:e._subscribe},_isComplete:{value:e._isComplete,writable:!0},getSubject:{value:e.getSubject},connect:{value:e.connect},refCount:{value:e.refCount}}})();class Q extends T{constructor(e,t){super(e),this.connectable=t}_error(e){this._unsubscribe(),super._error(e)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const e=this.connectable;if(e){this.connectable=null;const t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}}}function Y(){return new k}function ee(e){return{toString:e}.toString()}function te(e,t,n){return ee(()=>{const o=function(e){return function(...t){if(e){const n=e(...t);for(const e in n)this[e]=n[e]}}}(t);function a(...e){if(this instanceof a)return o.apply(this,e),this;const t=new a(...e);return n.annotation=t,n;function n(e,n,o){const a=e.hasOwnProperty("__parameters__")?e.__parameters__:Object.defineProperty(e,"__parameters__",{value:[]}).__parameters__;for(;a.length<=o;)a.push(null);return(a[o]=a[o]||[]).push(t),e}}return n&&(a.prototype=Object.create(n.prototype)),a.prototype.ngMetadataName=e,a.annotationCls=a,a})}const ne=te("Inject",e=>({token:e})),oe=te("Optional"),ae=te("Self"),re=te("SkipSelf");var se=function(e){return e[e.Default=0]="Default",e[e.Host=1]="Host",e[e.Self=2]="Self",e[e.SkipSelf=4]="SkipSelf",e[e.Optional=8]="Optional",e}({});function ie(e){for(let t in e)if(e[t]===ie)return t;throw Error("Could not find renamed property on target object.")}function le(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function ue(e){return{factory:e.factory,providers:e.providers||[],imports:e.imports||[]}}function ce(e){return pe(e,e[he])||pe(e,e[ge])}function pe(e,t){return t&&t.token===e?t:null}function de(e){return e&&(e.hasOwnProperty(me)||e.hasOwnProperty(_e))?e[me]:null}const he=ie({"\u0275prov":ie}),me=ie({"\u0275inj":ie}),fe=ie({"\u0275provFallback":ie}),ge=ie({ngInjectableDef:ie}),_e=ie({ngInjectorDef:ie});function ye(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(ye).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return""+e.overriddenName;if(e.name)return""+e.name;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function be(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const ve=ie({__forward_ref__:ie});function xe(e){return e.__forward_ref__=xe,e.toString=function(){return ye(this())},e}function we(e){return"function"==typeof(t=e)&&t.hasOwnProperty(ve)&&t.__forward_ref__===xe?e():e;var t}const Ce="undefined"!=typeof globalThis&&globalThis,Te="undefined"!=typeof window&&window,ke="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Pe="undefined"!=typeof global&&global,Se=Ce||Pe||Te||ke,Me=ie({"\u0275cmp":ie}),Oe=ie({"\u0275dir":ie}),Ie=ie({"\u0275pipe":ie}),Fe=ie({"\u0275mod":ie}),De=ie({"\u0275loc":ie}),Ae=ie({"\u0275fac":ie}),Ee=ie({__NG_ELEMENT_ID__:ie});class Re{constructor(e,t){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=le({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}toString(){return"InjectionToken "+this._desc}}const Ne=new Re("INJECTOR",-1),je={},ze=/\n/gm,Le=ie({provide:String,useValue:ie});let Xe,Ue=void 0;function Be(e){const t=Ue;return Ue=e,t}function Ve(e){const t=Xe;return Xe=e,t}function He(e,t=se.Default){if(void 0===Ue)throw new Error("inject() must be called from an injection context");return null===Ue?Ge(e,void 0,t):Ue.get(e,t&se.Optional?null:void 0,t)}function qe(e,t=se.Default){return(Xe||He)(we(e),t)}function Ge(e,t,n){const o=ce(e);if(o&&"root"==o.providedIn)return void 0===o.value?o.value=o.factory():o.value;if(n&se.Optional)return null;if(void 0!==t)return t;throw new Error(`Injector: NOT_FOUND [${ye(e)}]`)}function We(e){const t=[];for(let n=0;n<e.length;n++){const o=we(e[n]);if(Array.isArray(o)){if(0===o.length)throw new Error("Arguments array must have arguments.");let e=void 0,n=se.Default;for(let t=0;t<o.length;t++){const a=o[t];a instanceof oe||"Optional"===a.ngMetadataName||a===oe?n|=se.Optional:a instanceof re||"SkipSelf"===a.ngMetadataName||a===re?n|=se.SkipSelf:a instanceof ae||"Self"===a.ngMetadataName||a===ae?n|=se.Self:e=a instanceof ne||a===ne?a.token:a}t.push(qe(e,n))}else t.push(qe(o))}return t}class $e{get(e,t=je){if(t===je){const t=new Error(`NullInjectorError: No provider for ${ye(e)}!`);throw t.name="NullInjectorError",t}return t}}class Ze{}class Ke{}function Je(e,t){e.forEach(e=>Array.isArray(e)?Je(e,t):t(e))}function Qe(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function Ye(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}function et(e,t,n){let o=nt(e,t);return o>=0?e[1|o]=n:(o=~o,function(e,t,n,o){let a=e.length;if(a==t)e.push(n,o);else if(1===a)e.push(o,e[0]),e[0]=n;else{for(a--,e.push(e[a-1],e[a]);a>t;)e[a]=e[a-2],a--;e[t]=n,e[t+1]=o}}(e,o,t,n)),o}function tt(e,t){const n=nt(e,t);if(n>=0)return e[1|n]}function nt(e,t){return function(e,t,n){let o=0,a=e.length>>1;for(;a!==o;){const n=o+(a-o>>1),r=e[n<<1];if(t===r)return n<<1;r>t?a=n:o=n+1}return~(a<<1)}(e,t)}const ot=function(){var e={OnPush:0,Default:1};return e[e.OnPush]="OnPush",e[e.Default]="Default",e}(),at=function(){var e={Emulated:0,Native:1,None:2,ShadowDom:3};return e[e.Emulated]="Emulated",e[e.Native]="Native",e[e.None]="None",e[e.ShadowDom]="ShadowDom",e}(),rt={},st=[];let it=0;function lt(e){return ee(()=>{const t=e.type,n=t.prototype,o={},a={type:t,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:o,inputs:null,outputs:null,exportAs:e.exportAs||null,onChanges:null,onInit:n.ngOnInit||null,doCheck:n.ngDoCheck||null,afterContentInit:n.ngAfterContentInit||null,afterContentChecked:n.ngAfterContentChecked||null,afterViewInit:n.ngAfterViewInit||null,afterViewChecked:n.ngAfterViewChecked||null,onDestroy:n.ngOnDestroy||null,onPush:e.changeDetection===ot.OnPush,directiveDefs:null,pipeDefs:null,selectors:e.selectors||st,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||at.Emulated,id:"c",styles:e.styles||st,_:null,setInput:null,schemas:e.schemas||null,tView:null},r=e.directives,s=e.features,i=e.pipes;return a.id+=it++,a.inputs=ht(e.inputs,o),a.outputs=ht(e.outputs),s&&s.forEach(e=>e(a)),a.directiveDefs=r?()=>("function"==typeof r?r():r).map(ut):null,a.pipeDefs=i?()=>("function"==typeof i?i():i).map(ct):null,a})}function ut(e){return gt(e)||function(e){return e[Oe]||null}(e)}function ct(e){return function(e){return e[Ie]||null}(e)}const pt={};function dt(e){const t={type:e.type,bootstrap:e.bootstrap||st,declarations:e.declarations||st,imports:e.imports||st,exports:e.exports||st,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&ee(()=>{pt[e.id]=e.type}),t}function ht(e,t){if(null==e)return rt;const n={};for(const o in e)if(e.hasOwnProperty(o)){let a=e[o],r=a;Array.isArray(a)&&(r=a[1],a=a[0]),n[a]=o,t&&(t[a]=r)}return n}const mt=lt;function ft(e){return{type:e.type,name:e.name,factory:null,pure:!1!==e.pure,onDestroy:e.type.prototype.ngOnDestroy||null}}function gt(e){return e[Me]||null}function _t(e,t){return e.hasOwnProperty(Ae)?e[Ae]:null}function yt(e,t){const n=e[Fe]||null;if(!n&&!0===t)throw new Error(`Type ${ye(e)} does not have '\u0275mod' property.`);return n}function bt(e){return Array.isArray(e)&&"object"==typeof e[1]}function vt(e){return Array.isArray(e)&&!0===e[1]}function xt(e){return 0!=(8&e.flags)}function wt(e){return 2==(2&e.flags)}function Ct(e){return 1==(1&e.flags)}function Tt(e){return null!==e.template}function kt(e){return 0!=(512&e[2])}let Pt=void 0;function St(e){return!!e.listen}const Mt={createRenderer:(e,t)=>void 0!==Pt?Pt:"undefined"!=typeof document?document:void 0};function Ot(e){for(;Array.isArray(e);)e=e[0];return e}function It(e,t){return Ot(t[e+20])}function Ft(e,t){return Ot(t[e.index])}function Dt(e,t){return e.data[t+20]}function At(e,t){return e[t+20]}function Et(e,t){const n=t[e];return bt(n)?n:n[0]}function Rt(e){const t=function(e){return e.__ngContext__||null}(e);return t?Array.isArray(t)?t:t.lView:null}function Nt(e){return 4==(4&e[2])}function jt(e){return 128==(128&e[2])}function zt(e,t){return null===e||null==t?null:e[t]}function Lt(e){e[18]=0}function Xt(e,t){e[5]+=t;let n=e,o=e[3];for(;null!==o&&(1===t&&1===n[5]||-1===t&&0===n[5]);)o[5]+=t,n=o,o=o[3]}const Ut={lFrame:un(null),bindingsEnabled:!0,checkNoChangesMode:!1};function Bt(){return Ut.bindingsEnabled}function Vt(){return Ut.lFrame.lView}function Ht(){return Ut.lFrame.tView}function qt(e){Ut.lFrame.contextLView=e}function Gt(){return Ut.lFrame.previousOrParentTNode}function Wt(e,t){Ut.lFrame.previousOrParentTNode=e,Ut.lFrame.isParent=t}function $t(){return Ut.lFrame.isParent}function Zt(){return Ut.checkNoChangesMode}function Kt(e){Ut.checkNoChangesMode=e}function Jt(){const e=Ut.lFrame;let t=e.bindingRootIndex;return-1===t&&(t=e.bindingRootIndex=e.tView.bindingStartIndex),t}function Qt(){return Ut.lFrame.bindingIndex}function Yt(){return Ut.lFrame.bindingIndex++}function en(e){const t=Ut.lFrame,n=t.bindingIndex;return t.bindingIndex=t.bindingIndex+e,n}function tn(e,t){const n=Ut.lFrame;n.bindingIndex=n.bindingRootIndex=e,nn(t)}function nn(e){Ut.lFrame.currentDirectiveIndex=e}function on(){return Ut.lFrame.currentQueryIndex}function an(e){Ut.lFrame.currentQueryIndex=e}function rn(e,t){const n=ln();Ut.lFrame=n,n.previousOrParentTNode=t,n.lView=e}function sn(e,t){const n=ln(),o=e[1];Ut.lFrame=n,n.previousOrParentTNode=t,n.lView=e,n.tView=o,n.contextLView=e,n.bindingIndex=o.bindingStartIndex}function ln(){const e=Ut.lFrame,t=null===e?null:e.child;return null===t?un(e):t}function un(e){const t={previousOrParentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:0,contextLView:null,elementDepthCount:0,currentNamespace:null,currentSanitizer:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null};return null!==e&&(e.child=t),t}function cn(){const e=Ut.lFrame;return Ut.lFrame=e.parent,e.previousOrParentTNode=null,e.lView=null,e}const pn=cn;function dn(){const e=cn();e.isParent=!0,e.tView=null,e.selectedIndex=0,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.currentSanitizer=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function hn(){return Ut.lFrame.selectedIndex}function mn(e){Ut.lFrame.selectedIndex=e}function fn(){const e=Ut.lFrame;return Dt(e.tView,e.selectedIndex)}function gn(e,t){for(let n=t.directiveStart,o=t.directiveEnd;n<o;n++){const t=e.data[n];t.afterContentInit&&(e.contentHooks||(e.contentHooks=[])).push(-n,t.afterContentInit),t.afterContentChecked&&((e.contentHooks||(e.contentHooks=[])).push(n,t.afterContentChecked),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(n,t.afterContentChecked)),t.afterViewInit&&(e.viewHooks||(e.viewHooks=[])).push(-n,t.afterViewInit),t.afterViewChecked&&((e.viewHooks||(e.viewHooks=[])).push(n,t.afterViewChecked),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(n,t.afterViewChecked)),null!=t.onDestroy&&(e.destroyHooks||(e.destroyHooks=[])).push(n,t.onDestroy)}}function _n(e,t,n){vn(e,t,3,n)}function yn(e,t,n,o){(3&e[2])===n&&vn(e,t,n,o)}function bn(e,t){let n=e[2];(3&n)===t&&(n&=2047,n+=1,e[2]=n)}function vn(e,t,n,o){const a=null!=o?o:-1;let r=0;for(let s=void 0!==o?65535&e[18]:0;s<t.length;s++)if("number"==typeof t[s+1]){if(r=t[s],null!=o&&r>=o)break}else t[s]<0&&(e[18]+=65536),(r<a||-1==a)&&(xn(e,n,t,s),e[18]=(4294901760&e[18])+s+2),s++}function xn(e,t,n,o){const a=n[o]<0,r=n[o+1],s=e[a?-n[o]:n[o]];a?e[2]>>11<e[18]>>16&&(3&e[2])===t&&(e[2]+=2048,r.call(s)):r.call(s)}class wn{constructor(e,t,n){this.factory=e,this.resolving=!1,this.canSeeViewProviders=t,this.injectImpl=n}}function Cn(e,t,n){const o=St(e);let a=0;for(;a<n.length;){const r=n[a];if("number"==typeof r){if(0!==r)break;a++;const s=n[a++],i=n[a++],l=n[a++];o?e.setAttribute(t,i,l,s):t.setAttributeNS(s,i,l)}else{const s=r,i=n[++a];kn(s)?o&&e.setProperty(t,s,i):o?e.setAttribute(t,s,i):t.setAttribute(s,i),a++}}return a}function Tn(e){return 3===e||4===e||6===e}function kn(e){return 64===e.charCodeAt(0)}function Pn(e,t){if(null===t||0===t.length);else if(null===e||0===e.length)e=t.slice();else{let n=-1;for(let o=0;o<t.length;o++){const a=t[o];"number"==typeof a?n=a:0===n||Sn(e,n,a,null,-1===n||2===n?t[++o]:null)}}return e}function Sn(e,t,n,o,a){let r=0,s=e.length;if(-1===t)s=-1;else for(;r<e.length;){const n=e[r++];if("number"==typeof n){if(n===t){s=-1;break}if(n>t){s=r-1;break}}}for(;r<e.length;){const t=e[r];if("number"==typeof t)break;if(t===n){if(null===o)return void(null!==a&&(e[r+1]=a));if(o===e[r+1])return void(e[r+2]=a)}r++,null!==o&&r++,null!==a&&r++}-1!==s&&(e.splice(s,0,t),r=s+1),e.splice(r++,0,n),null!==o&&e.splice(r++,0,o),null!==a&&e.splice(r++,0,a)}function Mn(e){return-1!==e}function On(e){return 32767&e}function In(e){return e>>16}function Fn(e,t){let n=In(e),o=t;for(;n>0;)o=o[15],n--;return o}function Dn(e){return"string"==typeof e?e:null==e?"":""+e}function An(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():Dn(e)}const En=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(Se))();function Rn(e){return e instanceof Function?e():e}let Nn=!0;function jn(e){const t=Nn;return Nn=e,t}let zn=0;function Ln(e,t){const n=Un(e,t);if(-1!==n)return n;const o=t[1];o.firstCreatePass&&(e.injectorIndex=t.length,Xn(o.data,e),Xn(t,null),Xn(o.blueprint,null));const a=Bn(e,t),r=e.injectorIndex;if(Mn(a)){const e=On(a),n=Fn(a,t),o=n[1].data;for(let a=0;a<8;a++)t[r+a]=n[e+a]|o[e+a]}return t[r+8]=a,r}function Xn(e,t){e.push(0,0,0,0,0,0,0,0,t)}function Un(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null==t[e.injectorIndex+8]?-1:e.injectorIndex}function Bn(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=t[6],o=1;for(;n&&-1===n.injectorIndex;)n=(t=t[15])?t[6]:null,o++;return n?n.injectorIndex|o<<16:-1}function Vn(e,t,n){!function(e,t,n){let o="string"!=typeof n?n[Ee]:n.charCodeAt(0)||0;null==o&&(o=n[Ee]=zn++);const a=255&o,r=1<<a,s=64&a,i=32&a,l=t.data;128&a?s?i?l[e+7]|=r:l[e+6]|=r:i?l[e+5]|=r:l[e+4]|=r:s?i?l[e+3]|=r:l[e+2]|=r:i?l[e+1]|=r:l[e]|=r}(e,t,n)}function Hn(e,t,n,o=se.Default,a){if(null!==e){const a=function(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e[Ee];return"number"==typeof t&&t>0?255&t:t}(n);if("function"==typeof a){rn(t,e);try{const e=a();if(null!=e||o&se.Optional)return e;throw new Error(`No provider for ${An(n)}!`)}finally{pn()}}else if("number"==typeof a){if(-1===a)return new Jn(e,t);let r=null,s=Un(e,t),i=-1,l=o&se.Host?t[16][6]:null;for((-1===s||o&se.SkipSelf)&&(i=-1===s?Bn(e,t):t[s+8],Kn(o,!1)?(r=t[1],s=On(i),t=Fn(i,t)):s=-1);-1!==s;){i=t[s+8];const e=t[1];if(Zn(a,s,e.data)){const e=Gn(s,t,n,r,o,l);if(e!==qn)return e}Kn(o,t[1].data[s+8]===l)&&Zn(a,s,t)?(r=e,s=On(i),t=Fn(i,t)):s=-1}}}if(o&se.Optional&&void 0===a&&(a=null),0==(o&(se.Self|se.Host))){const e=t[9],r=Ve(void 0);try{return e?e.get(n,a,o&se.Optional):Ge(n,a,o&se.Optional)}finally{Ve(r)}}if(o&se.Optional)return a;throw new Error(`NodeInjector: NOT_FOUND [${An(n)}]`)}const qn={};function Gn(e,t,n,o,a,r){const s=t[1],i=s.data[e+8],l=Wn(i,s,n,null==o?wt(i)&&Nn:o!=s&&3===i.type,a&se.Host&&r===i);return null!==l?$n(t,s,l,i):qn}function Wn(e,t,n,o,a){const r=e.providerIndexes,s=t.data,i=65535&r,l=e.directiveStart,u=r>>16,c=a?i+u:e.directiveEnd;for(let p=o?i:i+u;p<c;p++){const e=s[p];if(p<l&&n===e||p>=l&&e.type===n)return p}if(a){const e=s[l];if(e&&Tt(e)&&e.type===n)return l}return null}function $n(e,t,n,o){let a=e[n];const r=t.data;if(a instanceof wn){const s=a;if(s.resolving)throw new Error("Circular dep for "+An(r[n]));const i=jn(s.canSeeViewProviders);let l;s.resolving=!0,s.injectImpl&&(l=Ve(s.injectImpl)),rn(e,o);try{a=e[n]=s.factory(void 0,r,e,o),t.firstCreatePass&&n>=o.directiveStart&&function(e,t,n){const{onChanges:o,onInit:a,doCheck:r}=t;o&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,o),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,o)),a&&(n.preOrderHooks||(n.preOrderHooks=[])).push(-e,a),r&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,r),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,r))}(n,r[n],t)}finally{s.injectImpl&&Ve(l),jn(i),s.resolving=!1,pn()}}return a}function Zn(e,t,n){const o=64&e,a=32&e;let r;return r=128&e?o?a?n[t+7]:n[t+6]:a?n[t+5]:n[t+4]:o?a?n[t+3]:n[t+2]:a?n[t+1]:n[t],!!(r&1<<e)}function Kn(e,t){return!(e&se.Self||e&se.Host&&t)}class Jn{constructor(e,t){this._tNode=e,this._lView=t}get(e,t){return Hn(this._tNode,this._lView,e,void 0,t)}}function Qn(e){return e.ngDebugContext}function Yn(e){return e.ngOriginalError}function eo(e,...t){e.error(...t)}class to{constructor(){this._console=console}handleError(e){const t=this._findOriginalError(e),n=this._findContext(e),o=function(e){return e.ngErrorLogger||eo}(e);o(this._console,"ERROR",e),t&&o(this._console,"ORIGINAL ERROR",t),n&&o(this._console,"ERROR CONTEXT",n)}_findContext(e){return e?Qn(e)?Qn(e):this._findContext(Yn(e)):null}_findOriginalError(e){let t=Yn(e);for(;t&&Yn(t);)t=Yn(t);return t}}class no{constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return"SafeValue must use [property]=binding: "+this.changingThisBreaksApplicationSecurity+" (see http://g.co/ng/security#xss)"}}function oo(e){return e instanceof no?e.changingThisBreaksApplicationSecurity:e}let ao=!0,ro=!1;function so(){return ro=!0,ao}const io=/^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,lo=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i,uo=function(){var e={NONE:0,HTML:1,STYLE:2,SCRIPT:3,URL:4,RESOURCE_URL:5};return e[e.NONE]="NONE",e[e.HTML]="HTML",e[e.STYLE]="STYLE",e[e.SCRIPT]="SCRIPT",e[e.URL]="URL",e[e.RESOURCE_URL]="RESOURCE_URL",e}();function co(e){const t=function(){const e=Vt();return e&&e[12]}();return t?t.sanitize(uo.URL,e)||"":function(e,t){const n=function(e){return e instanceof no&&e.getTypeName()||null}(e);if(null!=n&&n!==t){if("ResourceURL"===n&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${n} (see http://g.co/ng/security#xss)`)}return n===t}(e,"URL")?oo(e):(n=Dn(e),(n=String(n)).match(io)||n.match(lo)?n:(so()&&console.warn(`WARNING: sanitizing unsafe URL value ${n} (see http://g.co/ng/security#xss)`),"unsafe:"+n));var n}function po(e,t){e.__ngContext__=t}function ho(e){throw new Error("Multiple components match node with tagname "+e.tagName)}function mo(){throw new Error("Cannot mix multi providers and regular providers")}function fo(e,t,n){let o=e.length;for(;;){const a=e.indexOf(t,n);if(-1===a)return a;if(0===a||e.charCodeAt(a-1)<=32){const n=t.length;if(a+n===o||e.charCodeAt(a+n)<=32)return a}n=a+1}}function go(e,t,n){let o=0;for(;o<e.length;){let a=e[o++];if(n&&"class"===a){if(a=e[o],-1!==fo(a.toLowerCase(),t,0))return!0}else if(1===a){for(;o<e.length&&"string"==typeof(a=e[o++]);)if(a.toLowerCase()===t)return!0;return!1}}return!1}function _o(e){return 0===e.type&&"ng-template"!==e.tagName}function yo(e,t,n){return t===(0!==e.type||n?e.tagName:"ng-template")}function bo(e,t,n){let o=4;const a=e.attrs||[],r=function(e){for(let t=0;t<e.length;t++)if(Tn(e[t]))return t;return e.length}(a);let s=!1;for(let i=0;i<t.length;i++){const l=t[i];if("number"!=typeof l){if(!s)if(4&o){if(o=2|1&o,""!==l&&!yo(e,l,n)||""===l&&1===t.length){if(vo(o))return!1;s=!0}}else{const u=8&o?l:t[++i];if(8&o&&null!==e.attrs){if(!go(e.attrs,u,n)){if(vo(o))return!1;s=!0}continue}const c=xo(8&o?"class":l,a,_o(e),n);if(-1===c){if(vo(o))return!1;s=!0;continue}if(""!==u){let e;e=c>r?"":a[c+1].toLowerCase();const t=8&o?e:null;if(t&&-1!==fo(t,u,0)||2&o&&u!==e){if(vo(o))return!1;s=!0}}}}else{if(!s&&!vo(o)&&!vo(l))return!1;if(s&&vo(l))continue;s=!1,o=l|1&o}}return vo(o)||s}function vo(e){return 0==(1&e)}function xo(e,t,n,o){if(null===t)return-1;let a=0;if(o||!n){let n=!1;for(;a<t.length;){const o=t[a];if(o===e)return a;if(3===o||6===o)n=!0;else{if(1===o||2===o){let e=t[++a];for(;"string"==typeof e;)e=t[++a];continue}if(4===o)break;if(0===o){a+=4;continue}}a+=n?1:2}return-1}return function(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){const o=e[n];if("number"==typeof o)return-1;if(o===t)return n;n++}return-1}(t,e)}function wo(e,t,n=!1){for(let o=0;o<t.length;o++)if(bo(e,t[o],n))return!0;return!1}function Co(e,t){return e?":not("+t.trim()+")":t}function To(e){let t=e[0],n=1,o=2,a="",r=!1;for(;n<e.length;){let s=e[n];if("string"==typeof s)if(2&o){const t=e[++n];a+="["+s+(t.length>0?'="'+t+'"':"")+"]"}else 8&o?a+="."+s:4&o&&(a+=" "+s);else""===a||vo(s)||(t+=Co(r,a),a=""),o=s,r=r||!vo(o);n++}return""!==a&&(t+=Co(r,a)),t}const ko={};function Po(e){const t=e[3];return vt(t)?t[3]:t}function So(e){return Oo(e[13])}function Mo(e){return Oo(e[4])}function Oo(e){for(;null!==e&&!vt(e);)e=e[4];return e}function Io(e){Fo(Ht(),Vt(),hn()+e,Zt())}function Fo(e,t,n,o){if(!o)if(3==(3&t[2])){const o=e.preOrderCheckHooks;null!==o&&_n(t,o,n)}else{const o=e.preOrderHooks;null!==o&&yn(t,o,0,n)}mn(n)}function Do(e,t){return e<<17|t<<2}function Ao(e){return e>>17&32767}function Eo(e){return 2|e}function Ro(e){return(131068&e)>>2}function No(e,t){return-131069&e|t<<2}function jo(e){return 1|e}function zo(e,t){const n=e.contentQueries;if(null!==n)for(let o=0;o<n.length;o+=2){const a=n[o],r=n[o+1];if(-1!==r){const n=e.data[r];an(a),n.contentQueries(2,t[r],r)}}}function Lo(e,t,n){return St(t)?t.createElement(e,n):null===n?t.createElement(e):t.createElementNS(n,e)}function Xo(e,t,n,o,a,r,s,i,l,u){const c=t.blueprint.slice();return c[0]=a,c[2]=140|o,Lt(c),c[3]=c[15]=e,c[8]=n,c[10]=s||e&&e[10],c[11]=i||e&&e[11],c[12]=l||e&&e[12]||null,c[9]=u||e&&e[9]||null,c[6]=r,c[16]=2==t.type?e[16]:c,c}function Uo(e,t,n,o,a,r){const s=n+20,i=e.data[s]||function(e,t,n,o,a,r){const s=Gt(),i=$t(),l=i?s:s&&s.parent,u=e.data[n]=Ko(0,l&&l!==t?l:null,o,n,a,r);return null===e.firstChild&&(e.firstChild=u),s&&(!i||null!=s.child||null===u.parent&&2!==s.type?i||(s.next=u):s.child=u),u}(e,t,s,o,a,r);return Wt(i,!0),i}function Bo(e,t,n){sn(t,t[6]);try{const o=e.viewQuery;null!==o&&ya(1,o,n);const a=e.template;null!==a&&qo(e,t,a,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&zo(e,t),e.staticViewQueries&&ya(2,e.viewQuery,n);const r=e.components;null!==r&&function(e,t){for(let n=0;n<t.length;n++)ha(e,t[n])}(t,r)}catch(o){throw e.firstCreatePass&&(e.incompleteFirstPass=!0),o}finally{t[2]&=-5,dn()}}function Vo(e,t,n,o){const a=t[2];if(256==(256&a))return;sn(t,t[6]);const r=Zt();try{Lt(t),Ut.lFrame.bindingIndex=e.bindingStartIndex,null!==n&&qo(e,t,n,2,o);const s=3==(3&a);if(!r)if(s){const n=e.preOrderCheckHooks;null!==n&&_n(t,n,null)}else{const n=e.preOrderHooks;null!==n&&yn(t,n,0,null),bn(t,0)}if(function(e){for(let t=So(e);null!==t;t=Mo(t)){if(!t[2])continue;const e=t[9];for(let t=0;t<e.length;t++){const n=e[t],o=n[3];0==(1024&n[2])&&Xt(o,1),n[2]|=1024}}}(t),function(e){for(let t=So(e);null!==t;t=Mo(t))for(let e=10;e<t.length;e++){const n=t[e],o=n[1];jt(n)&&Vo(o,n,o.template,n[8])}}(t),null!==e.contentQueries&&zo(e,t),!r)if(s){const n=e.contentCheckHooks;null!==n&&_n(t,n)}else{const n=e.contentHooks;null!==n&&yn(t,n,1),bn(t,1)}!function(e,t){try{const n=e.expandoInstructions;if(null!==n){let o=e.expandoStartIndex,a=-1,r=-1;for(let e=0;e<n.length;e++){const s=n[e];"number"==typeof s?s<=0?(r=0-s,mn(r),o+=9+n[++e],a=o):o+=s:(null!==s&&(tn(o,a),s(2,t[a])),a++)}}}finally{mn(-1)}}(e,t);const i=e.components;null!==i&&function(e,t){for(let n=0;n<t.length;n++)da(e,t[n])}(t,i);const l=e.viewQuery;if(null!==l&&ya(2,l,o),!r)if(s){const n=e.viewCheckHooks;null!==n&&_n(t,n)}else{const n=e.viewHooks;null!==n&&yn(t,n,2),bn(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),r||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,Xt(t[3],-1))}finally{dn()}}function Ho(e,t,n,o){const a=t[10],r=!Zt(),s=Nt(t);try{r&&!s&&a.begin&&a.begin(),s&&Bo(e,t,o),Vo(e,t,n,o)}finally{r&&!s&&a.end&&a.end()}}function qo(e,t,n,o,a){const r=hn();try{mn(-1),2&o&&t.length>20&&Fo(e,t,0,Zt()),n(o,a)}finally{mn(r)}}function Go(e,t,n){Bt()&&(function(e,t,n,o){const a=n.directiveStart,r=n.directiveEnd;e.firstCreatePass||Ln(n,t),po(o,t);const s=n.initialInputs;for(let i=a;i<r;i++){const o=e.data[i],r=Tt(o);r&&la(t,n,o);const l=$n(t,e,i,n);po(l,t),null!==s&&ua(0,i-a,l,o,0,s),r&&(Et(n.index,t)[8]=l)}}(e,t,n,Ft(n,t)),128==(128&n.flags)&&function(e,t,n){const o=n.directiveStart,a=n.directiveEnd,r=e.expandoInstructions,s=e.firstCreatePass,i=n.index-20,l=Ut.lFrame.currentDirectiveIndex;try{mn(i);for(let n=o;n<a;n++){const o=e.data[n],a=t[n];nn(n),null!==o.hostBindings||0!==o.hostVars||null!==o.hostAttrs?na(o,a):s&&r.push(null)}}finally{mn(-1),nn(l)}}(e,t,n))}function Wo(e,t,n=Ft){const o=t.localNames;if(null!==o){let a=t.index+1;for(let r=0;r<o.length;r+=2){const s=o[r+1],i=-1===s?n(t,e):e[s];e[a++]=i}}}function $o(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=Zo(1,-1,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}function Zo(e,t,n,o,a,r,s,i,l,u){const c=20+o,p=c+a,d=function(e,t){const n=[];for(let o=0;o<t;o++)n.push(o<e?null:ko);return n}(c,p);return d[1]={type:e,id:t,blueprint:d,template:n,queries:null,viewQuery:i,node:null,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:p,expandoInstructions:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof r?r():r,pipeRegistry:"function"==typeof s?s():s,firstChild:null,schemas:l,consts:u,incompleteFirstPass:!1}}function Ko(e,t,n,o,a,r){return{type:n,index:o,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,tagName:a,attrs:r,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}function Jo(e,t,n){for(let o in e)if(e.hasOwnProperty(o)){const a=e[o];(n=null===n?{}:n).hasOwnProperty(o)?n[o].push(t,a):n[o]=[t,a]}return n}function Qo(e,t,n,o,a,r,s,i){const l=Ft(t,n);let u,c=t.inputs;var p;!i&&null!=c&&(u=c[o])?(Ca(e,n,u,o,a),wt(t)&&function(e,t){const n=Et(t,e);16&n[2]||(n[2]|=64)}(n,t.index)):3===t.type&&(o="class"===(p=o)?"className":"for"===p?"htmlFor":"formaction"===p?"formAction":"innerHtml"===p?"innerHTML":"readonly"===p?"readOnly":"tabindex"===p?"tabIndex":p,a=null!=s?s(a,t.tagName||"",o):a,St(r)?r.setProperty(l,o,a):kn(o)||(l.setProperty?l.setProperty(o,a):l[o]=a))}function Yo(e,t,n,o){let a=!1;if(Bt()){const r=function(e,t,n){const o=e.directiveRegistry;let a=null;if(o)for(let r=0;r<o.length;r++){const s=o[r];wo(n,s.selectors,!1)&&(a||(a=[]),Vn(Ln(n,t),e,s.type),Tt(s)?(2&n.flags&&ho(n),aa(e,n),a.unshift(s)):a.push(s))}return a}(e,t,n),s=null===o?null:{"":-1};if(null!==r){let o=0;a=!0,sa(n,e.data.length,r.length);for(let e=0;e<r.length;e++){const t=r[e];t.providersResolver&&t.providersResolver(t)}oa(e,n,r.length);let i=!1,l=!1;for(let a=0;a<r.length;a++){const u=r[a];n.mergedAttrs=Pn(n.mergedAttrs,u.hostAttrs),ia(e,t,u),ra(e.data.length-1,u,s),null!==u.contentQueries&&(n.flags|=8),null===u.hostBindings&&null===u.hostAttrs&&0===u.hostVars||(n.flags|=128),!i&&(u.onChanges||u.onInit||u.doCheck)&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n.index-20),i=!0),l||!u.onChanges&&!u.doCheck||((e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n.index-20),l=!0),ea(e,u),o+=u.hostVars}!function(e,t){const n=t.directiveEnd,o=e.data,a=t.attrs,r=[];let s=null,i=null;for(let l=t.directiveStart;l<n;l++){const e=o[l],n=e.inputs,u=null===a||_o(t)?null:ca(n,a);r.push(u),s=Jo(n,l,s),i=Jo(e.outputs,l,i)}null!==s&&(s.hasOwnProperty("class")&&(t.flags|=16),s.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=r,t.inputs=s,t.outputs=i}(e,n),ta(e,t,o)}s&&function(e,t,n){if(t){const o=e.localNames=[];for(let e=0;e<t.length;e+=2){const a=n[t[e+1]];if(null==a)throw new Error(`Export of name '${t[e+1]}' not found!`);o.push(t[e],a)}}}(n,o,s)}return n.mergedAttrs=Pn(n.mergedAttrs,n.attrs),a}function ea(e,t){const n=e.expandoInstructions;n.push(t.hostBindings),0!==t.hostVars&&n.push(t.hostVars)}function ta(e,t,n){for(let o=0;o<n;o++)t.push(ko),e.blueprint.push(ko),e.data.push(null)}function na(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function oa(e,t,n){const o=20-t.index,a=e.data.length-(65535&t.providerIndexes);(e.expandoInstructions||(e.expandoInstructions=[])).push(o,a,n)}function aa(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}function ra(e,t,n){if(n){if(t.exportAs)for(let o=0;o<t.exportAs.length;o++)n[t.exportAs[o]]=e;Tt(t)&&(n[""]=e)}}function sa(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}function ia(e,t,n){e.data.push(n);const o=n.factory||(n.factory=_t(n.type)),a=new wn(o,Tt(n),null);e.blueprint.push(a),t.push(a)}function la(e,t,n){const o=Ft(t,e),a=$o(n),r=e[10],s=ma(e,Xo(e,a,null,n.onPush?64:16,o,t,r,r.createRenderer(o,n)));e[t.index]=s}function ua(e,t,n,o,a,r){const s=r[t];if(null!==s){const e=o.setInput;for(let t=0;t<s.length;){const a=s[t++],r=s[t++],i=s[t++];null!==e?o.setInput(n,i,a,r):n[r]=i}}}function ca(e,t){let n=null,o=0;for(;o<t.length;){const a=t[o];if(0!==a)if(5!==a){if("number"==typeof a)break;e.hasOwnProperty(a)&&(null===n&&(n=[]),n.push(a,e[a],t[o+1])),o+=2}else o+=2;else o+=4}return n}function pa(e,t,n,o){return new Array(e,!0,!1,t,null,0,o,n,null,null)}function da(e,t){const n=Et(t,e);if(jt(n)){const e=n[1];80&n[2]?Vo(e,n,e.template,n[8]):n[5]>0&&function e(t){for(let o=So(t);null!==o;o=Mo(o))for(let t=10;t<o.length;t++){const n=o[t];if(1024&n[2]){const e=n[1];Vo(e,n,e.template,n[8])}else n[5]>0&&e(n)}const n=t[1].components;if(null!==n)for(let o=0;o<n.length;o++){const a=Et(n[o],t);jt(a)&&a[5]>0&&e(a)}}(n)}}function ha(e,t){const n=Et(t,e),o=n[1];!function(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}(o,n),Bo(o,n,n[8])}function ma(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}function fa(e){for(;e;){e[2]|=64;const t=Po(e);if(kt(e)&&!t)return e;e=t}return null}function ga(e,t,n){const o=t[10];o.begin&&o.begin();try{Vo(e,t,e.template,n)}catch(a){throw wa(t,a),a}finally{o.end&&o.end()}}function _a(e){!function(e){for(let t=0;t<e.components.length;t++){const n=e.components[t],o=Rt(n),a=o[1];Ho(a,o,a.template,n)}}(e[8])}function ya(e,t,n){an(0),t(e,n)}const ba=(()=>Promise.resolve(null))();function va(e){return e[7]||(e[7]=[])}function xa(e){return e.cleanup||(e.cleanup=[])}function wa(e,t){const n=e[9],o=n?n.get(to,null):null;o&&o.handleError(t)}function Ca(e,t,n,o,a){for(let r=0;r<n.length;){const s=n[r++],i=n[r++],l=t[s],u=e.data[s];null!==u.setInput?u.setInput(l,a,o,i):l[i]=a}}function Ta(e,t,n){const o=It(t,e),a=e[11];St(a)?a.setValue(o,n):o.textContent=n}function ka(e,t){const n=t[3];return-1===e.index?vt(n)?n:null:n}function Pa(e,t){const n=ka(e,t);return n?ja(t[11],n[7]):null}function Sa(e,t,n,o,a){if(null!=o){let r,s=!1;vt(o)?r=o:bt(o)&&(s=!0,o=o[0]);const i=Ot(o);0===e&&null!==n?null==a?Ra(t,n,i):Ea(t,n,i,a||null):1===e&&null!==n?Ea(t,n,i,a||null):2===e?function(e,t,n){const o=ja(e,t);o&&function(e,t,n,o){St(e)?e.removeChild(t,n,o):t.removeChild(n)}(e,o,t,n)}(t,i,s):3===e&&t.destroyNode(i),null!=r&&function(e,t,n,o,a){const r=n[7];r!==Ot(n)&&Sa(t,e,o,r,a);for(let s=10;s<n.length;s++){const a=n[s];Ua(a[1],a,e,t,o,r)}}(t,e,r,n,a)}}function Ma(e,t,n,o){const a=Pa(e.node,t);a&&Ua(e,t,t[11],n?1:2,a,o)}function Oa(e,t){const n=e[9],o=n.indexOf(t);1024&t[2]&&Xt(t[3],-1),n.splice(o,1)}function Ia(e,t){if(e.length<=10)return;const n=10+t,o=e[n];if(o){const a=o[17];null!==a&&a!==e&&Oa(a,o),t>0&&(e[n-1][4]=o[4]);const r=Ye(e,10+t);Ma(o[1],o,!1,null);const s=r[19];null!==s&&s.detachView(r[1]),o[3]=null,o[4]=null,o[2]&=-129}return o}function Fa(e,t){if(!(256&t[2])){const n=t[11];St(n)&&n.destroyNode&&Ua(e,t,n,3,null,null),function(e){let t=e[13];if(!t)return Aa(e[1],e);for(;t;){let n=null;if(bt(t))n=t[13];else{const e=t[10];e&&(n=e)}if(!n){for(;t&&!t[4]&&t!==e;)bt(t)&&Aa(t[1],t),t=Da(t,e);null===t&&(t=e),bt(t)&&Aa(t[1],t),n=t&&t[4]}t=n}}(t)}}function Da(e,t){let n;return bt(e)&&(n=e[6])&&2===n.type?ka(n,e):e[3]===t?null:e[3]}function Aa(e,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let o=0;o<n.length;o+=2){const e=t[n[o]];if(!(e instanceof wn)){const t=n[o+1];if(Array.isArray(t))for(let n=0;n<t.length;n+=2)t[n+1].call(e[t[n]]);else t.call(e)}}}(e,t),function(e,t){const n=e.cleanup;if(null!==n){const e=t[7];for(let o=0;o<n.length-1;o+=2)if("string"==typeof n[o]){const a=n[o+1],r="function"==typeof a?a(t):Ot(t[a]),s=e[n[o+2]],i=n[o+3];"boolean"==typeof i?r.removeEventListener(n[o],s,i):i>=0?e[i]():e[-i].unsubscribe(),o+=2}else n[o].call(e[n[o+1]]);t[7]=null}}(e,t);const n=t[6];n&&3===n.type&&St(t[11])&&t[11].destroy();const o=t[17];if(null!==o&&vt(t[3])){o!==t[3]&&Oa(o,t);const n=t[19];null!==n&&n.detachView(e)}}}function Ea(e,t,n,o){St(e)?e.insertBefore(t,n,o):t.insertBefore(n,o,!0)}function Ra(e,t,n){St(e)?e.appendChild(t,n):t.appendChild(n)}function Na(e,t,n,o){null!==o?Ea(e,t,n,o):Ra(e,t,n)}function ja(e,t){return St(e)?e.parentNode(t):t.parentNode}function za(e,t,n,o){const a=function(e,t,n){let o=t.parent;for(;null!=o&&(4===o.type||5===o.type);)o=(t=o).parent;if(null==o){const e=n[6];return 2===e.type?Pa(e,n):n[0]}if(t&&5===t.type&&4&t.flags)return Ft(t,n).parentNode;if(2&o.flags){const t=e.data,n=t[t[o.index].directiveStart].encapsulation;if(n!==at.ShadowDom&&n!==at.Native)return null}return Ft(o,n)}(e,o,t);if(null!=a){const e=t[11],r=function(e,t){if(2===e.type){const n=ka(e,t);return null===n?null:La(n.indexOf(t,10)-10,n)}return 4===e.type||5===e.type?Ft(e,t):null}(o.parent||t[6],t);if(Array.isArray(n))for(let t=0;t<n.length;t++)Na(e,a,n[t],r);else Na(e,a,n,r)}}function La(e,t){const n=10+e+1;if(n<t.length){const e=t[n],o=e[1].firstChild;if(null!==o)return function e(t,n){if(null!==n){const o=n.type;if(3===o)return Ft(n,t);if(0===o)return La(-1,t[n.index]);if(4===o||5===o){const o=n.child;if(null!==o)return e(t,o);{const e=t[n.index];return vt(e)?La(-1,e):Ot(e)}}{const o=t[16],a=o[6],r=Po(o),s=a.projection[n.projection];return null!=s?e(r,s):e(t,n.next)}}return null}(e,o)}return t[7]}function Xa(e,t,n,o,a,r,s){for(;null!=n;){const i=o[n.index],l=n.type;s&&0===t&&(i&&po(Ot(i),o),n.flags|=4),64!=(64&n.flags)&&(4===l||5===l?(Xa(e,t,n.child,o,a,r,!1),Sa(t,e,a,i,r)):1===l?Ba(e,t,o,n,a,r):Sa(t,e,a,i,r)),n=s?n.projectionNext:n.next}}function Ua(e,t,n,o,a,r){Xa(n,o,e.node.child,t,a,r,!1)}function Ba(e,t,n,o,a,r){const s=n[16],i=s[6].projection[o.projection];if(Array.isArray(i))for(let l=0;l<i.length;l++)Sa(t,e,a,i[l],r);else Xa(e,t,i,s[3],a,r,!0)}function Va(e,t,n){St(e)?e.setAttribute(t,"style",n):t.style.cssText=n}function Ha(e,t,n){St(e)?""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n):t.className=n}class qa{constructor(e,t){this._lView=e,this._cdRefInjectingView=t,this._appRef=null,this._viewContainerRef=null}get rootNodes(){const e=this._lView;return null==e[0]?function e(t,n,o,a,r=!1){for(;null!==o;){const s=n[o.index];if(null!==s&&a.push(Ot(s)),vt(s))for(let t=10;t<s.length;t++){const n=s[t],o=n[1].firstChild;null!==o&&e(n[1],n,o,a)}const i=o.type;if(4===i||5===i)e(t,n,o.child,a);else if(1===i){const t=n[16],r=t[6].projection[o.projection];if(Array.isArray(r))a.push(...r);else{const n=Po(t);e(n[1],n,r,a,!0)}}o=r?o.projectionNext:o.next}return a}(e[1],e,e[6].child,[]):[]}get context(){return this._lView[8]}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._viewContainerRef){const e=this._viewContainerRef.indexOf(this);e>-1&&this._viewContainerRef.detach(e),this._viewContainerRef=null}Fa(this._lView[1],this._lView)}onDestroy(e){var t,n,o;t=this._lView[1],o=e,va(n=this._lView).push(o),t.firstCreatePass&&xa(t).push(n[7].length-1,null)}markForCheck(){fa(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){ga(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(e,t,n){Kt(!0);try{ga(e,t,n)}finally{Kt(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(e){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._viewContainerRef=e}detachFromAppRef(){var e;this._appRef=null,Ua(this._lView[1],e=this._lView,e[11],2,null,null)}attachToAppRef(e){if(this._viewContainerRef)throw new Error("This view is already attached to a ViewContainer!");this._appRef=e}}class Ga extends qa{constructor(e){super(e),this._view=e}detectChanges(){_a(this._view)}checkNoChanges(){!function(e){Kt(!0);try{_a(e)}finally{Kt(!1)}}(this._view)}get context(){return null}}let Wa,$a,Za;function Ka(e,t,n){return Wa||(Wa=class extends e{}),new Wa(Ft(t,n))}function Ja(e,t,n,o){return $a||($a=class extends e{constructor(e,t,n){super(),this._declarationView=e,this._declarationTContainer=t,this.elementRef=n}createEmbeddedView(e){const t=this._declarationTContainer.tViews,n=Xo(this._declarationView,t,e,16,null,t.node);n[17]=this._declarationView[this._declarationTContainer.index];const o=this._declarationView[19];return null!==o&&(n[19]=o.createEmbeddedView(t)),Bo(t,n,e),new qa(n)}}),0===n.type?new $a(o,n,Ka(t,n,o)):null}function Qa(e,t,n,o){let a;Za||(Za=class extends e{constructor(e,t,n){super(),this._lContainer=e,this._hostTNode=t,this._hostView=n}get element(){return Ka(t,this._hostTNode,this._hostView)}get injector(){return new Jn(this._hostTNode,this._hostView)}get parentInjector(){const e=Bn(this._hostTNode,this._hostView),t=Fn(e,this._hostView),n=function(e,t,n){if(n.parent&&-1!==n.parent.injectorIndex){const e=n.parent.injectorIndex;let t=n.parent;for(;null!=t.parent&&e==t.parent.injectorIndex;)t=t.parent;return t}let o=In(e),a=t,r=t[6];for(;o>1;)a=a[15],r=a[6],o--;return r}(e,this._hostView,this._hostTNode);return Mn(e)&&null!=n?new Jn(n,t):new Jn(null,this._hostView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){return null!==this._lContainer[8]&&this._lContainer[8][e]||null}get length(){return this._lContainer.length-10}createEmbeddedView(e,t,n){const o=e.createEmbeddedView(t||{});return this.insert(o,n),o}createComponent(e,t,n,o,a){const r=n||this.parentInjector;if(!a&&null==e.ngModule&&r){const e=r.get(Ze,null);e&&(a=e)}const s=e.create(r,o,void 0,a);return this.insert(s.hostView,t),s}insert(e,t){const n=e._lView,o=n[1];if(e.destroyed)throw new Error("Cannot insert a destroyed View in a ViewContainer!");if(this.allocateContainerIfNeeded(),vt(n[3])){const t=this.indexOf(e);if(-1!==t)this.detach(t);else{const t=n[3],o=new Za(t,t[6],t[3]);o.detach(o.indexOf(e))}}const a=this._adjustIndex(t);return function(e,t,n,o){const a=10+o,r=n.length;o>0&&(n[a-1][4]=t),o<r-10?(t[4]=n[a],Qe(n,10+o,t)):(n.push(t),t[4]=null),t[3]=n;const s=t[17];null!==s&&n!==s&&function(e,t){const n=e[9];t[16]!==t[3][3][16]&&(e[2]=!0),null===n?e[9]=[t]:n.push(t)}(s,t);const i=t[19];null!==i&&i.insertView(e),t[2]|=128}(o,n,this._lContainer,a),Ma(o,n,!0,La(a,this._lContainer)),e.attachToViewContainerRef(this),Qe(this._lContainer[8],a,e),e}move(e,t){if(e.destroyed)throw new Error("Cannot move a destroyed View in a ViewContainer!");return this.insert(e,t)}indexOf(e){const t=this._lContainer[8];return null!==t?t.indexOf(e):-1}remove(e){this.allocateContainerIfNeeded();const t=this._adjustIndex(e,-1);!function(e,t){const n=Ia(e,t);n&&Fa(n[1],n)}(this._lContainer,t),Ye(this._lContainer[8],t)}detach(e){this.allocateContainerIfNeeded();const t=this._adjustIndex(e,-1),n=Ia(this._lContainer,t);return n&&null!=Ye(this._lContainer[8],t)?new qa(n):null}_adjustIndex(e,t=0){return null==e?this.length+t:e}allocateContainerIfNeeded(){null===this._lContainer[8]&&(this._lContainer[8]=[])}});const r=o[n.index];if(vt(r))a=r;else{let e;if(4===n.type)e=Ot(r);else if(e=o[11].createComment(""),kt(o)){const t=o[11],a=Ft(n,o);Ea(t,ja(t,a),e,function(e,t){return St(e)?e.nextSibling(t):t.nextSibling}(t,a))}else za(o[1],o,e,n);o[n.index]=a=pa(r,o,e,n),ma(o,a)}return new Za(a,n,o)}let Ya=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>er(),e})();const er=function(e=!1){return function(e,t,n){if(!n&&wt(e)){const n=Et(e.index,t);return new qa(n,n)}return 3===e.type||0===e.type||4===e.type||5===e.type?new qa(t[16],t):null}(Gt(),Vt(),e)},tr=new Re("Set Injector scope."),nr={},or={},ar=[];let rr=void 0;function sr(){return void 0===rr&&(rr=new $e),rr}function ir(e,t=null,n=null,o){return new lr(e,n,t||sr(),o)}class lr{constructor(e,t,n,o=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const a=[];t&&Je(t,n=>this.processProvider(n,e,t)),Je([e],e=>this.processInjectorType(e,[],a)),this.records.set(Ne,cr(void 0,this));const r=this.records.get(tr);this.scope=null!=r?r.value:null,this.source=o||("object"==typeof e?null:ye(e))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(e=>e.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(e,t=je,n=se.Default){this.assertNotDestroyed();const o=Be(this);try{if(!(n&se.SkipSelf)){let t=this.records.get(e);if(void 0===t){const n=("function"==typeof(a=e)||"object"==typeof a&&a instanceof Re)&&ce(e);t=n&&this.injectableDefInScope(n)?cr(ur(e),nr):null,this.records.set(e,t)}if(null!=t)return this.hydrate(e,t)}return(n&se.Self?sr():this.parent).get(e,t=n&se.Optional&&t===je?null:t)}catch(r){if("NullInjectorError"===r.name){if((r.ngTempTokenPath=r.ngTempTokenPath||[]).unshift(ye(e)),o)throw r;return function(e,t,n,o){const a=e.ngTempTokenPath;throw t.__source&&a.unshift(t.__source),e.message=function(e,t,n,o=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.substr(2):e;let a=ye(t);if(Array.isArray(t))a=t.map(ye).join(" -> ");else if("object"==typeof t){let e=[];for(let n in t)if(t.hasOwnProperty(n)){let o=t[n];e.push(n+":"+("string"==typeof o?JSON.stringify(o):ye(o)))}a=`{${e.join(", ")}}`}return`${n}${o?"("+o+")":""}[${a}]: ${e.replace(ze,"\n  ")}`}("\n"+e.message,a,n,o),e.ngTokenPath=a,e.ngTempTokenPath=null,e}(r,e,"R3InjectorError",this.source)}throw r}finally{Be(o)}var a}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(e=>this.get(e))}toString(){const e=[];return this.records.forEach((t,n)=>e.push(ye(n))),`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(e,t,n){if(!(e=we(e)))return!1;let o=de(e);const a=null==o&&e.ngModule||void 0,r=void 0===a?e:a,s=-1!==n.indexOf(r);if(void 0!==a&&(o=de(a)),null==o)return!1;if(null!=o.imports&&!s){let e;n.push(r);try{Je(o.imports,o=>{this.processInjectorType(o,t,n)&&(void 0===e&&(e=[]),e.push(o))})}finally{}if(void 0!==e)for(let t=0;t<e.length;t++){const{ngModule:n,providers:o}=e[t];Je(o,e=>this.processProvider(e,n,o||ar))}}this.injectorDefTypes.add(r),this.records.set(r,cr(o.factory,nr));const i=o.providers;if(null!=i&&!s){const t=e;Je(i,e=>this.processProvider(e,t,i))}return void 0!==a&&void 0!==e.providers}processProvider(e,t,n){let o=dr(e=we(e))?e:we(e&&e.provide);const a=function(e,t,n){return pr(e)?cr(void 0,e.useValue):cr(function(e,t,n){let o=void 0;if(dr(e)){const t=we(e);return _t(t)||ur(t)}if(pr(e))o=()=>we(e.useValue);else if((a=e)&&a.useFactory)o=()=>e.useFactory(...We(e.deps||[]));else if(function(e){return!(!e||!e.useExisting)}(e))o=()=>qe(we(e.useExisting));else{const a=we(e&&(e.useClass||e.provide));if(a||function(e,t,n){let o="";throw e&&t&&(o=` - only instances of Provider and Type are allowed, got: [${t.map(e=>e==n?"?"+n+"?":"...").join(", ")}]`),new Error(`Invalid provider for the NgModule '${ye(e)}'`+o)}(t,n,e),!function(e){return!!e.deps}(e))return _t(a)||ur(a);o=()=>new a(...We(e.deps))}var a;return o}(e,t,n),nr)}(e,t,n);if(dr(e)||!0!==e.multi){const e=this.records.get(o);e&&void 0!==e.multi&&mo()}else{let t=this.records.get(o);t?void 0===t.multi&&mo():(t=cr(void 0,nr,!0),t.factory=()=>We(t.multi),this.records.set(o,t)),o=e,t.multi.push(e)}this.records.set(o,a)}hydrate(e,t){var n;return t.value===or?function(e){throw new Error("Cannot instantiate cyclic dependency! "+e)}(ye(e)):t.value===nr&&(t.value=or,t.value=t.factory()),"object"==typeof t.value&&t.value&&null!==(n=t.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(t.value),t.value}injectableDefInScope(e){return!!e.providedIn&&("string"==typeof e.providedIn?"any"===e.providedIn||e.providedIn===this.scope:this.injectorDefTypes.has(e.providedIn))}}function ur(e){const t=ce(e),n=null!==t?t.factory:_t(e);if(null!==n)return n;const o=de(e);if(null!==o)return o.factory;if(e instanceof Re)throw new Error(`Token ${ye(e)} is missing a \u0275prov definition.`);if(e instanceof Function)return function(e){const t=e.length;if(t>0){const n=function(e,t){const n=[];for(let o=0;o<e;o++)n.push("?");return n}(t);throw new Error(`Can't resolve all parameters for ${ye(e)}: (${n.join(", ")}).`)}const n=function(e){const t=e&&(e[he]||e[ge]||e[fe]&&e[fe]());if(t){const n=function(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in v10. Please add @Injectable() to the "${n}" class.`),t}return null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new Error("unreachable")}function cr(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function pr(e){return null!==e&&"object"==typeof e&&Le in e}function dr(e){return"function"==typeof e}const hr=function(e,t,n){return function(e,t=null,n=null,o){const a=ir(e,t,n,o);return a._resolveInjectorDefTypes(),a}({name:n},t,e,n)};let mr=(()=>{class e{static create(e,t){return Array.isArray(e)?hr(e,t,""):hr(e.providers,e.parent,e.name||"")}}return e.THROW_IF_NOT_FOUND=je,e.NULL=new $e,e.\u0275prov=le({token:e,providedIn:"any",factory:()=>qe(Ne)}),e.__NG_ELEMENT_ID__=-1,e})();const fr=new Re("AnalyzeForEntryComponents");let gr=new Map;const _r=new Set;function yr(e){return"string"==typeof e?e:e.text()}function br(e,t,n){let o=n?e.styles:null,a=n?e.classes:null,r=0;if(null!==t)for(let s=0;s<t.length;s++){const e=t[s];"number"==typeof e?r=e:1==r?a=be(a,e):2==r&&(o=be(o,e+": "+t[++s]+";"))}n?e.styles=o:e.stylesWithoutHost=o,n?e.classes=a:e.classesWithoutHost=a}let vr=null;function xr(){if(!vr){const e=Se.Symbol;if(e&&e.iterator)vr=e.iterator;else{const e=Object.getOwnPropertyNames(Map.prototype);for(let t=0;t<e.length;++t){const n=e[t];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(vr=n)}}}return vr}function wr(e,t){return e===t||"number"==typeof e&&"number"==typeof t&&isNaN(e)&&isNaN(t)}class Cr{constructor(e){this.wrapped=e}static wrap(e){return new Cr(e)}static unwrap(e){return Cr.isWrapped(e)?e.wrapped:e}static isWrapped(e){return e instanceof Cr}}function Tr(e){return!!kr(e)&&(Array.isArray(e)||!(e instanceof Map)&&xr()in e)}function kr(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function Pr(e,t,n){return e[t]=n}function Sr(e,t,n){return!Object.is(e[t],n)&&(e[t]=n,!0)}function Mr(e,t,n,o){const a=Sr(e,t,n);return Sr(e,t+1,o)||a}function Or(e,t,n,o){const a=Vt();return Sr(a,Yt(),t)&&(Ht(),function(e,t,n,o,a,r){const s=Ft(e,t),i=t[11];if(null==o)St(i)?i.removeAttribute(s,n,r):s.removeAttribute(n);else{const t=null==a?Dn(o):a(o,e.tagName||"",n);St(i)?i.setAttribute(s,n,t,r):r?s.setAttributeNS(r,n,t):s.setAttribute(n,t)}}(fn(),a,e,t,n,o)),Or}function Ir(e,t,n,o){return Sr(e,Yt(),n)?t+Dn(n)+o:ko}function Fr(e,t,n,o,a,r,s,i){const l=Vt(),u=Ht(),c=e+20,p=u.firstCreatePass?function(e,t,n,o,a,r,s,i,l){const u=t.consts,c=Uo(t,n[6],e,0,s||null,zt(u,i));Yo(t,n,c,zt(u,l)),gn(t,c);const p=c.tViews=Zo(2,-1,o,a,r,t.directiveRegistry,t.pipeRegistry,null,t.schemas,u),d=Ko(0,null,2,-1,null,null);return d.injectorIndex=c.injectorIndex,p.node=d,null!==t.queries&&(t.queries.template(t,c),p.queries=t.queries.embeddedTView(c)),c}(e,u,l,t,n,o,a,r,s):u.data[c];Wt(p,!1);const d=l[11].createComment("");za(u,l,d,p),po(d,l),ma(l,l[c]=pa(d,l,d,p)),Ct(p)&&Go(u,l,p),null!=s&&Wo(l,p,i)}function Dr(e,t=se.Default){const n=Vt();return null==n?qe(e,t):Hn(Gt(),n,we(e),t)}function Ar(){throw new Error("invalid")}function Er(e,t,n){const o=Vt();return Sr(o,Yt(),t)&&Qo(Ht(),fn(),o,e,t,o[11],n,!1),Er}function Rr(e,t,n,o,a){const r=a?"class":"style";Ca(e,n,t.inputs[r],r,o)}function Nr(e,t,n,o){const a=Vt(),r=Ht(),s=20+e,i=a[11],l=a[s]=Lo(t,i,Ut.lFrame.currentNamespace),u=r.firstCreatePass?function(e,t,n,o,a,r,s){const i=t.consts,l=zt(i,r),u=Uo(t,n[6],e,3,a,l);return Yo(t,n,u,zt(i,s)),null!==u.attrs&&br(u,u.attrs,!1),null!==u.mergedAttrs&&br(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(e,r,a,0,t,n,o):r.data[s];Wt(u,!0);const c=u.mergedAttrs;null!==c&&Cn(i,l,c);const p=u.classes;null!==p&&Ha(i,l,p);const d=u.styles;null!==d&&Va(i,l,d),za(r,a,l,u),0===Ut.lFrame.elementDepthCount&&po(l,a),Ut.lFrame.elementDepthCount++,Ct(u)&&(Go(r,a,u),function(e,t,n){if(xt(t)){const o=t.directiveEnd;for(let a=t.directiveStart;a<o;a++){const t=e.data[a];t.contentQueries&&t.contentQueries(1,n[a],a)}}}(r,u,a)),null!==o&&Wo(a,u)}function jr(){let e=Gt();$t()?Ut.lFrame.isParent=!1:(e=e.parent,Wt(e,!1));const t=e;Ut.lFrame.elementDepthCount--;const n=Ht();n.firstCreatePass&&(gn(n,e),xt(e)&&n.queries.elementEnd(e)),null!=t.classesWithoutHost&&function(e){return 0!=(16&e.flags)}(t)&&Rr(n,t,Vt(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function(e){return 0!=(32&e.flags)}(t)&&Rr(n,t,Vt(),t.stylesWithoutHost,!1)}function zr(e,t,n,o){Nr(e,t,n,o),jr()}function Lr(){return Vt()}function Xr(e){return!!e&&"function"==typeof e.then}function Ur(e,t,n=!1,o){const a=Vt(),r=Ht(),s=Gt();return function(e,t,n,o,a,r,s=!1,i){const l=Ct(o),u=e.firstCreatePass&&(e.cleanup||(e.cleanup=[])),c=va(t);let p=!0;if(3===o.type){const d=Ft(o,t),h=i?i(d):rt,m=h.target||d,f=c.length,g=i?e=>i(Ot(e[o.index])).target:o.index;if(St(n)){let s=null;if(!i&&l&&(s=function(e,t,n,o){const a=e.cleanup;if(null!=a)for(let r=0;r<a.length-1;r+=2){const e=a[r];if(e===n&&a[r+1]===o){const e=t[7],n=a[r+2];return e.length>n?e[n]:null}"string"==typeof e&&(r+=2)}return null}(e,t,a,o.index)),null!==s)(s.__ngLastListenerFn__||s).__ngNextListenerFn__=r,s.__ngLastListenerFn__=r,p=!1;else{r=Vr(o,t,r,!1);const e=n.listen(h.name||m,a,r);c.push(r,e),u&&u.push(a,g,f,f+1)}}else r=Vr(o,t,r,!0),m.addEventListener(a,r,s),c.push(r),u&&u.push(a,g,f,s)}const d=o.outputs;let h;if(p&&null!==d&&(h=d[a])){const e=h.length;if(e)for(let n=0;n<e;n+=2){const e=t[h[n]][h[n+1]].subscribe(r),s=c.length;c.push(r,e),u&&u.push(a,o.index,s,-(s+1))}}}(r,a,a[11],s,e,t,n,o),Ur}function Br(e,t,n){try{return!1!==t(n)}catch(o){return wa(e,o),!1}}function Vr(e,t,n,o){return function a(r){if(r===Function)return n;const s=2&e.flags?Et(e.index,t):t;0==(32&t[2])&&fa(s);let i=Br(t,n,r),l=a.__ngNextListenerFn__;for(;l;)i=Br(t,l,r)&&i,l=l.__ngNextListenerFn__;return o&&!1===i&&(r.preventDefault(),r.returnValue=!1),i}}function Hr(e=1){return function(e){return(Ut.lFrame.contextLView=function(e,t){for(;e>0;)t=t[15],e--;return t}(e,Ut.lFrame.contextLView))[8]}(e)}function qr(e,t,n){return Gr(e,"",t,"",n),qr}function Gr(e,t,n,o,a){const r=Vt(),s=Ir(r,t,n,o);return s!==ko&&Qo(Ht(),fn(),r,e,s,r[11],a,!1),Gr}const Wr=[];function $r(e,t,n,o,a){const r=e[n+1],s=null===t;let i=o?Ao(r):Ro(r),l=!1;for(;0!==i&&(!1===l||s);){const n=e[i+1];Zr(e[i],t)&&(l=!0,e[i+1]=o?jo(n):Eo(n)),i=o?Ao(n):Ro(n)}l&&(e[n+1]=o?Eo(r):jo(r))}function Zr(e,t){return null===e||null==t||(Array.isArray(e)?e[1]:e)===t||!(!Array.isArray(e)||"string"!=typeof t)&&nt(e,t)>=0}const Kr={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function Jr(e){return e.substring(Kr.key,Kr.keyEnd)}function Qr(e,t){const n=Kr.textEnd;return n===t?-1:(t=Kr.keyEnd=function(e,t,n){for(;t<n&&e.charCodeAt(t)>32;)t++;return t}(e,Kr.key=t,n),Yr(e,t,n))}function Yr(e,t,n){for(;t<n&&e.charCodeAt(t)<=32;)t++;return t}function es(e,t){for(let n=function(e){return function(e){Kr.key=0,Kr.keyEnd=0,Kr.value=0,Kr.valueEnd=0,Kr.textEnd=e.length}(e),Qr(e,Yr(e,0,Kr.textEnd))}(t);n>=0;n=Qr(t,n))et(e,Jr(t),!0)}function ts(e,t){return t>=e.expandoStartIndex}function ns(e,t,n,o,a){let r=null;const s=n.directiveEnd;let i=n.directiveStylingLast;for(-1===i?i=n.directiveStart:i++;i<s&&(r=t[i],o=os(o,r.hostAttrs,a),r!==e);)i++;return null!==e&&(n.directiveStylingLast=i),o}function os(e,t,n){const o=n?1:2;let a=-1;if(null!==t)for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?a=s:a===o&&(Array.isArray(e)||(e=void 0===e?[]:["",e]),et(e,s,!!n||t[++r]))}return void 0===e?null:e}function as(e,t,n,o,a,r,s,i){if(3!==t.type)return;const l=e.data,u=l[i+1];ss(1==(1&u)?rs(l,t,n,a,Ro(u),s):void 0)||(ss(r)||function(e){return 2==(2&e)}(u)&&(r=rs(l,null,n,a,i,s)),function(e,t,n,o,a){const r=St(e);if(t)a?r?e.addClass(n,o):n.classList.add(o):r?e.removeClass(n,o):n.classList.remove(o);else{const t=-1==o.indexOf("-")?void 0:2;null==a?r?e.removeStyle(n,o,t):n.style.removeProperty(o):r?e.setStyle(n,o,a,t):n.style.setProperty(o,a)}}(o,s,It(hn(),n),a,r))}function rs(e,t,n,o,a,r){const s=null===t;let i=void 0;for(;a>0;){const t=e[a],r=Array.isArray(t),l=r?t[1]:t,u=null===l;let c=n[a+1];c===ko&&(c=u?Wr:void 0);let p=u?tt(c,o):l===o?c:void 0;if(r&&!ss(p)&&(p=tt(t,o)),ss(p)&&(i=p,s))return i;const d=e[a+1];a=s?Ao(d):Ro(d)}if(null!==t){let e=r?t.residualClasses:t.residualStyles;null!=e&&(i=tt(e,o))}return i}function ss(e){return void 0!==e}function is(e,t){return 0!=(e.flags&(t?16:32))}function ls(e,t=""){const n=Vt(),o=Ht(),a=e+20,r=o.firstCreatePass?Uo(o,n[6],e,3,null,null):o.data[a],s=n[a]=function(e,t){return St(t)?t.createText(e):t.createTextNode(e)}(t,n[11]);za(o,n,s,r),Wt(r,!1)}function us(e){return cs("",e,""),us}function cs(e,t,n){const o=Vt(),a=Ir(o,e,t,n);return a!==ko&&Ta(o,hn(),a),cs}function ps(e,t,n,o,a){const r=Vt(),s=function(e,t,n,o,a,r){const s=Mr(e,Qt(),n,a);return en(2),s?t+Dn(n)+o+Dn(a)+r:ko}(r,e,t,n,o,a);return s!==ko&&Ta(r,hn(),s),ps}function ds(e,t){const n=Rt(e)[1],o=n.data.length-1;gn(n,{directiveStart:o,directiveEnd:o+1})}class hs{}class ms{resolveComponentFactory(e){throw function(e){const t=Error(`No component factory found for ${ye(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(e)}}let fs=(()=>{class e{}return e.NULL=new ms,e})(),gs=(()=>{class e{constructor(e){this.nativeElement=e}}return e.__NG_ELEMENT_ID__=()=>_s(e),e})();const _s=function(e){return Ka(e,Gt(),Vt())};class ys{}const bs=function(){var e={Important:1,DashCase:2};return e[e.Important]="Important",e[e.DashCase]="DashCase",e}();let vs=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>xs(),e})();const xs=function(){const e=Vt(),t=Et(Gt().index,e);return function(e){const t=e[11];if(St(t))return t;throw new Error("Cannot inject Renderer2 when the application uses Renderer3!")}(bt(t)?t:e)};let ws=(()=>{class e{}return e.\u0275prov=le({token:e,providedIn:"root",factory:()=>null}),e})();class Cs{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const Ts=new Cs("9.1.12");class ks{constructor(){}supports(e){return Tr(e)}create(e){return new Ss(e)}}const Ps=(e,t)=>t;class Ss{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||Ps}forEachItem(e){let t;for(t=this._itHead;null!==t;t=t._next)e(t)}forEachOperation(e){let t=this._itHead,n=this._removalsHead,o=0,a=null;for(;t||n;){const r=!n||t&&t.currentIndex<Fs(n,o,a)?t:n,s=Fs(r,o,a),i=r.currentIndex;if(r===n)o--,n=n._nextRemoved;else if(t=t._next,null==r.previousIndex)o++;else{a||(a=[]);const e=s-o,t=i-o;if(e!=t){for(let n=0;n<e;n++){const o=n<a.length?a[n]:a[n]=0,r=o+n;t<=r&&r<e&&(a[n]=o+1)}a[r.previousIndex]=t-e}}s!==i&&e(r,s,i)}}forEachPreviousItem(e){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachMovedItem(e){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}forEachIdentityChange(e){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)e(t)}diff(e){if(null==e&&(e=[]),!Tr(e))throw new Error(`Error trying to diff '${ye(e)}'. Only arrays and iterables are allowed`);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t,n,o,a=this._itHead,r=!1;if(Array.isArray(e)){this.length=e.length;for(let t=0;t<this.length;t++)n=e[t],o=this._trackByFn(t,n),null!==a&&wr(a.trackById,o)?(r&&(a=this._verifyReinsertion(a,n,o,t)),wr(a.item,n)||this._addIdentityChange(a,n)):(a=this._mismatch(a,n,o,t),r=!0),a=a._next}else t=0,function(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)t(e[n]);else{const n=e[xr()]();let o;for(;!(o=n.next()).done;)t(o.value)}}(e,e=>{o=this._trackByFn(t,e),null!==a&&wr(a.trackById,o)?(r&&(a=this._verifyReinsertion(a,e,o,t)),wr(a.item,e)||this._addIdentityChange(a,e)):(a=this._mismatch(a,e,o,t),r=!0),a=a._next,t++}),this.length=t;return this._truncate(a),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e,t;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=t)e.previousIndex=e.currentIndex,t=e._nextMoved;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,t,n,o){let a;return null===e?a=this._itTail:(a=e._prev,this._remove(e)),null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(n,o))?(wr(e.item,t)||this._addIdentityChange(e,t),this._moveAfter(e,a,o)):null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(wr(e.item,t)||this._addIdentityChange(e,t),this._reinsertAfter(e,a,o)):e=this._addAfter(new Ms(t,n),a,o),e}_verifyReinsertion(e,t,n,o){let a=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==a?e=this._reinsertAfter(a,e._prev,o):e.currentIndex!=o&&(e.currentIndex=o,this._addToMoves(e,o)),e}_truncate(e){for(;null!==e;){const t=e._next;this._addToRemovals(this._unlink(e)),e=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,t,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const o=e._prevRemoved,a=e._nextRemoved;return null===o?this._removalsHead=a:o._nextRemoved=a,null===a?this._removalsTail=o:a._prevRemoved=o,this._insertAfter(e,t,n),this._addToMoves(e,n),e}_moveAfter(e,t,n){return this._unlink(e),this._insertAfter(e,t,n),this._addToMoves(e,n),e}_addAfter(e,t,n){return this._insertAfter(e,t,n),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,t,n){const o=null===t?this._itHead:t._next;return e._next=o,e._prev=t,null===o?this._itTail=e:o._prev=e,null===t?this._itHead=e:t._next=e,null===this._linkedRecords&&(this._linkedRecords=new Is),this._linkedRecords.put(e),e.currentIndex=n,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const t=e._prev,n=e._next;return null===t?this._itHead=n:t._next=n,null===n?this._itTail=t:n._prev=t,e}_addToMoves(e,t){return e.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new Is),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,t){return e.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class Ms{constructor(e,t){this.item=e,this.trackById=t,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class Os{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,t){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===t||t<=n.currentIndex)&&wr(n.trackById,e))return n;return null}remove(e){const t=e._prevDup,n=e._nextDup;return null===t?this._head=n:t._nextDup=n,null===n?this._tail=t:n._prevDup=t,null===this._head}}class Is{constructor(){this.map=new Map}put(e){const t=e.trackById;let n=this.map.get(t);n||(n=new Os,this.map.set(t,n)),n.add(e)}get(e,t){const n=this.map.get(e);return n?n.get(e,t):null}remove(e){const t=e.trackById;return this.map.get(t).remove(e)&&this.map.delete(t),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function Fs(e,t,n){const o=e.previousIndex;if(null===o)return o;let a=0;return n&&o<n.length&&(a=n[o]),o+t+a}class Ds{constructor(){}supports(e){return e instanceof Map||kr(e)}create(){return new As}}class As{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let t;for(t=this._mapHead;null!==t;t=t._next)e(t)}forEachPreviousItem(e){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)e(t)}forEachChangedItem(e){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}diff(e){if(e){if(!(e instanceof Map||kr(e)))throw new Error(`Error trying to diff '${ye(e)}'. Only maps and objects are allowed`)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(e,(e,n)=>{if(t&&t.key===n)this._maybeAddToChanges(t,e),this._appendAfter=t,t=t._next;else{const o=this._getOrCreateRecordForKey(n,e);t=this._insertBeforeOrAppend(t,o)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let e=t;null!==e;e=e._nextRemoved)e===this._mapHead&&(this._mapHead=null),this._records.delete(e.key),e._nextRemoved=e._next,e.previousValue=e.currentValue,e.currentValue=null,e._prev=null,e._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,t){if(e){const n=e._prev;return t._next=e,t._prev=n,e._prev=t,n&&(n._next=t),e===this._mapHead&&(this._mapHead=t),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(e,t){if(this._records.has(e)){const n=this._records.get(e);this._maybeAddToChanges(n,t);const o=n._prev,a=n._next;return o&&(o._next=a),a&&(a._prev=o),n._next=null,n._prev=null,n}const n=new Es(e);return this._records.set(e,n),n.currentValue=t,this._addToAdditions(n),n}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,t){wr(t,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=t,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,t){e instanceof Map?e.forEach(t):Object.keys(e).forEach(n=>t(e[n],n))}}class Es{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}let Rs=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(null!=n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>{if(!n)throw new Error("Cannot extend IterableDiffers without a parent injector");return e.create(t,n)},deps:[[e,new re,new oe]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(null!=t)return t;throw new Error(`Cannot find a differ supporting object '${e}' of type '${n=e,n.name||typeof n}'`);var n}}return e.\u0275prov=le({token:e,providedIn:"root",factory:()=>new e([new ks])}),e})(),Ns=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>{if(!n)throw new Error("Cannot extend KeyValueDiffers without a parent injector");return e.create(t,n)},deps:[[e,new re,new oe]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(t)return t;throw new Error(`Cannot find a differ supporting object '${e}'`)}}return e.\u0275prov=le({token:e,providedIn:"root",factory:()=>new e([new Ds])}),e})();const js=[new Ds],zs=new Rs([new ks]),Ls=new Ns(js);let Xs=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>Us(e,gs),e})();const Us=function(e,t){return Ja(e,t,Gt(),Vt())};let Bs=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>Vs(e,gs),e})();const Vs=function(e,t){return Qa(e,t,Gt(),Vt())},Hs={};class qs extends fs{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const t=gt(e);return new $s(t,this.ngModule)}}function Gs(e){const t=[];for(let n in e)e.hasOwnProperty(n)&&t.push({propName:e[n],templateName:n});return t}const Ws=new Re("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>En});class $s extends hs{constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=e.selectors.map(To).join(","),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!t}get inputs(){return Gs(this.componentDef.inputs)}get outputs(){return Gs(this.componentDef.outputs)}create(e,t,n,o){const a=(o=o||this.ngModule)?function(e,t){return{get:(n,o,a)=>{const r=e.get(n,Hs,a);return r!==Hs||o===Hs?r:t.get(n,o,a)}}}(e,o.injector):e,r=a.get(ys,Mt),s=a.get(ws,null),i=r.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",u=n?function(e,t,n){if(St(e))return e.selectRootElement(t,n===at.ShadowDom);let o="string"==typeof t?e.querySelector(t):t;return o.textContent="",o}(i,n,this.componentDef.encapsulation):Lo(l,r.createRenderer(null,this.componentDef),function(e){const t=e.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(l)),c=this.componentDef.onPush?576:528,p="string"==typeof n&&/^#root-ng-internal-isolated-\d+/.test(n),d={components:[],scheduler:En,clean:ba,playerHandler:null,flags:0},h=Zo(0,-1,null,1,0,null,null,null,null,null),m=Xo(null,h,d,c,null,null,r,i,s,a);let f,g;sn(m,null);try{const e=function(e,t,n,o,a,r){const s=n[1];n[20]=e;const i=Uo(s,null,0,3,null,null),l=i.mergedAttrs=t.hostAttrs;null!==l&&(br(i,l,!0),null!==e&&(Cn(a,e,l),null!==i.classes&&Ha(a,e,i.classes),null!==i.styles&&Va(a,e,i.styles)));const u=o.createRenderer(e,t),c=Xo(n,$o(t),null,t.onPush?64:16,n[20],i,o,u,void 0);return s.firstCreatePass&&(Vn(Ln(i,n),s,t.type),aa(s,i),sa(i,n.length,1)),ma(n,c),n[20]=c}(u,this.componentDef,m,r,i);if(u)if(n)Cn(i,u,["ng-version",Ts.full]);else{const{attrs:e,classes:t}=function(e){const t=[],n=[];let o=1,a=2;for(;o<e.length;){let r=e[o];if("string"==typeof r)2===a?""!==r&&t.push(r,e[++o]):8===a&&n.push(r);else{if(!vo(a))break;a=r}o++}return{attrs:t,classes:n}}(this.componentDef.selectors[0]);e&&Cn(i,u,e),t&&t.length>0&&Ha(i,u,t.join(" "))}if(g=Dt(h,0),void 0!==t){const e=g.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const o=t[n];e.push(null!=o?Array.from(o):null)}}f=function(e,t,n,o,a){const r=n[1],s=function(e,t,n){const o=Gt();e.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),oa(e,o,1),ia(e,t,n));const a=$n(t,e,t.length-1,o);po(a,t);const r=Ft(o,t);return r&&po(r,t),a}(r,n,t);o.components.push(s),e[8]=s,a&&a.forEach(e=>e(s,t)),t.contentQueries&&t.contentQueries(1,s,n.length-1);const i=Gt();if(r.firstCreatePass&&(null!==t.hostBindings||null!==t.hostAttrs)){mn(i.index-20);const e=n[1];ea(e,t),ta(e,n,t.hostVars),na(t,s)}return s}(e,this.componentDef,m,d,[ds]),Bo(h,m,null)}finally{dn()}const _=new Zs(this.componentType,f,Ka(gs,g,m),m,g);return n&&!p||(h.node.child=g),_}}class Zs extends class{}{constructor(e,t,n,o,a){super(),this.location=n,this._rootLView=o,this._tNode=a,this.destroyCbs=[],this.instance=t,this.hostView=this.changeDetectorRef=new Ga(o),function(e,t,n,o){let a=e.node;null==a&&(e.node=a=Ko(0,null,2,-1,null,null)),o[6]=a}(o[1],0,0,o),this.componentType=e}get injector(){return new Jn(this._tNode,this._rootLView)}destroy(){this.destroyCbs&&(this.destroyCbs.forEach(e=>e()),this.destroyCbs=null,!this.hostView.destroyed&&this.hostView.destroy())}onDestroy(e){this.destroyCbs&&this.destroyCbs.push(e)}}const Ks=void 0;var Js=["en",[["a","p"],["AM","PM"],Ks],[["AM","PM"],Ks,Ks],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Ks,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Ks,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Ks,"{1} 'at' {0}",Ks],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(e){let t=Math.floor(Math.abs(e)),n=e.toString().replace(/^[^.]*\.?/,"").length;return 1===t&&0===n?1:5}];let Qs={};function Ys(e){const t=function(e){return e.toLowerCase().replace(/_/g,"-")}(e);let n=ei(t);if(n)return n;const o=t.split("-")[0];if(n=ei(o),n)return n;if("en"===o)return Js;throw new Error(`Missing locale data for the locale "${e}".`)}function ei(e){return e in Qs||(Qs[e]=Se.ng&&Se.ng.common&&Se.ng.common.locales&&Se.ng.common.locales[e]),Qs[e]}const ti=function(){var e={LocaleId:0,DayPeriodsFormat:1,DayPeriodsStandalone:2,DaysFormat:3,DaysStandalone:4,MonthsFormat:5,MonthsStandalone:6,Eras:7,FirstDayOfWeek:8,WeekendRange:9,DateFormat:10,TimeFormat:11,DateTimeFormat:12,NumberSymbols:13,NumberFormats:14,CurrencyCode:15,CurrencySymbol:16,CurrencyName:17,Currencies:18,Directionality:19,PluralCase:20,ExtraData:21};return e[e.LocaleId]="LocaleId",e[e.DayPeriodsFormat]="DayPeriodsFormat",e[e.DayPeriodsStandalone]="DayPeriodsStandalone",e[e.DaysFormat]="DaysFormat",e[e.DaysStandalone]="DaysStandalone",e[e.MonthsFormat]="MonthsFormat",e[e.MonthsStandalone]="MonthsStandalone",e[e.Eras]="Eras",e[e.FirstDayOfWeek]="FirstDayOfWeek",e[e.WeekendRange]="WeekendRange",e[e.DateFormat]="DateFormat",e[e.TimeFormat]="TimeFormat",e[e.DateTimeFormat]="DateTimeFormat",e[e.NumberSymbols]="NumberSymbols",e[e.NumberFormats]="NumberFormats",e[e.CurrencyCode]="CurrencyCode",e[e.CurrencySymbol]="CurrencySymbol",e[e.CurrencyName]="CurrencyName",e[e.Currencies]="Currencies",e[e.Directionality]="Directionality",e[e.PluralCase]="PluralCase",e[e.ExtraData]="ExtraData",e}();let ni="en-US";function oi(e){var t,n;n="Expected localeId to be defined",null==(t=e)&&function(e,t,n,o){throw new Error("ASSERTION ERROR: "+e+` [Expected=> null != ${t} <=Actual]`)}(n,t),"string"==typeof e&&(ni=e.toLowerCase().replace(/_/g,"-"))}const ai=new Map;class ri extends Ze{constructor(e,t){super(),this._parent=t,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new qs(this);const n=yt(e),o=e[De]||null;o&&oi(o),this._bootstrapComponents=Rn(n.bootstrap),this._r3Injector=ir(e,t,[{provide:Ze,useValue:this},{provide:fs,useValue:this.componentFactoryResolver}],ye(e)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(e)}get(e,t=mr.THROW_IF_NOT_FOUND,n=se.Default){return e===mr||e===Ze||e===Ne?this:this._r3Injector.get(e,t,n)}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class si extends Ke{constructor(e){super(),this.moduleType=e,null!==yt(e)&&function e(t){if(null!==t.\u0275mod.id){const e=t.\u0275mod.id;(function(e,t,n){if(t&&t!==n)throw new Error(`Duplicate module registered for ${e} - ${ye(t)} vs ${ye(t.name)}`)})(e,ai.get(e),t),ai.set(e,t)}let n=t.\u0275mod.imports;n instanceof Function&&(n=n()),n&&n.forEach(t=>e(t))}(e)}create(e){return new ri(this.moduleType,e)}}function ii(e,t){const n=e[t];return n===ko?void 0:n}function li(e,t){const n=Ht();let o;const a=e+20;n.firstCreatePass?(o=function(e,t){if(t)for(let n=t.length-1;n>=0;n--){const o=t[n];if(e===o.name)return o}throw new Error(`The pipe '${e}' could not be found!`)}(t,n.pipeRegistry),n.data[a]=o,o.onDestroy&&(n.destroyHooks||(n.destroyHooks=[])).push(a,o.onDestroy)):o=n.data[a];const r=o.factory||(o.factory=_t(o.type)),s=Ve(Dr),i=jn(!1),l=r();return jn(i),Ve(s),function(e,t,n,o){const a=n+20;a>=e.data.length&&(e.data[a]=null,e.blueprint[a]=null),t[a]=o}(n,Vt(),e,l),l}function ui(e,t,n){const o=Vt(),a=At(o,e);return pi(o,ci(o,e)?function(e,t,n,o,a,r){const s=t+n;return Sr(e,s,a)?Pr(e,s+1,r?o.call(r,a):o(a)):ii(e,s+1)}(o,Jt(),t,a.transform,n,a):a.transform(n))}function ci(e,t){return e[1].data[t+20].pure}function pi(e,t){return Cr.isWrapped(t)&&(t=Cr.unwrap(t),e[Qt()]=ko),t}class di extends k{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,t,n){let o,a=e=>null,r=()=>null;e&&"object"==typeof e?(o=this.__isAsync?t=>{setTimeout(()=>e.next(t))}:t=>{e.next(t)},e.error&&(a=this.__isAsync?t=>{setTimeout(()=>e.error(t))}:t=>{e.error(t)}),e.complete&&(r=this.__isAsync?()=>{setTimeout(()=>e.complete())}:()=>{e.complete()})):(o=this.__isAsync?t=>{setTimeout(()=>e(t))}:t=>{e(t)},t&&(a=this.__isAsync?e=>{setTimeout(()=>t(e))}:e=>{t(e)}),n&&(r=this.__isAsync?()=>{setTimeout(()=>n())}:()=>{n()}));const s=super.subscribe(o,a,r);return e instanceof p&&e.add(s),s}}function hi(){return this._results[xr()]()}class mi{constructor(){this.dirty=!0,this._results=[],this.changes=new di,this.length=0;const e=xr(),t=mi.prototype;t[e]||(t[e]=hi)}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e){this._results=function e(t,n){void 0===n&&(n=t);for(let o=0;o<t.length;o++){let a=t[o];Array.isArray(a)?(n===t&&(n=t.slice(0,o)),e(a,n)):n!==t&&n.push(a)}return n}(e),this.dirty=!1,this.length=this._results.length,this.last=this._results[this.length-1],this.first=this._results[0]}notifyOnChanges(){this.changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class fi{constructor(e){this.queryList=e,this.matches=null}clone(){return new fi(this.queryList)}setDirty(){this.queryList.setDirty()}}class gi{constructor(e=[]){this.queries=e}createEmbeddedView(e){const t=e.queries;if(null!==t){const n=null!==e.contentQueries?e.contentQueries[0]:t.length,o=[];for(let e=0;e<n;e++){const n=t.getByIndex(e);o.push(this.queries[n.indexInDeclarationView].clone())}return new gi(o)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)null!==Pi(e,t).matches&&this.queries[t].setDirty()}}class _i{constructor(e,t,n,o=null){this.predicate=e,this.descendants=t,this.isStatic=n,this.read=o}}class yi{constructor(e=[]){this.queries=e}elementStart(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let n=0;n<this.length;n++){const o=null!==t?t.length:0,a=this.getByIndex(n).embeddedTView(e,o);a&&(a.indexInDeclarationView=n,null!==t?t.push(a):t=[a])}return null!==t?new yi(t):null}template(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class bi{constructor(e,t=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new bi(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&!1===this.metadata.descendants){const t=this._declarationNodeIndex;let n=e.parent;for(;null!==n&&4===n.type&&n.index!==t;)n=n.parent;return t===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(e,t){if(Array.isArray(this.metadata.predicate)){const n=this.metadata.predicate;for(let o=0;o<n.length;o++)this.matchTNodeWithReadOption(e,t,vi(t,n[o]))}else{const n=this.metadata.predicate;n===Xs?0===t.type&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,Wn(t,e,n,!1,!1))}}matchTNodeWithReadOption(e,t,n){if(null!==n){const o=this.metadata.read;if(null!==o)if(o===gs||o===Bs||o===Xs&&0===t.type)this.addMatch(t.index,-2);else{const n=Wn(t,e,o,!1,!1);null!==n&&this.addMatch(t.index,n)}else this.addMatch(t.index,n)}}addMatch(e,t){null===this.matches?this.matches=[e,t]:this.matches.push(e,t)}}function vi(e,t){const n=e.localNames;if(null!==n)for(let o=0;o<n.length;o+=2)if(n[o]===t)return n[o+1];return null}function xi(e,t,n,o){return-1===n?function(e,t){return 3===e.type||4===e.type?Ka(gs,e,t):0===e.type?Ja(Xs,gs,e,t):null}(t,e):-2===n?function(e,t,n){return n===gs?Ka(gs,t,e):n===Xs?Ja(Xs,gs,t,e):n===Bs?Qa(Bs,gs,t,e):void 0}(e,t,o):$n(e,e[1],n,t)}function wi(e,t,n,o){const a=t[19].queries[o];if(null===a.matches){const o=e.data,r=n.matches,s=[];for(let e=0;e<r.length;e+=2){const a=r[e];s.push(a<0?null:xi(t,o[a],r[e+1],n.metadata.read))}a.matches=s}return a.matches}function Ci(e){const t=Vt(),n=Ht(),o=on();an(o+1);const a=Pi(n,o);if(e.dirty&&Nt(t)===a.metadata.isStatic){if(null===a.matches)e.reset([]);else{const r=a.crossesNgTemplate?function e(t,n,o,a){const r=t.queries.getByIndex(o),s=r.matches;if(null!==s){const i=wi(t,n,r,o);for(let t=0;t<s.length;t+=2){const o=s[t];if(o>0)a.push(i[t/2]);else{const r=s[t+1],i=n[-o];for(let t=10;t<i.length;t++){const n=i[t];n[17]===n[3]&&e(n[1],n,r,a)}if(null!==i[9]){const t=i[9];for(let n=0;n<t.length;n++){const o=t[n];e(o[1],o,r,a)}}}}}return a}(n,t,o,[]):wi(n,t,a,o);e.reset(r),e.notifyOnChanges()}return!0}return!1}function Ti(e,t,n){!function(e,t,n,o,a,r){e.firstCreatePass&&function(e,t,n){null===e.queries&&(e.queries=new yi),e.queries.track(new bi(t,-1))}(e,new _i(n,o,!1,a)),function(e,t){const n=new mi;!function(e,t,n,o){const a=va(t);a.push(n),e.firstCreatePass&&xa(e).push(o,a.length-1)}(e,t,n,n.destroy),null===t[19]&&(t[19]=new gi),t[19].queries.push(new fi(n))}(e,t)}(Ht(),Vt(),e,t,n)}function ki(){return e=Vt(),t=on(),e[19].queries[t].queryList;var e,t}function Pi(e,t){return e.queries.getByIndex(t)}const Si=new Re("Application Initializer");let Mi=(()=>{class e{constructor(e){this.appInits=e,this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}runInitializers(){if(this.initialized)return;const e=[],t=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const t=this.appInits[n]();Xr(t)&&e.push(t)}Promise.all(e).then(()=>{t()}).catch(e=>{this.reject(e)}),0===e.length&&t(),this.initialized=!0}}return e.\u0275fac=function(t){return new(t||e)(qe(Si,8))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();const Oi=new Re("AppId"),Ii={provide:Oi,useFactory:function(){return`${Fi()}${Fi()}${Fi()}`},deps:[]};function Fi(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const Di=new Re("Platform Initializer"),Ai=new Re("Platform ID"),Ei=new Re("appBootstrapListener");let Ri=(()=>{class e{log(e){console.log(e)}warn(e){console.warn(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();const Ni=new Re("LocaleId"),ji=new Re("DefaultCurrencyCode");class zi{constructor(e,t){this.ngModuleFactory=e,this.componentFactories=t}}const Li=function(e){return new si(e)},Xi=Li,Ui=function(e){return Promise.resolve(Li(e))},Bi=function(e){const t=Li(e),n=Rn(yt(e).declarations).reduce((e,t)=>{const n=gt(t);return n&&e.push(new $s(n)),e},[]);return new zi(t,n)},Vi=Bi,Hi=function(e){return Promise.resolve(Bi(e))};let qi=(()=>{class e{constructor(){this.compileModuleSync=Xi,this.compileModuleAsync=Ui,this.compileModuleAndAllComponentsSync=Vi,this.compileModuleAndAllComponentsAsync=Hi}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();const Gi=new Re("compilerOptions"),Wi=(()=>Promise.resolve(0))();function $i(e){"undefined"==typeof Zone?Wi.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class Zi{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:t=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new di(!1),this.onMicrotaskEmpty=new di(!1),this.onStable=new di(!1),this.onError=new di(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched(),this._nesting=0,this._outer=this._inner=Zone.current,Zone.wtfZoneSpec&&(this._inner=this._inner.fork(Zone.wtfZoneSpec)),Zone.TaskTrackingZoneSpec&&(this._inner=this._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(this._inner=this._inner.fork(Zone.longStackTraceZoneSpec)),this.shouldCoalesceEventChangeDetection=t,this.lastRequestAnimationFrameId=-1,this.nativeRequestAnimationFrame=function(){let e=Se.requestAnimationFrame,t=Se.cancelAnimationFrame;if("undefined"!=typeof Zone&&e&&t){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const o=t[Zone.__symbol__("OriginalDelegate")];o&&(t=o)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(e){const t=!!e.shouldCoalesceEventChangeDetection&&e.nativeRequestAnimationFrame&&(()=>{!function(e){-1===e.lastRequestAnimationFrameId&&(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(Se,()=>{e.lastRequestAnimationFrameId=-1,Yi(e),Qi(e)}),Yi(e))}(e)});e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0,maybeDelayChangeDetection:t},onInvokeTask:(n,o,a,r,s,i)=>{try{return el(e),n.invokeTask(a,r,s,i)}finally{t&&"eventTask"===r.type&&t(),tl(e)}},onInvoke:(t,n,o,a,r,s,i)=>{try{return el(e),t.invoke(o,a,r,s,i)}finally{tl(e)}},onHasTask:(t,n,o,a)=>{t.hasTask(o,a),n===o&&("microTask"==a.change?(e._hasPendingMicrotasks=a.microTask,Yi(e),Qi(e)):"macroTask"==a.change&&(e.hasPendingMacrotasks=a.macroTask))},onHandleError:(t,n,o,a)=>(t.handleError(o,a),e.runOutsideAngular(()=>e.onError.emit(a)),!1)})}(this)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Zi.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Zi.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(e,t,n){return this._inner.run(e,t,n)}runTask(e,t,n,o){const a=this._inner,r=a.scheduleEventTask("NgZoneEvent: "+o,e,Ji,Ki,Ki);try{return a.runTask(r,t,n)}finally{a.cancelTask(r)}}runGuarded(e,t,n){return this._inner.runGuarded(e,t,n)}runOutsideAngular(e){return this._outer.run(e)}}function Ki(){}const Ji={};function Qi(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function Yi(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||e.shouldCoalesceEventChangeDetection&&-1!==e.lastRequestAnimationFrameId)}function el(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function tl(e){e._nesting--,Qi(e)}class nl{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new di,this.onMicrotaskEmpty=new di,this.onStable=new di,this.onError=new di}run(e,t,n){return e.apply(t,n)}runGuarded(e,t,n){return e.apply(t,n)}runOutsideAngular(e){return e()}runTask(e,t,n,o){return e.apply(t,n)}}let ol=(()=>{class e{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Zi.assertNotInAngularZone(),$i(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())$i(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(t=>!t.updateCb||!t.updateCb(e)||(clearTimeout(t.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,t,n){let o=-1;t&&t>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(e=>e.timeoutId!==o),e(this._didWork,this.getPendingTasks())},t)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:n})}whenStable(e,t,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');this.addCallback(e,t,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,t,n){return[]}}return e.\u0275fac=function(t){return new(t||e)(qe(Zi))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),al=(()=>{class e{constructor(){this._applications=new Map,il.addToWindow(this)}registerApplication(e,t){this._applications.set(e,t)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,t=!0){return il.findTestabilityInTree(this,e,t)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();class rl{addToWindow(e){}findTestabilityInTree(e,t,n){return null}}let sl,il=new rl,ll=function(e,t,n){const o=e.get(Gi,[]).concat(t),a=new si(n);if(0===gr.size)return Promise.resolve(a);const r=function(e){const t=[];return e.forEach(e=>e&&t.push(...e)),t}(o.map(e=>e.providers));if(0===r.length)return Promise.resolve(a);const s=function(){const e=Se.ng;if(!e||!e.\u0275compilerFacade)throw new Error("Angular JIT compilation failed: '@angular/compiler' not loaded!\n  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\n  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\n  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.");return e.\u0275compilerFacade}(),i=mr.create({providers:r}).get(s.ResourceLoader);return function(e){const t=[],n=new Map;function o(e){let t=n.get(e);if(!t){const o=(e=>Promise.resolve(i.get(e)))(e);n.set(e,t=o.then(yr))}return t}return gr.forEach((e,n)=>{const a=[];e.templateUrl&&a.push(o(e.templateUrl).then(t=>{e.template=t}));const r=e.styleUrls,s=e.styles||(e.styles=[]),i=e.styles.length;r&&r.forEach((t,n)=>{s.push(""),a.push(o(t).then(o=>{s[i+n]=o,r.splice(r.indexOf(t),1),0==r.length&&(e.styleUrls=void 0)}))});const l=Promise.all(a).then(()=>function(e){_r.delete(e)}(n));t.push(l)}),gr=new Map,Promise.all(t).then(()=>{})}().then(()=>a)};const ul=new Re("AllowMultipleToken");class cl{constructor(e,t){this.name=e,this.token=t}}function pl(e,t,n=[]){const o="Platform: "+t,a=new Re(o);return(t=[])=>{let r=dl();if(!r||r.injector.get(ul,!1))if(e)e(n.concat(t).concat({provide:a,useValue:!0}));else{const e=n.concat(t).concat({provide:a,useValue:!0},{provide:tr,useValue:"platform"});!function(e){if(sl&&!sl.destroyed&&!sl.injector.get(ul,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");sl=e.get(hl);const t=e.get(Di,null);t&&t.forEach(e=>e())}(mr.create({providers:e,name:o}))}return function(e){const t=dl();if(!t)throw new Error("No platform exists!");if(!t.injector.get(e,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return t}(a)}}function dl(){return sl&&!sl.destroyed?sl:null}let hl=(()=>{class e{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,t){const n=function(e,t){let n;return n="noop"===e?new nl:("zone.js"===e?void 0:e)||new Zi({enableLongStackTrace:so(),shouldCoalesceEventChangeDetection:t}),n}(t?t.ngZone:void 0,t&&t.ngZoneEventCoalescing||!1),o=[{provide:Zi,useValue:n}];return n.run(()=>{const t=mr.create({providers:o,parent:this.injector,name:e.moduleType.name}),a=e.create(t),r=a.injector.get(to,null);if(!r)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return a.onDestroy(()=>gl(this._modules,a)),n.runOutsideAngular(()=>n.onError.subscribe({next:e=>{r.handleError(e)}})),function(e,t,n){try{const o=n();return Xr(o)?o.catch(n=>{throw t.runOutsideAngular(()=>e.handleError(n)),n}):o}catch(o){throw t.runOutsideAngular(()=>e.handleError(o)),o}}(r,n,()=>{const e=a.injector.get(Mi);return e.runInitializers(),e.donePromise.then(()=>(oi(a.injector.get(Ni,"en-US")||"en-US"),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,t=[]){const n=ml({},t);return ll(this.injector,n,e).then(e=>this.bootstrapModuleFactory(e,n))}_moduleDoBootstrap(e){const t=e.injector.get(fl);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(e=>t.bootstrap(e));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${ye(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);e.instance.ngDoBootstrap(t)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(t){return new(t||e)(qe(mr))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();function ml(e,t){return Array.isArray(t)?t.reduce(ml,e):Object.assign(Object.assign({},e),t)}let fl=(()=>{class e{constructor(e,t,n,o,a,r){this._zone=e,this._console=t,this._injector=n,this._exceptionHandler=o,this._componentFactoryResolver=a,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._enforceNoNewChanges=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._enforceNoNewChanges=so(),this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const s=new v(e=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{e.next(this._stable),e.complete()})}),i=new v(e=>{let t;this._zone.runOutsideAngular(()=>{t=this._zone.onStable.subscribe(()=>{Zi.assertNotInAngularZone(),$i(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,e.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{Zi.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{e.next(!1)}))});return()=>{t.unsubscribe(),n.unsubscribe()}});this.isStable=function(...e){let t=Number.POSITIVE_INFINITY,n=null,o=e[e.length-1];return S(o)?(n=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(t=e.pop())):"number"==typeof o&&(t=e.pop()),null===n&&1===e.length&&e[0]instanceof v?e[0]:q(t)(G(e,n))}(s,i.pipe(e=>{return W()((t=Y,function(e){let n;n="function"==typeof t?t:function(){return t};const o=Object.create(e,J);return o.source=e,o.subjectFactory=n,o})(e));var t}))}bootstrap(e,t){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=e instanceof hs?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(n.componentType);const o=n.isBoundToModule?void 0:this._injector.get(Ze),a=n.create(mr.NULL,[],t||n.selector,o);a.onDestroy(()=>{this._unloadComponent(a)});const r=a.injector.get(ol,null);return r&&a.injector.get(al).registerApplication(a.location.nativeElement,r),this._loadComponent(a),so()&&this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."),a}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let e of this._views)e.detectChanges();if(this._enforceNoNewChanges)for(let e of this._views)e.checkNoChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const t=e;this._views.push(t),t.attachToAppRef(this)}detachView(e){const t=e;gl(this._views,t),t.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(Ei,[]).concat(this._bootstrapListeners).forEach(t=>t(e))}_unloadComponent(e){this.detachView(e.hostView),gl(this.components,e)}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy())}get viewCount(){return this._views.length}}return e.\u0275fac=function(t){return new(t||e)(qe(Zi),qe(Ri),qe(mr),qe(to),qe(fs),qe(Mi))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();function gl(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class _l{}class yl{}const bl={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let vl=(()=>{class e{constructor(e,t){this._compiler=e,this._config=t||bl}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[t,o]=e.split("#");return void 0===o&&(o="default"),n("zn8P")(t).then(e=>e[o]).then(e=>xl(e,t,o)).then(e=>this._compiler.compileModuleAsync(e))}loadFactory(e){let[t,o]=e.split("#"),a="NgFactory";return void 0===o&&(o="default",a=""),n("zn8P")(this._config.factoryPathPrefix+t+this._config.factoryPathSuffix).then(e=>e[o+a]).then(e=>xl(e,t,o))}}return e.\u0275fac=function(t){return new(t||e)(qe(qi),qe(yl,8))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();function xl(e,t,n){if(!e)throw new Error(`Cannot find '${n}' in '${t}'`);return e}const wl=pl(null,"core",[{provide:Ai,useValue:"unknown"},{provide:hl,deps:[mr]},{provide:al,deps:[]},{provide:Ri,deps:[]}]),Cl=[{provide:fl,useClass:fl,deps:[Zi,Ri,mr,to,fs,Mi]},{provide:Ws,deps:[Zi],useFactory:function(e){let t=[];return e.onStable.subscribe(()=>{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:Mi,useClass:Mi,deps:[[new oe,Si]]},{provide:qi,useClass:qi,deps:[]},Ii,{provide:Rs,useFactory:function(){return zs},deps:[]},{provide:Ns,useFactory:function(){return Ls},deps:[]},{provide:Ni,useFactory:function(e){return oi(e=e||"undefined"!=typeof $localize&&$localize.locale||"en-US"),e},deps:[[new ne(Ni),new oe,new re]]},{provide:ji,useValue:"USD"}];let Tl=(()=>{class e{constructor(e){}}return e.\u0275mod=dt({type:e}),e.\u0275inj=ue({factory:function(t){return new(t||e)(qe(fl))},providers:Cl}),e})(),kl=null;function Pl(){return kl}const Sl=new Re("DocumentToken");let Ml=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({factory:Ol,token:e,providedIn:"platform"}),e})();function Ol(){return qe(Fl)}const Il=new Re("Location Initialized");let Fl=(()=>{class e extends Ml{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=Pl().getLocation(),this._history=Pl().getHistory()}getBaseHrefFromDOM(){return Pl().getBaseHref(this._doc)}onPopState(e){Pl().getGlobalEventTarget(this._doc,"window").addEventListener("popstate",e,!1)}onHashChange(e){Pl().getGlobalEventTarget(this._doc,"window").addEventListener("hashchange",e,!1)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,t,n){Dl()?this._history.pushState(e,t,n):this.location.hash=n}replaceState(e,t,n){Dl()?this._history.replaceState(e,t,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}getState(){return this._history.state}}return e.\u0275fac=function(t){return new(t||e)(qe(Sl))},e.\u0275prov=le({factory:Al,token:e,providedIn:"platform"}),e})();function Dl(){return!!window.history.pushState}function Al(){return new Fl(qe(Sl))}function El(e,t){if(0==e.length)return t;if(0==t.length)return e;let n=0;return e.endsWith("/")&&n++,t.startsWith("/")&&n++,2==n?e+t.substring(1):1==n?e+t:e+"/"+t}function Rl(e){const t=e.match(/#|\?|$/),n=t&&t.index||e.length;return e.slice(0,n-("/"===e[n-1]?1:0))+e.slice(n)}function Nl(e){return e&&"?"!==e[0]?"?"+e:e}let jl=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({factory:zl,token:e,providedIn:"root"}),e})();function zl(e){const t=qe(Sl).location;return new Xl(qe(Ml),t&&t.origin||"")}const Ll=new Re("appBaseHref");let Xl=(()=>{class e extends jl{constructor(e,t){if(super(),this._platformLocation=e,null==t&&(t=this._platformLocation.getBaseHrefFromDOM()),null==t)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=t}onPopState(e){this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e)}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return El(this._baseHref,e)}path(e=!1){const t=this._platformLocation.pathname+Nl(this._platformLocation.search),n=this._platformLocation.hash;return n&&e?`${t}${n}`:t}pushState(e,t,n,o){const a=this.prepareExternalUrl(n+Nl(o));this._platformLocation.pushState(e,t,a)}replaceState(e,t,n,o){const a=this.prepareExternalUrl(n+Nl(o));this._platformLocation.replaceState(e,t,a)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return e.\u0275fac=function(t){return new(t||e)(qe(Ml),qe(Ll,8))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),Ul=(()=>{class e extends jl{constructor(e,t){super(),this._platformLocation=e,this._baseHref="",null!=t&&(this._baseHref=t)}onPopState(e){this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e)}getBaseHref(){return this._baseHref}path(e=!1){let t=this._platformLocation.hash;return null==t&&(t="#"),t.length>0?t.substring(1):t}prepareExternalUrl(e){const t=El(this._baseHref,e);return t.length>0?"#"+t:t}pushState(e,t,n,o){let a=this.prepareExternalUrl(n+Nl(o));0==a.length&&(a=this._platformLocation.pathname),this._platformLocation.pushState(e,t,a)}replaceState(e,t,n,o){let a=this.prepareExternalUrl(n+Nl(o));0==a.length&&(a=this._platformLocation.pathname),this._platformLocation.replaceState(e,t,a)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return e.\u0275fac=function(t){return new(t||e)(qe(Ml),qe(Ll,8))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),Bl=(()=>{class e{constructor(e,t){this._subject=new di,this._urlChangeListeners=[],this._platformStrategy=e;const n=this._platformStrategy.getBaseHref();this._platformLocation=t,this._baseHref=Rl(Hl(n)),this._platformStrategy.onPopState(e=>{this._subject.emit({url:this.path(!0),pop:!0,state:e.state,type:e.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,t=""){return this.path()==this.normalize(e+Nl(t))}normalize(t){return e.stripTrailingSlash(function(e,t){return e&&t.startsWith(e)?t.substring(e.length):t}(this._baseHref,Hl(t)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,t="",n=null){this._platformStrategy.pushState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Nl(t)),n)}replaceState(e,t="",n=null){this._platformStrategy.replaceState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Nl(t)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}onUrlChange(e){this._urlChangeListeners.push(e),this.subscribe(e=>{this._notifyUrlChangeListeners(e.url,e.state)})}_notifyUrlChangeListeners(e="",t){this._urlChangeListeners.forEach(n=>n(e,t))}subscribe(e,t,n){return this._subject.subscribe({next:e,error:t,complete:n})}}return e.\u0275fac=function(t){return new(t||e)(qe(jl),qe(Ml))},e.normalizeQueryParams=Nl,e.joinWithSlash=El,e.stripTrailingSlash=Rl,e.\u0275prov=le({factory:Vl,token:e,providedIn:"root"}),e})();function Vl(){return new Bl(qe(jl),qe(Ml))}function Hl(e){return e.replace(/\/index.html$/,"")}const ql=function(){var e={Zero:0,One:1,Two:2,Few:3,Many:4,Other:5};return e[e.Zero]="Zero",e[e.One]="One",e[e.Two]="Two",e[e.Few]="Few",e[e.Many]="Many",e[e.Other]="Other",e}(),Gl=function(){var e={Format:0,Standalone:1};return e[e.Format]="Format",e[e.Standalone]="Standalone",e}(),Wl=function(){var e={Narrow:0,Abbreviated:1,Wide:2,Short:3};return e[e.Narrow]="Narrow",e[e.Abbreviated]="Abbreviated",e[e.Wide]="Wide",e[e.Short]="Short",e}(),$l=function(){var e={Short:0,Medium:1,Long:2,Full:3};return e[e.Short]="Short",e[e.Medium]="Medium",e[e.Long]="Long",e[e.Full]="Full",e}(),Zl=function(){var e={Decimal:0,Group:1,List:2,PercentSign:3,PlusSign:4,MinusSign:5,Exponential:6,SuperscriptingExponent:7,PerMille:8,Infinity:9,NaN:10,TimeSeparator:11,CurrencyDecimal:12,CurrencyGroup:13};return e[e.Decimal]="Decimal",e[e.Group]="Group",e[e.List]="List",e[e.PercentSign]="PercentSign",e[e.PlusSign]="PlusSign",e[e.MinusSign]="MinusSign",e[e.Exponential]="Exponential",e[e.SuperscriptingExponent]="SuperscriptingExponent",e[e.PerMille]="PerMille",e[e.Infinity]="Infinity",e[e.NaN]="NaN",e[e.TimeSeparator]="TimeSeparator",e[e.CurrencyDecimal]="CurrencyDecimal",e[e.CurrencyGroup]="CurrencyGroup",e}();function Kl(e,t){return tu(Ys(e)[ti.DateFormat],t)}function Jl(e,t){return tu(Ys(e)[ti.TimeFormat],t)}function Ql(e,t){return tu(Ys(e)[ti.DateTimeFormat],t)}function Yl(e,t){const n=Ys(e),o=n[ti.NumberSymbols][t];if(void 0===o){if(t===Zl.CurrencyDecimal)return n[ti.NumberSymbols][Zl.Decimal];if(t===Zl.CurrencyGroup)return n[ti.NumberSymbols][Zl.Group]}return o}function eu(e){if(!e[ti.ExtraData])throw new Error(`Missing extra locale data for the locale "${e[ti.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`)}function tu(e,t){for(let n=t;n>-1;n--)if(void 0!==e[n])return e[n];throw new Error("Locale data API: locale data undefined")}function nu(e){const[t,n]=e.split(":");return{hours:+t,minutes:+n}}const ou=/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/,au={},ru=/((?:[^GyMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/,su=function(){var e={Short:0,ShortGMT:1,Long:2,Extended:3};return e[e.Short]="Short",e[e.ShortGMT]="ShortGMT",e[e.Long]="Long",e[e.Extended]="Extended",e}(),iu=function(){var e={FullYear:0,Month:1,Date:2,Hours:3,Minutes:4,Seconds:5,FractionalSeconds:6,Day:7};return e[e.FullYear]="FullYear",e[e.Month]="Month",e[e.Date]="Date",e[e.Hours]="Hours",e[e.Minutes]="Minutes",e[e.Seconds]="Seconds",e[e.FractionalSeconds]="FractionalSeconds",e[e.Day]="Day",e}(),lu=function(){var e={DayPeriods:0,Days:1,Months:2,Eras:3};return e[e.DayPeriods]="DayPeriods",e[e.Days]="Days",e[e.Months]="Months",e[e.Eras]="Eras",e}();function uu(e,t){return t&&(e=e.replace(/\{([^}]+)}/g,(function(e,n){return null!=t&&n in t?t[n]:e}))),e}function cu(e,t,n="-",o,a){let r="";(e<0||a&&e<=0)&&(a?e=1-e:(e=-e,r=n));let s=String(e);for(;s.length<t;)s="0"+s;return o&&(s=s.substr(s.length-t)),r+s}function pu(e,t,n=0,o=!1,a=!1){return function(r,s){let i=function(e,t){switch(e){case iu.FullYear:return t.getFullYear();case iu.Month:return t.getMonth();case iu.Date:return t.getDate();case iu.Hours:return t.getHours();case iu.Minutes:return t.getMinutes();case iu.Seconds:return t.getSeconds();case iu.FractionalSeconds:return t.getMilliseconds();case iu.Day:return t.getDay();default:throw new Error(`Unknown DateType value "${e}".`)}}(e,r);if((n>0||i>-n)&&(i+=n),e===iu.Hours)0===i&&-12===n&&(i=12);else if(e===iu.FractionalSeconds)return l=t,cu(i,3).substr(0,l);var l;const u=Yl(s,Zl.MinusSign);return cu(i,t,u,o,a)}}function du(e,t,n=Gl.Format,o=!1){return function(a,r){return function(e,t,n,o,a,r){switch(n){case lu.Months:return function(e,t,n){const o=Ys(e),a=tu([o[ti.MonthsFormat],o[ti.MonthsStandalone]],t);return tu(a,n)}(t,a,o)[e.getMonth()];case lu.Days:return function(e,t,n){const o=Ys(e),a=tu([o[ti.DaysFormat],o[ti.DaysStandalone]],t);return tu(a,n)}(t,a,o)[e.getDay()];case lu.DayPeriods:const s=e.getHours(),i=e.getMinutes();if(r){const e=function(e){const t=Ys(e);return eu(t),(t[ti.ExtraData][2]||[]).map(e=>"string"==typeof e?nu(e):[nu(e[0]),nu(e[1])])}(t),n=function(e,t,n){const o=Ys(e);eu(o);const a=tu([o[ti.ExtraData][0],o[ti.ExtraData][1]],t)||[];return tu(a,n)||[]}(t,a,o);let r;if(e.forEach((e,t)=>{if(Array.isArray(e)){const{hours:o,minutes:a}=e[0],{hours:l,minutes:u}=e[1];s>=o&&i>=a&&(s<l||s===l&&i<u)&&(r=n[t])}else{const{hours:o,minutes:a}=e;o===s&&a===i&&(r=n[t])}}),r)return r}return function(e,t,n){const o=Ys(e),a=tu([o[ti.DayPeriodsFormat],o[ti.DayPeriodsStandalone]],t);return tu(a,n)}(t,a,o)[s<12?0:1];case lu.Eras:return function(e,t){return tu(Ys(e)[ti.Eras],t)}(t,o)[e.getFullYear()<=0?0:1];default:throw new Error("unexpected translation type "+n)}}(a,r,e,t,n,o)}}function hu(e){return function(t,n,o){const a=-1*o,r=Yl(n,Zl.MinusSign),s=a>0?Math.floor(a/60):Math.ceil(a/60);switch(e){case su.Short:return(a>=0?"+":"")+cu(s,2,r)+cu(Math.abs(a%60),2,r);case su.ShortGMT:return"GMT"+(a>=0?"+":"")+cu(s,1,r);case su.Long:return"GMT"+(a>=0?"+":"")+cu(s,2,r)+":"+cu(Math.abs(a%60),2,r);case su.Extended:return 0===o?"Z":(a>=0?"+":"")+cu(s,2,r)+":"+cu(Math.abs(a%60),2,r);default:throw new Error(`Unknown zone width "${e}"`)}}}function mu(e,t=!1){return function(n,o){let a;if(t){const e=new Date(n.getFullYear(),n.getMonth(),1).getDay()-1,t=n.getDate();a=1+Math.floor((t+e)/7)}else{const e=function(e){const t=new Date(e,0,1).getDay();return new Date(e,0,1+(t<=4?4:11)-t)}(n.getFullYear()),t=(r=n,new Date(r.getFullYear(),r.getMonth(),r.getDate()+(4-r.getDay()))).getTime()-e.getTime();a=1+Math.round(t/6048e5)}var r;return cu(a,e,Yl(o,Zl.MinusSign))}}const fu={};function gu(e,t){e=e.replace(/:/g,"");const n=Date.parse("Jan 01, 1970 00:00:00 "+e)/6e4;return isNaN(n)?t:n}function _u(e){return e instanceof Date&&!isNaN(e.valueOf())}class yu{}let bu=(()=>{class e extends yu{constructor(e){super(),this.locale=e}getPluralCategory(e,t){switch(function(e){return Ys(e)[ti.PluralCase]}(t||this.locale)(e)){case ql.Zero:return"zero";case ql.One:return"one";case ql.Two:return"two";case ql.Few:return"few";case ql.Many:return"many";default:return"other"}}}return e.\u0275fac=function(t){return new(t||e)(qe(Ni))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();function vu(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const e=n.indexOf("="),[o,a]=-1==e?[n,""]:[n.slice(0,e),n.slice(e+1)];if(o.trim()===t)return decodeURIComponent(a)}return null}let xu=(()=>{class e{constructor(e,t,n,o){this._iterableDiffers=e,this._keyValueDiffers=t,this._ngEl=n,this._renderer=o,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof e?e.split(/\s+/):e,this._rawClass&&(Tr(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&&this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&&this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachChangedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachRemovedItem(e=>{e.previousValue&&this._toggleClass(e.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(e=>{if("string"!=typeof e.item)throw new Error("NgClass can only toggle CSS classes expressed as strings, got "+ye(e.item));this._toggleClass(e.item,!0)}),e.forEachRemovedItem(e=>this._toggleClass(e.item,!1))}_applyClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!0)):Object.keys(e).forEach(t=>this._toggleClass(t,!!e[t])))}_removeClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!1)):Object.keys(e).forEach(e=>this._toggleClass(e,!1)))}_toggleClass(e,t){(e=e.trim())&&e.split(/\s+/g).forEach(e=>{t?this._renderer.addClass(this._ngEl.nativeElement,e):this._renderer.removeClass(this._ngEl.nativeElement,e)})}}return e.\u0275fac=function(t){return new(t||e)(Dr(Rs),Dr(Ns),Dr(gs),Dr(vs))},e.\u0275dir=mt({type:e,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),e})();class wu{constructor(e,t,n,o){this.$implicit=e,this.ngForOf=t,this.index=n,this.count=o}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Cu=(()=>{class e{constructor(e,t,n){this._viewContainer=e,this._template=t,this._differs=n,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){so()&&null!=e&&"function"!=typeof e&&console&&console.warn&&console.warn(`trackBy must be a function, but received ${JSON.stringify(e)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`),this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const n=this._ngForOf;if(!this._differ&&n)try{this._differ=this._differs.find(n).create(this.ngForTrackBy)}catch(t){throw new Error(`Cannot find a differ supporting object '${n}' of type '${e=n,e.name||typeof e}'. NgFor only supports binding to Iterables such as Arrays.`)}}var e;if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const t=[];e.forEachOperation((e,n,o)=>{if(null==e.previousIndex){const n=this._viewContainer.createEmbeddedView(this._template,new wu(null,this._ngForOf,-1,-1),null===o?void 0:o),a=new Tu(e,n);t.push(a)}else if(null==o)this._viewContainer.remove(null===n?void 0:n);else if(null!==n){const a=this._viewContainer.get(n);this._viewContainer.move(a,o);const r=new Tu(e,a);t.push(r)}});for(let n=0;n<t.length;n++)this._perViewChange(t[n].view,t[n].record);for(let n=0,o=this._viewContainer.length;n<o;n++){const e=this._viewContainer.get(n);e.context.index=n,e.context.count=o,e.context.ngForOf=this._ngForOf}e.forEachIdentityChange(e=>{this._viewContainer.get(e.currentIndex).context.$implicit=e.item})}_perViewChange(e,t){e.context.$implicit=t.item}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(Dr(Bs),Dr(Xs),Dr(Rs))},e.\u0275dir=mt({type:e,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),e})();class Tu{constructor(e,t){this.record=e,this.view=t}}let ku=(()=>{class e{constructor(e,t){this._viewContainer=e,this._context=new Pu,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=t}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){Su("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){Su("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(Dr(Bs),Dr(Xs))},e.\u0275dir=mt({type:e,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),e})();class Pu{constructor(){this.$implicit=null,this.ngIf=null}}function Su(e,t){if(t&&!t.createEmbeddedView)throw new Error(`${e} must be a TemplateRef, but received '${ye(t)}'.`)}function Mu(e,t){return Error(`InvalidPipeArgument: '${t}' for pipe '${ye(e)}'`)}const Ou=/(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D])\S*/g;let Iu=(()=>{class e{transform(t){if(!t)return t;if("string"!=typeof t)throw Mu(e,t);return t.replace(Ou,e=>e[0].toUpperCase()+e.substr(1).toLowerCase())}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275pipe=ft({name:"titlecase",type:e,pure:!0}),e})(),Fu=(()=>{class e{transform(t){if(!t)return t;if("string"!=typeof t)throw Mu(e,t);return t.toUpperCase()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275pipe=ft({name:"uppercase",type:e,pure:!0}),e})(),Du=(()=>{class e{constructor(e){this.locale=e}transform(t,n="mediumDate",o,a){if(null==t||""===t||t!=t)return null;try{return function(e,t,n,o){let a=function(e){if(_u(e))return e;if("number"==typeof e&&!isNaN(e))return new Date(e);if("string"==typeof e){e=e.trim();const t=parseFloat(e);if(!isNaN(e-t))return new Date(t);if(/^(\d{4}-\d{1,2}-\d{1,2})$/.test(e)){const[t,n,o]=e.split("-").map(e=>+e);return new Date(t,n-1,o)}let n;if(n=e.match(ou))return function(e){const t=new Date(0);let n=0,o=0;const a=e[8]?t.setUTCFullYear:t.setFullYear,r=e[8]?t.setUTCHours:t.setHours;e[9]&&(n=Number(e[9]+e[10]),o=Number(e[9]+e[11])),a.call(t,Number(e[1]),Number(e[2])-1,Number(e[3]));const s=Number(e[4]||0)-n,i=Number(e[5]||0)-o,l=Number(e[6]||0),u=Math.round(1e3*parseFloat("0."+(e[7]||0)));return r.call(t,s,i,l,u),t}(n)}const t=new Date(e);if(!_u(t))throw new Error(`Unable to convert "${e}" into a date`);return t}(e);t=function e(t,n){const o=function(e){return Ys(e)[ti.LocaleId]}(t);if(au[o]=au[o]||{},au[o][n])return au[o][n];let a="";switch(n){case"shortDate":a=Kl(t,$l.Short);break;case"mediumDate":a=Kl(t,$l.Medium);break;case"longDate":a=Kl(t,$l.Long);break;case"fullDate":a=Kl(t,$l.Full);break;case"shortTime":a=Jl(t,$l.Short);break;case"mediumTime":a=Jl(t,$l.Medium);break;case"longTime":a=Jl(t,$l.Long);break;case"fullTime":a=Jl(t,$l.Full);break;case"short":const n=e(t,"shortTime"),o=e(t,"shortDate");a=uu(Ql(t,$l.Short),[n,o]);break;case"medium":const r=e(t,"mediumTime"),s=e(t,"mediumDate");a=uu(Ql(t,$l.Medium),[r,s]);break;case"long":const i=e(t,"longTime"),l=e(t,"longDate");a=uu(Ql(t,$l.Long),[i,l]);break;case"full":const u=e(t,"fullTime"),c=e(t,"fullDate");a=uu(Ql(t,$l.Full),[u,c])}return a&&(au[o][n]=a),a}(n,t)||t;let r,s=[];for(;t;){if(r=ru.exec(t),!r){s.push(t);break}{s=s.concat(r.slice(1));const e=s.pop();if(!e)break;t=e}}let i=a.getTimezoneOffset();o&&(i=gu(o,i),a=function(e,t,n){const o=e.getTimezoneOffset();return function(e,t){return(e=new Date(e.getTime())).setMinutes(e.getMinutes()+t),e}(e,-1*(gu(t,o)-o))}(a,o));let l="";return s.forEach(e=>{const t=function(e){if(fu[e])return fu[e];let t;switch(e){case"G":case"GG":case"GGG":t=du(lu.Eras,Wl.Abbreviated);break;case"GGGG":t=du(lu.Eras,Wl.Wide);break;case"GGGGG":t=du(lu.Eras,Wl.Narrow);break;case"y":t=pu(iu.FullYear,1,0,!1,!0);break;case"yy":t=pu(iu.FullYear,2,0,!0,!0);break;case"yyy":t=pu(iu.FullYear,3,0,!1,!0);break;case"yyyy":t=pu(iu.FullYear,4,0,!1,!0);break;case"M":case"L":t=pu(iu.Month,1,1);break;case"MM":case"LL":t=pu(iu.Month,2,1);break;case"MMM":t=du(lu.Months,Wl.Abbreviated);break;case"MMMM":t=du(lu.Months,Wl.Wide);break;case"MMMMM":t=du(lu.Months,Wl.Narrow);break;case"LLL":t=du(lu.Months,Wl.Abbreviated,Gl.Standalone);break;case"LLLL":t=du(lu.Months,Wl.Wide,Gl.Standalone);break;case"LLLLL":t=du(lu.Months,Wl.Narrow,Gl.Standalone);break;case"w":t=mu(1);break;case"ww":t=mu(2);break;case"W":t=mu(1,!0);break;case"d":t=pu(iu.Date,1);break;case"dd":t=pu(iu.Date,2);break;case"E":case"EE":case"EEE":t=du(lu.Days,Wl.Abbreviated);break;case"EEEE":t=du(lu.Days,Wl.Wide);break;case"EEEEE":t=du(lu.Days,Wl.Narrow);break;case"EEEEEE":t=du(lu.Days,Wl.Short);break;case"a":case"aa":case"aaa":t=du(lu.DayPeriods,Wl.Abbreviated);break;case"aaaa":t=du(lu.DayPeriods,Wl.Wide);break;case"aaaaa":t=du(lu.DayPeriods,Wl.Narrow);break;case"b":case"bb":case"bbb":t=du(lu.DayPeriods,Wl.Abbreviated,Gl.Standalone,!0);break;case"bbbb":t=du(lu.DayPeriods,Wl.Wide,Gl.Standalone,!0);break;case"bbbbb":t=du(lu.DayPeriods,Wl.Narrow,Gl.Standalone,!0);break;case"B":case"BB":case"BBB":t=du(lu.DayPeriods,Wl.Abbreviated,Gl.Format,!0);break;case"BBBB":t=du(lu.DayPeriods,Wl.Wide,Gl.Format,!0);break;case"BBBBB":t=du(lu.DayPeriods,Wl.Narrow,Gl.Format,!0);break;case"h":t=pu(iu.Hours,1,-12);break;case"hh":t=pu(iu.Hours,2,-12);break;case"H":t=pu(iu.Hours,1);break;case"HH":t=pu(iu.Hours,2);break;case"m":t=pu(iu.Minutes,1);break;case"mm":t=pu(iu.Minutes,2);break;case"s":t=pu(iu.Seconds,1);break;case"ss":t=pu(iu.Seconds,2);break;case"S":t=pu(iu.FractionalSeconds,1);break;case"SS":t=pu(iu.FractionalSeconds,2);break;case"SSS":t=pu(iu.FractionalSeconds,3);break;case"Z":case"ZZ":case"ZZZ":t=hu(su.Short);break;case"ZZZZZ":t=hu(su.Extended);break;case"O":case"OO":case"OOO":case"z":case"zz":case"zzz":t=hu(su.ShortGMT);break;case"OOOO":case"ZZZZ":case"zzzz":t=hu(su.Long);break;default:return null}return fu[e]=t,t}(e);l+=t?t(a,n,i):"''"===e?"'":e.replace(/(^'|'$)/g,"").replace(/''/g,"'")}),l}(t,n,a||this.locale,o)}catch(r){throw Mu(e,r.message)}}}return e.\u0275fac=function(t){return new(t||e)(Dr(Ni))},e.\u0275pipe=ft({name:"date",type:e,pure:!0}),e})(),Au=(()=>{class e{}return e.\u0275mod=dt({type:e}),e.\u0275inj=ue({factory:function(t){return new(t||e)},providers:[{provide:yu,useClass:bu}]}),e})(),Eu=(()=>{class e{}return e.\u0275prov=le({token:e,providedIn:"root",factory:()=>new Ru(qe(Sl),window,qe(to))}),e})();class Ru{constructor(e,t,n){this.document=e,this.window=t,this.errorHandler=n,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportScrollRestoration()?[this.window.scrollX,this.window.scrollY]:[0,0]}scrollToPosition(e){this.supportScrollRestoration()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(this.supportScrollRestoration()){e=this.window.CSS&&this.window.CSS.escape?this.window.CSS.escape(e):e.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g,"\\$1");try{const t=this.document.querySelector("#"+e);if(t)return void this.scrollToElement(t);const n=this.document.querySelector(`[name='${e}']`);if(n)return void this.scrollToElement(n)}catch(t){this.errorHandler.handleError(t)}}}setHistoryScrollRestoration(e){if(this.supportScrollRestoration()){const t=this.window.history;t&&t.scrollRestoration&&(t.scrollRestoration=e)}}scrollToElement(e){const t=e.getBoundingClientRect(),n=t.left+this.window.pageXOffset,o=t.top+this.window.pageYOffset,a=this.offset();this.window.scrollTo(n-a[0],o-a[1])}supportScrollRestoration(){try{return!!this.window&&!!this.window.scrollTo}catch(e){return!1}}}class Nu extends class extends class{}{constructor(){super()}supportsDOMEvents(){return!0}}{static makeCurrent(){var e;e=new Nu,kl||(kl=e)}getProperty(e,t){return e[t]}log(e){window.console&&window.console.log&&window.console.log(e)}logGroup(e){window.console&&window.console.group&&window.console.group(e)}logGroupEnd(){window.console&&window.console.groupEnd&&window.console.groupEnd()}onAndCancel(e,t,n){return e.addEventListener(t,n,!1),()=>{e.removeEventListener(t,n,!1)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){return e.parentNode&&e.parentNode.removeChild(e),e}getValue(e){return e.value}createElement(e,t){return(t=t||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return"window"===t?window:"document"===t?e:"body"===t?e.body:null}getHistory(){return window.history}getLocation(){return window.location}getBaseHref(e){const t=zu||(zu=document.querySelector("base"),zu)?zu.getAttribute("href"):null;return null==t?null:(n=t,ju||(ju=document.createElement("a")),ju.setAttribute("href",n),"/"===ju.pathname.charAt(0)?ju.pathname:"/"+ju.pathname);var n}resetBaseElement(){zu=null}getUserAgent(){return window.navigator.userAgent}performanceNow(){return window.performance&&window.performance.now?window.performance.now():(new Date).getTime()}supportsCookies(){return!0}getCookie(e){return vu(document.cookie,e)}}let ju,zu=null;const Lu=new Re("TRANSITION_ID"),Xu=[{provide:Si,useFactory:function(e,t,n){return()=>{n.get(Mi).donePromise.then(()=>{const n=Pl();Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t=>t.getAttribute("ng-transition")===e).forEach(e=>n.remove(e))})}},deps:[Lu,Sl,mr],multi:!0}];class Uu{static init(){var e;e=new Uu,il=e}addToWindow(e){Se.getAngularTestability=(t,n=!0)=>{const o=e.findTestabilityInTree(t,n);if(null==o)throw new Error("Could not find testability for element.");return o},Se.getAllAngularTestabilities=()=>e.getAllTestabilities(),Se.getAllAngularRootElements=()=>e.getAllRootElements(),Se.frameworkStabilizers||(Se.frameworkStabilizers=[]),Se.frameworkStabilizers.push(e=>{const t=Se.getAllAngularTestabilities();let n=t.length,o=!1;const a=function(t){o=o||t,n--,0==n&&e(o)};t.forEach((function(e){e.whenStable(a)}))})}findTestabilityInTree(e,t,n){if(null==t)return null;const o=e.getTestability(t);return null!=o?o:n?Pl().isShadowRoot(t)?this.findTestabilityInTree(e,t.host,!0):this.findTestabilityInTree(e,t.parentElement,!0):null}}const Bu=new Re("EventManagerPlugins");let Vu=(()=>{class e{constructor(e,t){this._zone=t,this._eventNameToPlugin=new Map,e.forEach(e=>e.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,t,n){return this._findPluginFor(t).addEventListener(e,t,n)}addGlobalEventListener(e,t,n){return this._findPluginFor(t).addGlobalEventListener(e,t,n)}getZone(){return this._zone}_findPluginFor(e){const t=this._eventNameToPlugin.get(e);if(t)return t;const n=this._plugins;for(let o=0;o<n.length;o++){const t=n[o];if(t.supports(e))return this._eventNameToPlugin.set(e,t),t}throw new Error("No event manager plugin found for event "+e)}}return e.\u0275fac=function(t){return new(t||e)(qe(Bu),qe(Zi))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();class Hu{constructor(e){this._doc=e}addGlobalEventListener(e,t,n){const o=Pl().getGlobalEventTarget(this._doc,e);if(!o)throw new Error(`Unsupported event target ${o} for event ${t}`);return this.addEventListener(o,t,n)}}let qu=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(e){const t=new Set;e.forEach(e=>{this._stylesSet.has(e)||(this._stylesSet.add(e),t.add(e))}),this.onStylesAdded(t)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),Gu=(()=>{class e extends qu{constructor(e){super(),this._doc=e,this._hostNodes=new Set,this._styleNodes=new Set,this._hostNodes.add(e.head)}_addStylesToHost(e,t){e.forEach(e=>{const n=this._doc.createElement("style");n.textContent=e,this._styleNodes.add(t.appendChild(n))})}addHost(e){this._addStylesToHost(this._stylesSet,e),this._hostNodes.add(e)}removeHost(e){this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach(t=>this._addStylesToHost(e,t))}ngOnDestroy(){this._styleNodes.forEach(e=>Pl().remove(e))}}return e.\u0275fac=function(t){return new(t||e)(qe(Sl))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();const Wu={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},$u=/%COMP%/g;function Zu(e,t,n){for(let o=0;o<t.length;o++){let a=t[o];Array.isArray(a)?Zu(e,a,n):(a=a.replace($u,e),n.push(a))}return n}function Ku(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let Ju=(()=>{class e{constructor(e,t,n){this.eventManager=e,this.sharedStylesHost=t,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new Qu(e)}createRenderer(e,t){if(!e||!t)return this.defaultRenderer;switch(t.encapsulation){case at.Emulated:{let n=this.rendererByCompId.get(t.id);return n||(n=new Yu(this.eventManager,this.sharedStylesHost,t,this.appId),this.rendererByCompId.set(t.id,n)),n.applyToHost(e),n}case at.Native:case at.ShadowDom:return new ec(this.eventManager,this.sharedStylesHost,e,t);default:if(!this.rendererByCompId.has(t.id)){const e=Zu(t.id,t.styles,[]);this.sharedStylesHost.addStyles(e),this.rendererByCompId.set(t.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(t){return new(t||e)(qe(Vu),qe(Gu),qe(Oi))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();class Qu{constructor(e){this.eventManager=e,this.data=Object.create(null)}destroy(){}createElement(e,t){return t?document.createElementNS(Wu[t]||t,e):document.createElement(e)}createComment(e){return document.createComment(e)}createText(e){return document.createTextNode(e)}appendChild(e,t){e.appendChild(t)}insertBefore(e,t,n){e&&e.insertBefore(t,n)}removeChild(e,t){e&&e.removeChild(t)}selectRootElement(e,t){let n="string"==typeof e?document.querySelector(e):e;if(!n)throw new Error(`The selector "${e}" did not match any elements`);return t||(n.textContent=""),n}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,n,o){if(o){t=o+":"+t;const a=Wu[o];a?e.setAttributeNS(a,t,n):e.setAttribute(t,n)}else e.setAttribute(t,n)}removeAttribute(e,t,n){if(n){const o=Wu[n];o?e.removeAttributeNS(o,t):e.removeAttribute(`${n}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,n,o){o&bs.DashCase?e.style.setProperty(t,n,o&bs.Important?"important":""):e.style[t]=n}removeStyle(e,t,n){n&bs.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,n){e[t]=n}setValue(e,t){e.nodeValue=t}listen(e,t,n){return"string"==typeof e?this.eventManager.addGlobalEventListener(e,t,Ku(n)):this.eventManager.addEventListener(e,t,Ku(n))}}class Yu extends Qu{constructor(e,t,n,o){super(e),this.component=n;const a=Zu(o+"-"+n.id,n.styles,[]);t.addStyles(a),this.contentAttr="_ngcontent-%COMP%".replace($u,o+"-"+n.id),this.hostAttr=function(e){return"_nghost-%COMP%".replace($u,e)}(o+"-"+n.id)}applyToHost(e){super.setAttribute(e,this.hostAttr,"")}createElement(e,t){const n=super.createElement(e,t);return super.setAttribute(n,this.contentAttr,""),n}}class ec extends Qu{constructor(e,t,n,o){super(e),this.sharedStylesHost=t,this.hostEl=n,this.component=o,this.shadowRoot=o.encapsulation===at.ShadowDom?n.attachShadow({mode:"open"}):n.createShadowRoot(),this.sharedStylesHost.addHost(this.shadowRoot);const a=Zu(o.id,o.styles,[]);for(let r=0;r<a.length;r++){const e=document.createElement("style");e.textContent=a[r],this.shadowRoot.appendChild(e)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,n){return super.insertBefore(this.nodeOrShadowRoot(e),t,n)}removeChild(e,t){return super.removeChild(this.nodeOrShadowRoot(e),t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}}let tc=(()=>{class e extends Hu{constructor(e){super(e)}supports(e){return!0}addEventListener(e,t,n){return e.addEventListener(t,n,!1),()=>this.removeEventListener(e,t,n)}removeEventListener(e,t,n){return e.removeEventListener(t,n)}}return e.\u0275fac=function(t){return new(t||e)(qe(Sl))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();const nc=["alt","control","meta","shift"],oc={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},ac={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},rc={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let sc=(()=>{class e extends Hu{constructor(e){super(e)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,n,o){const a=e.parseEventName(n),r=e.eventCallback(a.fullKey,o,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Pl().onAndCancel(t,a.domEventName,r))}static parseEventName(t){const n=t.toLowerCase().split("."),o=n.shift();if(0===n.length||"keydown"!==o&&"keyup"!==o)return null;const a=e._normalizeKey(n.pop());let r="";if(nc.forEach(e=>{const t=n.indexOf(e);t>-1&&(n.splice(t,1),r+=e+".")}),r+=a,0!=n.length||0===a.length)return null;const s={};return s.domEventName=o,s.fullKey=r,s}static getEventFullKey(e){let t="",n=function(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&ac.hasOwnProperty(t)&&(t=ac[t]))}return oc[t]||t}(e);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),nc.forEach(o=>{o!=n&&(0,rc[o])(e)&&(t+=o+".")}),t+=n,t}static eventCallback(t,n,o){return a=>{e.getEventFullKey(a)===t&&o.runGuarded(()=>n(a))}}static _normalizeKey(e){switch(e){case"esc":return"escape";default:return e}}}return e.\u0275fac=function(t){return new(t||e)(qe(Sl))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();const ic=pl(wl,"browser",[{provide:Ai,useValue:"browser"},{provide:Di,useValue:function(){Nu.makeCurrent(),Uu.init()},multi:!0},{provide:Sl,useFactory:function(){return function(e){Pt=e}(document),document},deps:[]}]),lc=[[],{provide:tr,useValue:"root"},{provide:to,useFactory:function(){return new to},deps:[]},{provide:Bu,useClass:tc,multi:!0,deps:[Sl,Zi,Ai]},{provide:Bu,useClass:sc,multi:!0,deps:[Sl]},[],{provide:Ju,useClass:Ju,deps:[Vu,Gu,Oi]},{provide:ys,useExisting:Ju},{provide:qu,useExisting:Gu},{provide:Gu,useClass:Gu,deps:[Sl]},{provide:ol,useClass:ol,deps:[Zi]},{provide:Vu,useClass:Vu,deps:[Bu,Zi]},[]];let uc=(()=>{class e{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(t){return{ngModule:e,providers:[{provide:Oi,useValue:t.appId},{provide:Lu,useExisting:Oi},Xu]}}}return e.\u0275mod=dt({type:e}),e.\u0275inj=ue({factory:function(t){return new(t||e)(qe(e,12))},providers:lc,imports:[Au,Tl]}),e})();function cc(...e){let t=e[e.length-1];return S(t)?(e.pop(),X(e,t)):G(e)}"undefined"!=typeof window&&window;class pc extends k{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const t=super._subscribe(e);return t&&!t.closed&&e.next(this._value),t}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new w;return this._value}next(e){super.next(this._value=e)}}const dc=(()=>{function e(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return e.prototype=Object.create(Error.prototype),e})(),hc={};class mc{constructor(e){this.resultSelector=e}call(e,t){return t.subscribe(new fc(e,this.resultSelector))}}class fc extends N{constructor(e,t){super(e),this.resultSelector=t,this.active=0,this.values=[],this.observables=[]}_next(e){this.values.push(hc),this.observables.push(e)}_complete(){const e=this.observables,t=e.length;if(0===t)this.destination.complete();else{this.active=t,this.toRespond=t;for(let n=0;n<t;n++){const t=e[n];this.add(R(this,t,t,n))}}}notifyComplete(e){0==(this.active-=1)&&this.destination.complete()}notifyNext(e,t,n,o,a){const r=this.values,s=this.toRespond?r[n]===hc?--this.toRespond:this.toRespond:0;r[n]=t,0===s&&(this.resultSelector?this._tryResultSelector(r):this.destination.next(r.slice()))}_tryResultSelector(e){let t;try{t=this.resultSelector.apply(this,e)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const gc=new v(e=>e.complete());function _c(e){return e?function(e){return new v(t=>e.schedule(()=>t.complete()))}(e):gc}function yc(e){return new v(t=>{let n;try{n=e()}catch(o){return void t.error(o)}return(n?U(n):_c()).subscribe(t)})}function bc(){return q(1)}function vc(e,t){return function(n){return n.lift(new xc(e,t))}}class xc{constructor(e,t){this.predicate=e,this.thisArg=t}call(e,t){return t.subscribe(new wc(e,this.predicate,this.thisArg))}}class wc extends m{constructor(e,t,n){super(e),this.predicate=t,this.thisArg=n,this.count=0}_next(e){let t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}t&&this.destination.next(e)}}const Cc=(()=>{function e(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return e.prototype=Object.create(Error.prototype),e})();function Tc(e){return function(t){return 0===e?_c():t.lift(new kc(e))}}class kc{constructor(e){if(this.total=e,this.total<0)throw new Cc}call(e,t){return t.subscribe(new Pc(e,this.total))}}class Pc extends m{constructor(e,t){super(e),this.total=t,this.ring=new Array,this.count=0}_next(e){const t=this.ring,n=this.total,o=this.count++;t.length<n?t.push(e):t[o%n]=e}_complete(){const e=this.destination;let t=this.count;if(t>0){const n=this.count>=this.total?this.total:this.count,o=this.ring;for(let a=0;a<n;a++){const a=t++%n;e.next(o[a])}}e.complete()}}function Sc(e=Ic){return t=>t.lift(new Mc(e))}class Mc{constructor(e){this.errorFactory=e}call(e,t){return t.subscribe(new Oc(e,this.errorFactory))}}class Oc extends m{constructor(e,t){super(e),this.errorFactory=t,this.hasValue=!1}_next(e){this.hasValue=!0,this.destination.next(e)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function Ic(){return new dc}function Fc(e=null){return t=>t.lift(new Dc(e))}class Dc{constructor(e){this.defaultValue=e}call(e,t){return t.subscribe(new Ac(e,this.defaultValue))}}class Ac extends m{constructor(e,t){super(e),this.defaultValue=t,this.isEmpty=!0}_next(e){this.isEmpty=!1,this.destination.next(e)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Ec(e,t){const n=arguments.length>=2;return o=>o.pipe(e?vc((t,n)=>e(t,n,o)):_,Tc(1),n?Fc(t):Sc(()=>new dc))}function Rc(e){return function(t){const n=new Nc(e),o=t.lift(n);return n.caught=o}}class Nc{constructor(e){this.selector=e}call(e,t){return t.subscribe(new jc(e,this.selector,this.caught))}}class jc extends N{constructor(e,t,n){super(e),this.selector=t,this.caught=n}error(e){if(!this.isStopped){let n;try{n=this.selector(e,this.caught)}catch(t){return void super.error(t)}this._unsubscribeAndRecycle();const o=new M(this,void 0,void 0);this.add(o);const a=R(this,n,void 0,void 0,o);a!==o&&this.add(a)}}}function zc(e){return t=>0===e?_c():t.lift(new Lc(e))}class Lc{constructor(e){if(this.total=e,this.total<0)throw new Cc}call(e,t){return t.subscribe(new Xc(e,this.total))}}class Xc extends m{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){const t=this.total,n=++this.count;n<=t&&(this.destination.next(e),n===t&&(this.destination.complete(),this.unsubscribe()))}}function Uc(e,t){const n=arguments.length>=2;return o=>o.pipe(e?vc((t,n)=>e(t,n,o)):_,zc(1),n?Fc(t):Sc(()=>new dc))}class Bc{constructor(e,t,n){this.predicate=e,this.thisArg=t,this.source=n}call(e,t){return t.subscribe(new Vc(e,this.predicate,this.thisArg,this.source))}}class Vc extends m{constructor(e,t,n,o){super(e),this.predicate=t,this.thisArg=n,this.source=o,this.index=0,this.thisArg=n||this}notifyComplete(e){this.destination.next(e),this.destination.complete()}_next(e){let t=!1;try{t=this.predicate.call(this.thisArg,e,this.index++,this.source)}catch(n){return void this.destination.error(n)}t||this.notifyComplete(!1)}_complete(){this.notifyComplete(!0)}}function Hc(e,t){return"function"==typeof t?n=>n.pipe(Hc((n,o)=>U(e(n,o)).pipe(j((e,a)=>t(n,e,o,a))))):t=>t.lift(new qc(e))}class qc{constructor(e){this.project=e}call(e,t){return t.subscribe(new Gc(e,this.project))}}class Gc extends N{constructor(e,t){super(e),this.project=t,this.index=0}_next(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(o){return void this.destination.error(o)}this._innerSub(t,e,n)}_innerSub(e,t,n){const o=this.innerSubscription;o&&o.unsubscribe();const a=new M(this,t,n),r=this.destination;r.add(a),this.innerSubscription=R(this,e,void 0,void 0,a),this.innerSubscription!==a&&r.add(this.innerSubscription)}_complete(){const{innerSubscription:e}=this;e&&!e.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=null}notifyComplete(e){this.destination.remove(e),this.innerSubscription=null,this.isStopped&&super._complete()}notifyNext(e,t,n,o,a){this.destination.next(t)}}function Wc(...e){return bc()(cc(...e))}function $c(e,t){let n=!1;return arguments.length>=2&&(n=!0),function(o){return o.lift(new Zc(e,t,n))}}class Zc{constructor(e,t,n=!1){this.accumulator=e,this.seed=t,this.hasSeed=n}call(e,t){return t.subscribe(new Kc(e,this.accumulator,this.seed,this.hasSeed))}}class Kc extends m{constructor(e,t,n,o){super(e),this.accumulator=t,this._seed=n,this.hasSeed=o,this.index=0}get seed(){return this._seed}set seed(e){this.hasSeed=!0,this._seed=e}_next(e){if(this.hasSeed)return this._tryNext(e);this.seed=e,this.destination.next(e)}_tryNext(e){const t=this.index++;let n;try{n=this.accumulator(this.seed,e,t)}catch(o){this.destination.error(o)}this.seed=n,this.destination.next(n)}}function Jc(e,t){return B(e,t,1)}function Qc(){}function Yc(e,t,n){return function(o){return o.lift(new ep(e,t,n))}}class ep{constructor(e,t,n){this.nextOrObserver=e,this.error=t,this.complete=n}call(e,t){return t.subscribe(new tp(e,this.nextOrObserver,this.error,this.complete))}}class tp extends m{constructor(e,t,n,a){super(e),this._tapNext=Qc,this._tapError=Qc,this._tapComplete=Qc,this._tapError=n||Qc,this._tapComplete=a||Qc,o(t)?(this._context=this,this._tapNext=t):t&&(this._context=t,this._tapNext=t.next||Qc,this._tapError=t.error||Qc,this._tapComplete=t.complete||Qc)}_next(e){try{this._tapNext.call(this._context,e)}catch(t){return void this.destination.error(t)}this.destination.next(e)}_error(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)}_complete(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()}}class np{constructor(e){this.callback=e}call(e,t){return t.subscribe(new op(e,this.callback))}}class op extends m{constructor(e,t){super(e),this.add(new p(t))}}class ap{constructor(e,t){this.id=e,this.url=t}}class rp extends ap{constructor(e,t,n="imperative",o=null){super(e,t),this.navigationTrigger=n,this.restoredState=o}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class sp extends ap{constructor(e,t,n){super(e,t),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class ip extends ap{constructor(e,t,n){super(e,t),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class lp extends ap{constructor(e,t,n){super(e,t),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class up extends ap{constructor(e,t,n,o){super(e,t),this.urlAfterRedirects=n,this.state=o}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class cp extends ap{constructor(e,t,n,o){super(e,t),this.urlAfterRedirects=n,this.state=o}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class pp extends ap{constructor(e,t,n,o,a){super(e,t),this.urlAfterRedirects=n,this.state=o,this.shouldActivate=a}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class dp extends ap{constructor(e,t,n,o){super(e,t),this.urlAfterRedirects=n,this.state=o}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class hp extends ap{constructor(e,t,n,o){super(e,t),this.urlAfterRedirects=n,this.state=o}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class mp{constructor(e){this.route=e}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class fp{constructor(e){this.route=e}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class gp{constructor(e){this.snapshot=e}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class _p{constructor(e){this.snapshot=e}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class yp{constructor(e){this.snapshot=e}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class bp{constructor(e){this.snapshot=e}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class vp{constructor(e,t,n){this.routerEvent=e,this.position=t,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}let xp=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=lt({type:e,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,t){1&e&&zr(0,"router-outlet")},directives:function(){return[wh]},encapsulation:2}),e})();class wp{constructor(e){this.params=e||{}}has(e){return this.params.hasOwnProperty(e)}get(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t[0]:t}return null}getAll(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function Cp(e){return new wp(e)}function Tp(e){const t=Error("NavigationCancelingError: "+e);return t.ngNavigationCancelingError=!0,t}function kp(e,t,n){const o=n.path.split("/");if(o.length>e.length)return null;if("full"===n.pathMatch&&(t.hasChildren()||o.length<e.length))return null;const a={};for(let r=0;r<o.length;r++){const t=o[r],n=e[r];if(t.startsWith(":"))a[t.substring(1)]=n;else if(t!==n.path)return null}return{consumed:e.slice(0,o.length),posParams:a}}class Pp{constructor(e,t){this.routes=e,this.module=t}}function Sp(e,t=""){for(let n=0;n<e.length;n++){const o=e[n];Mp(o,Op(t,o))}}function Mp(e,t){if(!e)throw new Error(`\n      Invalid configuration of route '${t}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);if(Array.isArray(e))throw new Error(`Invalid configuration of route '${t}': Array cannot be specified`);if(!e.component&&!e.children&&!e.loadChildren&&e.outlet&&"primary"!==e.outlet)throw new Error(`Invalid configuration of route '${t}': a componentless route without children or loadChildren cannot have a named outlet set`);if(e.redirectTo&&e.children)throw new Error(`Invalid configuration of route '${t}': redirectTo and children cannot be used together`);if(e.redirectTo&&e.loadChildren)throw new Error(`Invalid configuration of route '${t}': redirectTo and loadChildren cannot be used together`);if(e.children&&e.loadChildren)throw new Error(`Invalid configuration of route '${t}': children and loadChildren cannot be used together`);if(e.redirectTo&&e.component)throw new Error(`Invalid configuration of route '${t}': redirectTo and component cannot be used together`);if(e.path&&e.matcher)throw new Error(`Invalid configuration of route '${t}': path and matcher cannot be used together`);if(void 0===e.redirectTo&&!e.component&&!e.children&&!e.loadChildren)throw new Error(`Invalid configuration of route '${t}'. One of the following must be provided: component, redirectTo, children or loadChildren`);if(void 0===e.path&&void 0===e.matcher)throw new Error(`Invalid configuration of route '${t}': routes must have either a path or a matcher specified`);if("string"==typeof e.path&&"/"===e.path.charAt(0))throw new Error(`Invalid configuration of route '${t}': path cannot start with a slash`);if(""===e.path&&void 0!==e.redirectTo&&void 0===e.pathMatch)throw new Error(`Invalid configuration of route '{path: "${t}", redirectTo: "${e.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`);if(void 0!==e.pathMatch&&"full"!==e.pathMatch&&"prefix"!==e.pathMatch)throw new Error(`Invalid configuration of route '${t}': pathMatch can only be set to 'prefix' or 'full'`);e.children&&Sp(e.children,t)}function Op(e,t){return t?e||t.path?e&&!t.path?e+"/":!e&&t.path?t.path:`${e}/${t.path}`:"":e}function Ip(e){const t=e.children&&e.children.map(Ip),n=t?Object.assign(Object.assign({},e),{children:t}):Object.assign({},e);return!n.component&&(t||n.loadChildren)&&n.outlet&&"primary"!==n.outlet&&(n.component=xp),n}function Fp(e,t){const n=Object.keys(e),o=Object.keys(t);if(!n||!o||n.length!=o.length)return!1;let a;for(let r=0;r<n.length;r++)if(a=n[r],!Dp(e[a],t[a]))return!1;return!0}function Dp(e,t){return Array.isArray(e)&&Array.isArray(t)?e.length==t.length&&e.every(e=>t.indexOf(e)>-1):e===t}function Ap(e){return Array.prototype.concat.apply([],e)}function Ep(e){return e.length>0?e[e.length-1]:null}function Rp(e,t){for(const n in e)e.hasOwnProperty(n)&&t(e[n],n)}function Np(e){return(t=e)&&"function"==typeof t.subscribe?e:Xr(e)?U(Promise.resolve(e)):cc(e);var t}function jp(e,t,n){return n?function(e,t){return Fp(e,t)}(e.queryParams,t.queryParams)&&function e(t,n){if(!Up(t.segments,n.segments))return!1;if(t.numberOfChildren!==n.numberOfChildren)return!1;for(const o in n.children){if(!t.children[o])return!1;if(!e(t.children[o],n.children[o]))return!1}return!0}(e.root,t.root):function(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(n=>Dp(e[n],t[n]))}(e.queryParams,t.queryParams)&&function e(t,n){return function t(n,o,a){if(n.segments.length>a.length)return!!Up(n.segments.slice(0,a.length),a)&&!o.hasChildren();if(n.segments.length===a.length){if(!Up(n.segments,a))return!1;for(const t in o.children){if(!n.children[t])return!1;if(!e(n.children[t],o.children[t]))return!1}return!0}{const e=a.slice(0,n.segments.length),r=a.slice(n.segments.length);return!!Up(n.segments,e)&&!!n.children.primary&&t(n.children.primary,o,r)}}(t,n,n.segments)}(e.root,t.root)}class zp{constructor(e,t,n){this.root=e,this.queryParams=t,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Cp(this.queryParams)),this._queryParamMap}toString(){return qp.serialize(this)}}class Lp{constructor(e,t){this.segments=e,this.children=t,this.parent=null,Rp(t,(e,t)=>e.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Gp(this)}}class Xp{constructor(e,t){this.path=e,this.parameters=t}get parameterMap(){return this._parameterMap||(this._parameterMap=Cp(this.parameters)),this._parameterMap}toString(){return Qp(this)}}function Up(e,t){return e.length===t.length&&e.every((e,n)=>e.path===t[n].path)}function Bp(e,t){let n=[];return Rp(e.children,(e,o)=>{"primary"===o&&(n=n.concat(t(e,o)))}),Rp(e.children,(e,o)=>{"primary"!==o&&(n=n.concat(t(e,o)))}),n}class Vp{}class Hp{parse(e){const t=new od(e);return new zp(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(e){return`${"/"+function e(t,n){if(!t.hasChildren())return Gp(t);if(n){const n=t.children.primary?e(t.children.primary,!1):"",o=[];return Rp(t.children,(t,n)=>{"primary"!==n&&o.push(`${n}:${e(t,!1)}`)}),o.length>0?`${n}(${o.join("//")})`:n}{const n=Bp(t,(n,o)=>"primary"===o?[e(t.children.primary,!1)]:[`${o}:${e(n,!1)}`]);return`${Gp(t)}/(${n.join("//")})`}}(e.root,!0)}${function(e){const t=Object.keys(e).map(t=>{const n=e[t];return Array.isArray(n)?n.map(e=>`${$p(t)}=${$p(e)}`).join("&"):`${$p(t)}=${$p(n)}`});return t.length?"?"+t.join("&"):""}(e.queryParams)}${"string"==typeof e.fragment?"#"+encodeURI(e.fragment):""}`}}const qp=new Hp;function Gp(e){return e.segments.map(e=>Qp(e)).join("/")}function Wp(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function $p(e){return Wp(e).replace(/%3B/gi,";")}function Zp(e){return Wp(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Kp(e){return decodeURIComponent(e)}function Jp(e){return Kp(e.replace(/\+/g,"%20"))}function Qp(e){return`${Zp(e.path)}${t=e.parameters,Object.keys(t).map(e=>`;${Zp(e)}=${Zp(t[e])}`).join("")}`;var t}const Yp=/^[^\/()?;=#]+/;function ed(e){const t=e.match(Yp);return t?t[0]:""}const td=/^[^=?&#]+/,nd=/^[^?&#]+/;class od{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Lp([],{}):new Lp([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(e.length>0||Object.keys(t).length>0)&&(n.primary=new Lp(e,t)),n}parseSegment(){const e=ed(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(e),new Xp(Kp(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const t=ed(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=ed(this.remaining);e&&(n=e,this.capture(n))}e[Kp(t)]=Kp(n)}parseQueryParam(e){const t=function(e){const t=e.match(td);return t?t[0]:""}(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=function(e){const t=e.match(nd);return t?t[0]:""}(this.remaining);e&&(n=e,this.capture(n))}const o=Jp(t),a=Jp(n);if(e.hasOwnProperty(o)){let t=e[o];Array.isArray(t)||(t=[t],e[o]=t),t.push(a)}else e[o]=a}parseParens(e){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=ed(this.remaining),o=this.remaining[n.length];if("/"!==o&&")"!==o&&";"!==o)throw new Error(`Cannot parse url '${this.url}'`);let a=void 0;n.indexOf(":")>-1?(a=n.substr(0,n.indexOf(":")),this.capture(a),this.capture(":")):e&&(a="primary");const r=this.parseChildren();t[a]=1===Object.keys(r).length?r.primary:new Lp([],r),this.consumeOptional("//")}return t}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new Error(`Expected "${e}".`)}}class ad{constructor(e){this._root=e}get root(){return this._root.value}parent(e){const t=this.pathFromRoot(e);return t.length>1?t[t.length-2]:null}children(e){const t=rd(e,this._root);return t?t.children.map(e=>e.value):[]}firstChild(e){const t=rd(e,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(e){const t=sd(e,this._root);return t.length<2?[]:t[t.length-2].children.map(e=>e.value).filter(t=>t!==e)}pathFromRoot(e){return sd(e,this._root).map(e=>e.value)}}function rd(e,t){if(e===t.value)return t;for(const n of t.children){const t=rd(e,n);if(t)return t}return null}function sd(e,t){if(e===t.value)return[t];for(const n of t.children){const o=sd(e,n);if(o.length)return o.unshift(t),o}return[]}class id{constructor(e,t){this.value=e,this.children=t}toString(){return`TreeNode(${this.value})`}}function ld(e){const t={};return e&&e.children.forEach(e=>t[e.value.outlet]=e),t}class ud extends ad{constructor(e,t){super(e),this.snapshot=t,fd(this,e)}toString(){return this.snapshot.toString()}}function cd(e,t){const n=function(e,t){const n=new hd([],{},{},"",{},"primary",t,null,e.root,-1,{});return new md("",new id(n,[]))}(e,t),o=new pc([new Xp("",{})]),a=new pc({}),r=new pc({}),s=new pc({}),i=new pc(""),l=new pd(o,a,s,i,r,"primary",t,n.root);return l.snapshot=n.root,new ud(new id(l,[]),n)}class pd{constructor(e,t,n,o,a,r,s,i){this.url=e,this.params=t,this.queryParams=n,this.fragment=o,this.data=a,this.outlet=r,this.component=s,this._futureSnapshot=i}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(j(e=>Cp(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(j(e=>Cp(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function dd(e,t="emptyOnly"){const n=e.pathFromRoot;let o=0;if("always"!==t)for(o=n.length-1;o>=1;){const e=n[o],t=n[o-1];if(e.routeConfig&&""===e.routeConfig.path)o--;else{if(t.component)break;o--}}return function(e){return e.reduce((e,t)=>({params:Object.assign(Object.assign({},e.params),t.params),data:Object.assign(Object.assign({},e.data),t.data),resolve:Object.assign(Object.assign({},e.resolve),t._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(o))}class hd{constructor(e,t,n,o,a,r,s,i,l,u,c){this.url=e,this.params=t,this.queryParams=n,this.fragment=o,this.data=a,this.outlet=r,this.component=s,this.routeConfig=i,this._urlSegment=l,this._lastPathIndex=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Cp(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Cp(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(e=>e.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class md extends ad{constructor(e,t){super(t),this.url=e,fd(this,t)}toString(){return gd(this._root)}}function fd(e,t){t.value._routerState=e,t.children.forEach(t=>fd(e,t))}function gd(e){const t=e.children.length>0?` { ${e.children.map(gd).join(", ")} } `:"";return`${e.value}${t}`}function _d(e){if(e.snapshot){const t=e.snapshot,n=e._futureSnapshot;e.snapshot=n,Fp(t.queryParams,n.queryParams)||e.queryParams.next(n.queryParams),t.fragment!==n.fragment&&e.fragment.next(n.fragment),Fp(t.params,n.params)||e.params.next(n.params),function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!Fp(e[n],t[n]))return!1;return!0}(t.url,n.url)||e.url.next(n.url),Fp(t.data,n.data)||e.data.next(n.data)}else e.snapshot=e._futureSnapshot,e.data.next(e._futureSnapshot.data)}function yd(e,t){var n,o;return Fp(e.params,t.params)&&Up(n=e.url,o=t.url)&&n.every((e,t)=>Fp(e.parameters,o[t].parameters))&&!(!e.parent!=!t.parent)&&(!e.parent||yd(e.parent,t.parent))}function bd(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function vd(e,t,n,o,a){let r={};return o&&Rp(o,(e,t)=>{r[t]=Array.isArray(e)?e.map(e=>""+e):""+e}),new zp(n.root===e?t:function e(t,n,o){const a={};return Rp(t.children,(t,r)=>{a[r]=t===n?o:e(t,n,o)}),new Lp(t.segments,a)}(n.root,e,t),r,a)}class xd{constructor(e,t,n){if(this.isAbsolute=e,this.numberOfDoubleDots=t,this.commands=n,e&&n.length>0&&bd(n[0]))throw new Error("Root segment cannot have matrix parameters");const o=n.find(e=>"object"==typeof e&&null!=e&&e.outlets);if(o&&o!==Ep(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class wd{constructor(e,t,n){this.segmentGroup=e,this.processChildren=t,this.index=n}}function Cd(e){return"object"==typeof e&&null!=e&&e.outlets?e.outlets.primary:""+e}function Td(e,t,n){if(e||(e=new Lp([],{})),0===e.segments.length&&e.hasChildren())return kd(e,t,n);const o=function(e,t,n){let o=0,a=t;const r={match:!1,pathIndex:0,commandIndex:0};for(;a<e.segments.length;){if(o>=n.length)return r;const t=e.segments[a],s=Cd(n[o]),i=o<n.length-1?n[o+1]:null;if(a>0&&void 0===s)break;if(s&&i&&"object"==typeof i&&void 0===i.outlets){if(!Od(s,i,t))return r;o+=2}else{if(!Od(s,{},t))return r;o++}a++}return{match:!0,pathIndex:a,commandIndex:o}}(e,t,n),a=n.slice(o.commandIndex);if(o.match&&o.pathIndex<e.segments.length){const t=new Lp(e.segments.slice(0,o.pathIndex),{});return t.children.primary=new Lp(e.segments.slice(o.pathIndex),e.children),kd(t,0,a)}return o.match&&0===a.length?new Lp(e.segments,{}):o.match&&!e.hasChildren()?Pd(e,t,n):o.match?kd(e,0,a):Pd(e,t,n)}function kd(e,t,n){if(0===n.length)return new Lp(e.segments,{});{const o=function(e){return"object"!=typeof e[0]||void 0===e[0].outlets?{primary:e}:e[0].outlets}(n),a={};return Rp(o,(n,o)=>{null!==n&&(a[o]=Td(e.children[o],t,n))}),Rp(e.children,(e,t)=>{void 0===o[t]&&(a[t]=e)}),new Lp(e.segments,a)}}function Pd(e,t,n){const o=e.segments.slice(0,t);let a=0;for(;a<n.length;){if("object"==typeof n[a]&&void 0!==n[a].outlets){const e=Sd(n[a].outlets);return new Lp(o,e)}if(0===a&&bd(n[0])){o.push(new Xp(e.segments[t].path,n[0])),a++;continue}const r=Cd(n[a]),s=a<n.length-1?n[a+1]:null;r&&s&&bd(s)?(o.push(new Xp(r,Md(s))),a+=2):(o.push(new Xp(r,{})),a++)}return new Lp(o,{})}function Sd(e){const t={};return Rp(e,(e,n)=>{null!==e&&(t[n]=Pd(new Lp([],{}),0,e))}),t}function Md(e){const t={};return Rp(e,(e,n)=>t[n]=""+e),t}function Od(e,t,n){return e==n.path&&Fp(t,n.parameters)}class Id{constructor(e,t,n,o){this.routeReuseStrategy=e,this.futureState=t,this.currState=n,this.forwardEvent=o}activate(e){const t=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,n,e),_d(this.futureState.root),this.activateChildRoutes(t,n,e)}deactivateChildRoutes(e,t,n){const o=ld(t);e.children.forEach(e=>{const t=e.value.outlet;this.deactivateRoutes(e,o[t],n),delete o[t]}),Rp(o,(e,t)=>{this.deactivateRouteAndItsChildren(e,n)})}deactivateRoutes(e,t,n){const o=e.value,a=t?t.value:null;if(o===a)if(o.component){const a=n.getContext(o.outlet);a&&this.deactivateChildRoutes(e,t,a.children)}else this.deactivateChildRoutes(e,t,n);else a&&this.deactivateRouteAndItsChildren(t,n)}deactivateRouteAndItsChildren(e,t){this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,t):this.deactivateRouteAndOutlet(e,t)}detachAndStoreRouteSubtree(e,t){const n=t.getContext(e.value.outlet);if(n&&n.outlet){const t=n.outlet.detach(),o=n.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:t,route:e,contexts:o})}}deactivateRouteAndOutlet(e,t){const n=t.getContext(e.value.outlet);if(n){const o=ld(e),a=e.value.component?n.children:t;Rp(o,(e,t)=>this.deactivateRouteAndItsChildren(e,a)),n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated())}}activateChildRoutes(e,t,n){const o=ld(t);e.children.forEach(e=>{this.activateRoutes(e,o[e.value.outlet],n),this.forwardEvent(new bp(e.value.snapshot))}),e.children.length&&this.forwardEvent(new _p(e.value.snapshot))}activateRoutes(e,t,n){const o=e.value,a=t?t.value:null;if(_d(o),o===a)if(o.component){const a=n.getOrCreateContext(o.outlet);this.activateChildRoutes(e,t,a.children)}else this.activateChildRoutes(e,t,n);else if(o.component){const t=n.getOrCreateContext(o.outlet);if(this.routeReuseStrategy.shouldAttach(o.snapshot)){const e=this.routeReuseStrategy.retrieve(o.snapshot);this.routeReuseStrategy.store(o.snapshot,null),t.children.onOutletReAttached(e.contexts),t.attachRef=e.componentRef,t.route=e.route.value,t.outlet&&t.outlet.attach(e.componentRef,e.route.value),Fd(e.route)}else{const n=function(e){for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(o.snapshot),a=n?n.module.componentFactoryResolver:null;t.attachRef=null,t.route=o,t.resolver=a,t.outlet&&t.outlet.activateWith(o,a),this.activateChildRoutes(e,null,t.children)}}else this.activateChildRoutes(e,null,n)}}function Fd(e){_d(e.value),e.children.forEach(Fd)}function Dd(e){return"function"==typeof e}function Ad(e){return e instanceof zp}class Ed{constructor(e){this.segmentGroup=e||null}}class Rd{constructor(e){this.urlTree=e}}function Nd(e){return new v(t=>t.error(new Ed(e)))}function jd(e){return new v(t=>t.error(new Rd(e)))}function zd(e){return new v(t=>t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`)))}class Ld{constructor(e,t,n,o,a){this.configLoader=t,this.urlSerializer=n,this.urlTree=o,this.config=a,this.allowRedirects=!0,this.ngModule=e.get(Ze)}apply(){return this.expandSegmentGroup(this.ngModule,this.config,this.urlTree.root,"primary").pipe(j(e=>this.createUrlTree(e,this.urlTree.queryParams,this.urlTree.fragment))).pipe(Rc(e=>{if(e instanceof Rd)return this.allowRedirects=!1,this.match(e.urlTree);if(e instanceof Ed)throw this.noMatchError(e);throw e}))}match(e){return this.expandSegmentGroup(this.ngModule,this.config,e.root,"primary").pipe(j(t=>this.createUrlTree(t,e.queryParams,e.fragment))).pipe(Rc(e=>{if(e instanceof Ed)throw this.noMatchError(e);throw e}))}noMatchError(e){return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}createUrlTree(e,t,n){const o=e.segments.length>0?new Lp([],{primary:e}):e;return new zp(o,t,n)}expandSegmentGroup(e,t,n,o){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(e,t,n).pipe(j(e=>new Lp([],e))):this.expandSegment(e,n,t,n.segments,o,!0)}expandChildren(e,t,n){return function(e,t){if(0===Object.keys(e).length)return cc({});const n=[],o=[],a={};return Rp(e,(e,r)=>{const s=t(r,e).pipe(j(e=>a[r]=e));"primary"===r?n.push(s):o.push(s)}),cc.apply(null,n.concat(o)).pipe(bc(),Ec(),j(()=>a))}(n.children,(n,o)=>this.expandSegmentGroup(e,t,o,n))}expandSegment(e,t,n,o,a,r){return cc(...n).pipe(j(s=>this.expandSegmentAgainstRoute(e,t,n,s,o,a,r).pipe(Rc(e=>{if(e instanceof Ed)return cc(null);throw e}))),bc(),Uc(e=>!!e),Rc((e,n)=>{if(e instanceof dc||"EmptyError"===e.name){if(this.noLeftoversInUrl(t,o,a))return cc(new Lp([],{}));throw new Ed(t)}throw e}))}noLeftoversInUrl(e,t,n){return 0===t.length&&!e.children[n]}expandSegmentAgainstRoute(e,t,n,o,a,r,s){return Vd(o)!==r?Nd(t):void 0===o.redirectTo?this.matchSegmentAgainstRoute(e,t,o,a):s&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,t,n,o,a,r):Nd(t)}expandSegmentAgainstRouteUsingRedirect(e,t,n,o,a,r){return"**"===o.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,n,o,r):this.expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,o,a,r)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,t,n,o){const a=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?jd(a):this.lineralizeSegments(n,a).pipe(B(n=>{const a=new Lp(n,{});return this.expandSegment(e,a,t,n,o,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,o,a,r){const{matched:s,consumedSegments:i,lastChild:l,positionalParamSegments:u}=Xd(t,o,a);if(!s)return Nd(t);const c=this.applyRedirectCommands(i,o.redirectTo,u);return o.redirectTo.startsWith("/")?jd(c):this.lineralizeSegments(o,c).pipe(B(o=>this.expandSegment(e,t,n,o.concat(a.slice(l)),r,!1)))}matchSegmentAgainstRoute(e,t,n,o){if("**"===n.path)return n.loadChildren?this.configLoader.load(e.injector,n).pipe(j(e=>(n._loadedConfig=e,new Lp(o,{})))):cc(new Lp(o,{}));const{matched:a,consumedSegments:r,lastChild:s}=Xd(t,n,o);if(!a)return Nd(t);const i=o.slice(s);return this.getChildConfig(e,n,o).pipe(B(e=>{const n=e.module,o=e.routes,{segmentGroup:a,slicedSegments:s}=function(e,t,n,o){return n.length>0&&function(e,t,n){return n.some(n=>Bd(e,t,n)&&"primary"!==Vd(n))}(e,n,o)?{segmentGroup:Ud(new Lp(t,function(e,t){const n={};n.primary=t;for(const o of e)""===o.path&&"primary"!==Vd(o)&&(n[Vd(o)]=new Lp([],{}));return n}(o,new Lp(n,e.children)))),slicedSegments:[]}:0===n.length&&function(e,t,n){return n.some(n=>Bd(e,t,n))}(e,n,o)?{segmentGroup:Ud(new Lp(e.segments,function(e,t,n,o){const a={};for(const r of n)Bd(e,t,r)&&!o[Vd(r)]&&(a[Vd(r)]=new Lp([],{}));return Object.assign(Object.assign({},o),a)}(e,n,o,e.children))),slicedSegments:n}:{segmentGroup:e,slicedSegments:n}}(t,r,i,o);return 0===s.length&&a.hasChildren()?this.expandChildren(n,o,a).pipe(j(e=>new Lp(r,e))):0===o.length&&0===s.length?cc(new Lp(r,{})):this.expandSegment(n,a,o,s,"primary",!0).pipe(j(e=>new Lp(r.concat(e.segments),e.children)))}))}getChildConfig(e,t,n){return t.children?cc(new Pp(t.children,e)):t.loadChildren?void 0!==t._loadedConfig?cc(t._loadedConfig):function(e,t,n){const o=t.canLoad;return o&&0!==o.length?U(o).pipe(j(o=>{const a=e.get(o);let r;if(function(e){return e&&Dd(e.canLoad)}(a))r=a.canLoad(t,n);else{if(!Dd(a))throw new Error("Invalid CanLoad guard");r=a(t,n)}return Np(r)})).pipe(bc(),(a=e=>!0===e,e=>e.lift(new Bc(a,void 0,e)))):cc(!0);var a}(e.injector,t,n).pipe(B(n=>n?this.configLoader.load(e.injector,t).pipe(j(e=>(t._loadedConfig=e,e))):function(e){return new v(t=>t.error(Tp(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)))}(t))):cc(new Pp([],e))}lineralizeSegments(e,t){let n=[],o=t.root;for(;;){if(n=n.concat(o.segments),0===o.numberOfChildren)return cc(n);if(o.numberOfChildren>1||!o.children.primary)return zd(e.redirectTo);o=o.children.primary}}applyRedirectCommands(e,t,n){return this.applyRedirectCreatreUrlTree(t,this.urlSerializer.parse(t),e,n)}applyRedirectCreatreUrlTree(e,t,n,o){const a=this.createSegmentGroup(e,t.root,n,o);return new zp(a,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(e,t){const n={};return Rp(e,(e,o)=>{if("string"==typeof e&&e.startsWith(":")){const a=e.substring(1);n[o]=t[a]}else n[o]=e}),n}createSegmentGroup(e,t,n,o){const a=this.createSegments(e,t.segments,n,o);let r={};return Rp(t.children,(t,a)=>{r[a]=this.createSegmentGroup(e,t,n,o)}),new Lp(a,r)}createSegments(e,t,n,o){return t.map(t=>t.path.startsWith(":")?this.findPosParam(e,t,o):this.findOrReturn(t,n))}findPosParam(e,t,n){const o=n[t.path.substring(1)];if(!o)throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`);return o}findOrReturn(e,t){let n=0;for(const o of t){if(o.path===e.path)return t.splice(n),o;n++}return e}}function Xd(e,t,n){if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||n.length>0)?{matched:!1,consumedSegments:[],lastChild:0,positionalParamSegments:{}}:{matched:!0,consumedSegments:[],lastChild:0,positionalParamSegments:{}};const o=(t.matcher||kp)(n,e,t);return o?{matched:!0,consumedSegments:o.consumed,lastChild:o.consumed.length,positionalParamSegments:o.posParams}:{matched:!1,consumedSegments:[],lastChild:0,positionalParamSegments:{}}}function Ud(e){if(1===e.numberOfChildren&&e.children.primary){const t=e.children.primary;return new Lp(e.segments.concat(t.segments),t.children)}return e}function Bd(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path&&void 0!==n.redirectTo}function Vd(e){return e.outlet||"primary"}class Hd{constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class qd{constructor(e,t){this.component=e,this.route=t}}function Gd(e,t,n){const o=e._root;return function e(t,n,o,a,r={canDeactivateChecks:[],canActivateChecks:[]}){const s=ld(n);return t.children.forEach(t=>{!function(t,n,o,a,r={canDeactivateChecks:[],canActivateChecks:[]}){const s=t.value,i=n?n.value:null,l=o?o.getContext(t.value.outlet):null;if(i&&s.routeConfig===i.routeConfig){const u=function(e,t,n){if("function"==typeof n)return n(e,t);switch(n){case"pathParamsChange":return!Up(e.url,t.url);case"pathParamsOrQueryParamsChange":return!Up(e.url,t.url)||!Fp(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!yd(e,t)||!Fp(e.queryParams,t.queryParams);case"paramsChange":default:return!yd(e,t)}}(i,s,s.routeConfig.runGuardsAndResolvers);u?r.canActivateChecks.push(new Hd(a)):(s.data=i.data,s._resolvedData=i._resolvedData),e(t,n,s.component?l?l.children:null:o,a,r),u&&r.canDeactivateChecks.push(new qd(l&&l.outlet&&l.outlet.component||null,i))}else i&&$d(n,l,r),r.canActivateChecks.push(new Hd(a)),e(t,null,s.component?l?l.children:null:o,a,r)}(t,s[t.value.outlet],o,a.concat([t.value]),r),delete s[t.value.outlet]}),Rp(s,(e,t)=>$d(e,o.getContext(t),r)),r}(o,t?t._root:null,n,[o.value])}function Wd(e,t,n){const o=function(e){if(!e)return null;for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(o?o.module.injector:n).get(e)}function $d(e,t,n){const o=ld(e),a=e.value;Rp(o,(e,o)=>{$d(e,a.component?t?t.children.getContext(o):null:t,n)}),n.canDeactivateChecks.push(new qd(a.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,a))}const Zd=Symbol("INITIAL_VALUE");function Kd(){return Hc(e=>function(...e){let t=null,n=null;return S(e[e.length-1])&&(n=e.pop()),"function"==typeof e[e.length-1]&&(t=e.pop()),1===e.length&&l(e[0])&&(e=e[0]),G(e,n).lift(new mc(t))}(...e.map(e=>e.pipe(zc(1),function(...e){const t=e[e.length-1];return S(t)?(e.pop(),n=>Wc(e,n,t)):t=>Wc(e,t)}(Zd)))).pipe($c((e,t)=>{let n=!1;return t.reduce((e,o,a)=>{if(e!==Zd)return e;if(o===Zd&&(n=!0),!n){if(!1===o)return o;if(a===t.length-1||Ad(o))return o}return e},e)},Zd),vc(e=>e!==Zd),j(e=>Ad(e)?e:!0===e),zc(1)))}function Jd(e,t){return null!==e&&t&&t(new yp(e)),cc(!0)}function Qd(e,t){return null!==e&&t&&t(new gp(e)),cc(!0)}function Yd(e,t,n){const o=t.routeConfig?t.routeConfig.canActivate:null;return o&&0!==o.length?cc(o.map(o=>yc(()=>{const a=Wd(o,t,n);let r;if(function(e){return e&&Dd(e.canActivate)}(a))r=Np(a.canActivate(t,e));else{if(!Dd(a))throw new Error("Invalid CanActivate guard");r=Np(a(t,e))}return r.pipe(Uc())}))).pipe(Kd()):cc(!0)}function eh(e,t,n){const o=t[t.length-1],a=t.slice(0,t.length-1).reverse().map(e=>function(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(e)).filter(e=>null!==e).map(t=>yc(()=>cc(t.guards.map(a=>{const r=Wd(a,t.node,n);let s;if(function(e){return e&&Dd(e.canActivateChild)}(r))s=Np(r.canActivateChild(o,e));else{if(!Dd(r))throw new Error("Invalid CanActivateChild guard");s=Np(r(o,e))}return s.pipe(Uc())})).pipe(Kd())));return cc(a).pipe(Kd())}class th{}class nh{constructor(e,t,n,o,a,r){this.rootComponentType=e,this.config=t,this.urlTree=n,this.url=o,this.paramsInheritanceStrategy=a,this.relativeLinkResolution=r}recognize(){try{const e=rh(this.urlTree.root,[],[],this.config,this.relativeLinkResolution).segmentGroup,t=this.processSegmentGroup(this.config,e,"primary"),n=new hd([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},"primary",this.rootComponentType,null,this.urlTree.root,-1,{}),o=new id(n,t),a=new md(this.url,o);return this.inheritParamsAndData(a._root),cc(a)}catch(e){return new v(t=>t.error(e))}}inheritParamsAndData(e){const t=e.value,n=dd(t,this.paramsInheritanceStrategy);t.params=Object.freeze(n.params),t.data=Object.freeze(n.data),e.children.forEach(e=>this.inheritParamsAndData(e))}processSegmentGroup(e,t,n){return 0===t.segments.length&&t.hasChildren()?this.processChildren(e,t):this.processSegment(e,t,t.segments,n)}processChildren(e,t){const n=Bp(t,(t,n)=>this.processSegmentGroup(e,t,n));return function(e){const t={};e.forEach(e=>{const n=t[e.value.outlet];if(n){const t=n.url.map(e=>e.toString()).join("/"),o=e.value.url.map(e=>e.toString()).join("/");throw new Error(`Two segments cannot have the same outlet name: '${t}' and '${o}'.`)}t[e.value.outlet]=e.value})}(n),n.sort((e,t)=>"primary"===e.value.outlet?-1:"primary"===t.value.outlet?1:e.value.outlet.localeCompare(t.value.outlet)),n}processSegment(e,t,n,o){for(const r of e)try{return this.processSegmentAgainstRoute(r,t,n,o)}catch(a){if(!(a instanceof th))throw a}if(this.noLeftoversInUrl(t,n,o))return[];throw new th}noLeftoversInUrl(e,t,n){return 0===t.length&&!e.children[n]}processSegmentAgainstRoute(e,t,n,o){if(e.redirectTo)throw new th;if((e.outlet||"primary")!==o)throw new th;let a,r=[],s=[];if("**"===e.path){const r=n.length>0?Ep(n).parameters:{};a=new hd(n,r,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,lh(e),o,e.component,e,oh(t),ah(t)+n.length,uh(e))}else{const i=function(e,t,n){if(""===t.path){if("full"===t.pathMatch&&(e.hasChildren()||n.length>0))throw new th;return{consumedSegments:[],lastChild:0,parameters:{}}}const o=(t.matcher||kp)(n,e,t);if(!o)throw new th;const a={};Rp(o.posParams,(e,t)=>{a[t]=e.path});const r=o.consumed.length>0?Object.assign(Object.assign({},a),o.consumed[o.consumed.length-1].parameters):a;return{consumedSegments:o.consumed,lastChild:o.consumed.length,parameters:r}}(t,e,n);r=i.consumedSegments,s=n.slice(i.lastChild),a=new hd(r,i.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,lh(e),o,e.component,e,oh(t),ah(t)+r.length,uh(e))}const i=function(e){return e.children?e.children:e.loadChildren?e._loadedConfig.routes:[]}(e),{segmentGroup:l,slicedSegments:u}=rh(t,r,s,i,this.relativeLinkResolution);if(0===u.length&&l.hasChildren()){const e=this.processChildren(i,l);return[new id(a,e)]}if(0===i.length&&0===u.length)return[new id(a,[])];const c=this.processSegment(i,l,u,"primary");return[new id(a,c)]}}function oh(e){let t=e;for(;t._sourceSegment;)t=t._sourceSegment;return t}function ah(e){let t=e,n=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,n+=t._segmentIndexShift?t._segmentIndexShift:0;return n-1}function rh(e,t,n,o,a){if(n.length>0&&function(e,t,n){return n.some(n=>sh(e,t,n)&&"primary"!==ih(n))}(e,n,o)){const a=new Lp(t,function(e,t,n,o){const a={};a.primary=o,o._sourceSegment=e,o._segmentIndexShift=t.length;for(const r of n)if(""===r.path&&"primary"!==ih(r)){const n=new Lp([],{});n._sourceSegment=e,n._segmentIndexShift=t.length,a[ih(r)]=n}return a}(e,t,o,new Lp(n,e.children)));return a._sourceSegment=e,a._segmentIndexShift=t.length,{segmentGroup:a,slicedSegments:[]}}if(0===n.length&&function(e,t,n){return n.some(n=>sh(e,t,n))}(e,n,o)){const r=new Lp(e.segments,function(e,t,n,o,a,r){const s={};for(const i of o)if(sh(e,n,i)&&!a[ih(i)]){const n=new Lp([],{});n._sourceSegment=e,n._segmentIndexShift="legacy"===r?e.segments.length:t.length,s[ih(i)]=n}return Object.assign(Object.assign({},a),s)}(e,t,n,o,e.children,a));return r._sourceSegment=e,r._segmentIndexShift=t.length,{segmentGroup:r,slicedSegments:n}}const r=new Lp(e.segments,e.children);return r._sourceSegment=e,r._segmentIndexShift=t.length,{segmentGroup:r,slicedSegments:n}}function sh(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path&&void 0===n.redirectTo}function ih(e){return e.outlet||"primary"}function lh(e){return e.data||{}}function uh(e){return e.resolve||{}}function ch(e,t,n,o){const a=Wd(e,t,o);return Np(a.resolve?a.resolve(t,n):a(t,n))}function ph(e){return function(t){return t.pipe(Hc(t=>{const n=e(t);return n?U(n).pipe(j(()=>t)):U([t])}))}}class dh{shouldDetach(e){return!1}store(e,t){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,t){return e.routeConfig===t.routeConfig}}const hh=new Re("ROUTES");class mh{constructor(e,t,n,o){this.loader=e,this.compiler=t,this.onLoadStartListener=n,this.onLoadEndListener=o}load(e,t){return this.onLoadStartListener&&this.onLoadStartListener(t),this.loadModuleFactory(t.loadChildren).pipe(j(n=>{this.onLoadEndListener&&this.onLoadEndListener(t);const o=n.create(e);return new Pp(Ap(o.injector.get(hh)).map(Ip),o)}))}loadModuleFactory(e){return"string"==typeof e?U(this.loader.load(e)):Np(e()).pipe(B(e=>e instanceof Ke?cc(e):U(this.compiler.compileModuleAsync(e))))}}class fh{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,t){return e}}function gh(e){throw e}function _h(e,t,n){return t.parse("/")}function yh(e,t){return cc(null)}let bh=(()=>{class e{constructor(e,t,n,o,a,r,s,i){this.rootComponentType=e,this.urlSerializer=t,this.rootContexts=n,this.location=o,this.config=i,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new k,this.errorHandler=gh,this.malformedUriErrorHandler=_h,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:yh,afterPreactivation:yh},this.urlHandlingStrategy=new fh,this.routeReuseStrategy=new dh,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="legacy",this.ngModule=a.get(Ze),this.console=a.get(Ri);const l=a.get(Zi);this.isNgZoneEnabled=l instanceof Zi,this.resetConfig(i),this.currentUrlTree=new zp(new Lp([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new mh(r,s,e=>this.triggerEvent(new mp(e)),e=>this.triggerEvent(new fp(e))),this.routerState=cd(this.currentUrlTree,this.rootComponentType),this.transitions=new pc({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(e){const t=this.events;return e.pipe(vc(e=>0!==e.id),j(e=>Object.assign(Object.assign({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl)})),Hc(e=>{let n=!1,o=!1;return cc(e).pipe(Yc(e=>{this.currentNavigation={id:e.id,initialUrl:e.currentRawUrl,extractedUrl:e.extractedUrl,trigger:e.source,extras:e.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Hc(e=>{const n=!this.navigated||e.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl))return cc(e).pipe(Hc(e=>{const n=this.transitions.getValue();return t.next(new rp(e.id,this.serializeUrl(e.extractedUrl),e.source,e.restoredState)),n!==this.transitions.getValue()?gc:[e]}),Hc(e=>Promise.resolve(e)),(o=this.ngModule.injector,a=this.configLoader,r=this.urlSerializer,s=this.config,function(e){return e.pipe(Hc(e=>function(e,t,n,o,a){return new Ld(e,t,n,o,a).apply()}(o,a,r,e.extractedUrl,s).pipe(j(t=>Object.assign(Object.assign({},e),{urlAfterRedirects:t})))))}),Yc(e=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:e.urlAfterRedirects})}),function(e,t,n,o,a){return function(r){return r.pipe(B(r=>function(e,t,n,o,a="emptyOnly",r="legacy"){return new nh(e,t,n,o,a,r).recognize()}(e,t,r.urlAfterRedirects,n(r.urlAfterRedirects),o,a).pipe(j(e=>Object.assign(Object.assign({},r),{targetSnapshot:e})))))}}(this.rootComponentType,this.config,e=>this.serializeUrl(e),this.paramsInheritanceStrategy,this.relativeLinkResolution),Yc(e=>{"eager"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(e.urlAfterRedirects,!!e.extras.replaceUrl,e.id,e.extras.state),this.browserUrlTree=e.urlAfterRedirects)}),Yc(e=>{const n=new up(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);t.next(n)}));var o,a,r,s;if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:o,source:a,restoredState:r,extras:s}=e,i=new rp(n,this.serializeUrl(o),a,r);t.next(i);const l=cd(o,this.rootComponentType).snapshot;return cc(Object.assign(Object.assign({},e),{targetSnapshot:l,urlAfterRedirects:o,extras:Object.assign(Object.assign({},s),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=e.rawUrl,this.browserUrlTree=e.urlAfterRedirects,e.resolve(null),gc}),ph(e=>{const{targetSnapshot:t,id:n,extractedUrl:o,rawUrl:a,extras:{skipLocationChange:r,replaceUrl:s}}=e;return this.hooks.beforePreactivation(t,{navigationId:n,appliedUrlTree:o,rawUrlTree:a,skipLocationChange:!!r,replaceUrl:!!s})}),Yc(e=>{const t=new cp(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),j(e=>Object.assign(Object.assign({},e),{guards:Gd(e.targetSnapshot,e.currentSnapshot,this.rootContexts)})),function(e,t){return function(n){return n.pipe(B(n=>{const{targetSnapshot:o,currentSnapshot:a,guards:{canActivateChecks:r,canDeactivateChecks:s}}=n;return 0===s.length&&0===r.length?cc(Object.assign(Object.assign({},n),{guardsResult:!0})):function(e,t,n,o){return U(e).pipe(B(e=>function(e,t,n,o,a){const r=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return r&&0!==r.length?cc(r.map(r=>{const s=Wd(r,t,a);let i;if(function(e){return e&&Dd(e.canDeactivate)}(s))i=Np(s.canDeactivate(e,t,n,o));else{if(!Dd(s))throw new Error("Invalid CanDeactivate guard");i=Np(s(e,t,n,o))}return i.pipe(Uc())})).pipe(Kd()):cc(!0)}(e.component,e.route,n,t,o)),Uc(e=>!0!==e,!0))}(s,o,a,e).pipe(B(n=>n&&"boolean"==typeof n?function(e,t,n,o){return U(t).pipe(Jc(t=>U([Qd(t.route.parent,o),Jd(t.route,o),eh(e,t.path,n),Yd(e,t.route,n)]).pipe(bc(),Uc(e=>!0!==e,!0))),Uc(e=>!0!==e,!0))}(o,r,e,t):cc(n)),j(e=>Object.assign(Object.assign({},n),{guardsResult:e})))}))}}(this.ngModule.injector,e=>this.triggerEvent(e)),Yc(e=>{if(Ad(e.guardsResult)){const t=Tp(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`);throw t.url=e.guardsResult,t}}),Yc(e=>{const t=new pp(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot,!!e.guardsResult);this.triggerEvent(t)}),vc(e=>{if(!e.guardsResult){this.resetUrlToCurrentUrlTree();const n=new ip(e.id,this.serializeUrl(e.extractedUrl),"");return t.next(n),e.resolve(!1),!1}return!0}),ph(e=>{if(e.guards.canActivateChecks.length)return cc(e).pipe(Yc(e=>{const t=new dp(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),(t=this.paramsInheritanceStrategy,n=this.ngModule.injector,function(e){return e.pipe(B(e=>{const{targetSnapshot:o,guards:{canActivateChecks:a}}=e;return a.length?U(a).pipe(Jc(e=>function(e,t,n,o){return function(e,t,n,o){const a=Object.keys(e);if(0===a.length)return cc({});if(1===a.length){const r=a[0];return ch(e[r],t,n,o).pipe(j(e=>({[r]:e})))}const r={};return U(a).pipe(B(a=>ch(e[a],t,n,o).pipe(j(e=>(r[a]=e,e))))).pipe(Ec(),j(()=>r))}(e._resolve,e,t,o).pipe(j(t=>(e._resolvedData=t,e.data=Object.assign(Object.assign({},e.data),dd(e,n).resolve),null)))}(e.route,o,t,n)),function(e,t){return arguments.length>=2?function(n){return y($c(e,t),Tc(1),Fc(t))(n)}:function(t){return y($c((t,n,o)=>e(t,n,o+1)),Tc(1))(t)}}((e,t)=>e),j(t=>e)):cc(e)}))}),Yc(e=>{const t=new hp(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}));var t,n}),ph(e=>{const{targetSnapshot:t,id:n,extractedUrl:o,rawUrl:a,extras:{skipLocationChange:r,replaceUrl:s}}=e;return this.hooks.afterPreactivation(t,{navigationId:n,appliedUrlTree:o,rawUrlTree:a,skipLocationChange:!!r,replaceUrl:!!s})}),j(e=>{const t=function(e,t,n){const o=function e(t,n,o){if(o&&t.shouldReuseRoute(n.value,o.value.snapshot)){const a=o.value;a._futureSnapshot=n.value;const r=function(t,n,o){return n.children.map(n=>{for(const a of o.children)if(t.shouldReuseRoute(a.value.snapshot,n.value))return e(t,n,a);return e(t,n)})}(t,n,o);return new id(a,r)}{const o=t.retrieve(n.value);if(o){const e=o.route;return function e(t,n){if(t.value.routeConfig!==n.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(t.children.length!==n.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");n.value._futureSnapshot=t.value;for(let o=0;o<t.children.length;++o)e(t.children[o],n.children[o])}(n,e),e}{const o=new pd(new pc((a=n.value).url),new pc(a.params),new pc(a.queryParams),new pc(a.fragment),new pc(a.data),a.outlet,a.component,a),r=n.children.map(n=>e(t,n));return new id(o,r)}}var a}(e,t._root,n?n._root:void 0);return new ud(o,t)}(this.routeReuseStrategy,e.targetSnapshot,e.currentRouterState);return Object.assign(Object.assign({},e),{targetRouterState:t})}),Yc(e=>{this.currentUrlTree=e.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl),this.routerState=e.targetRouterState,"deferred"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!e.extras.replaceUrl,e.id,e.extras.state),this.browserUrlTree=e.urlAfterRedirects)}),(r=this.rootContexts,s=this.routeReuseStrategy,i=e=>this.triggerEvent(e),j(e=>(new Id(s,e.targetRouterState,e.currentRouterState,i).activate(r),e))),Yc({next(){n=!0},complete(){n=!0}}),(a=()=>{if(!n&&!o){this.resetUrlToCurrentUrlTree();const n=new ip(e.id,this.serializeUrl(e.extractedUrl),`Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`);t.next(n),e.resolve(!1)}this.currentNavigation=null},e=>e.lift(new np(a))),Rc(n=>{if(o=!0,(a=n)&&a.ngNavigationCancelingError){const o=Ad(n.url);o||(this.navigated=!0,this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl));const a=new ip(e.id,this.serializeUrl(e.extractedUrl),n.message);t.next(a),o?setTimeout(()=>{const t=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);return this.scheduleNavigation(t,"imperative",null,{skipLocationChange:e.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:e.resolve,reject:e.reject,promise:e.promise})},0):e.resolve(!1)}else{this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl);const o=new lp(e.id,this.serializeUrl(e.extractedUrl),n);t.next(o);try{e.resolve(this.errorHandler(n))}catch(r){e.reject(r)}}var a;return gc}));var a,r,s,i}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{let t=this.parseUrl(e.url);const n="popstate"===e.type?"popstate":"hashchange",o=e.state&&e.state.navigationId?e.state:null;setTimeout(()=>{this.scheduleNavigation(t,n,o,{replaceUrl:!0})},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){Sp(e),this.config=e.map(Ip),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=null)}createUrlTree(e,t={}){const{relativeTo:n,queryParams:o,fragment:a,preserveQueryParams:r,queryParamsHandling:s,preserveFragment:i}=t;so()&&r&&console&&console.warn&&console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead.");const l=n||this.routerState.root,u=i?this.currentUrlTree.fragment:a;let c=null;if(s)switch(s){case"merge":c=Object.assign(Object.assign({},this.currentUrlTree.queryParams),o);break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=o||null}else c=r?this.currentUrlTree.queryParams:o||null;return null!==c&&(c=this.removeEmptyProps(c)),function(e,t,n,o,a){if(0===n.length)return vd(t.root,t.root,t,o,a);const r=function(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new xd(!0,0,e);let t=0,n=!1;const o=e.reduce((e,o,a)=>{if("object"==typeof o&&null!=o){if(o.outlets){const t={};return Rp(o.outlets,(e,n)=>{t[n]="string"==typeof e?e.split("/"):e}),[...e,{outlets:t}]}if(o.segmentPath)return[...e,o.segmentPath]}return"string"!=typeof o?[...e,o]:0===a?(o.split("/").forEach((o,a)=>{0==a&&"."===o||(0==a&&""===o?n=!0:".."===o?t++:""!=o&&e.push(o))}),e):[...e,o]},[]);return new xd(n,t,o)}(n);if(r.toRoot())return vd(t.root,new Lp([],{}),t,o,a);const s=function(e,t,n){if(e.isAbsolute)return new wd(t.root,!0,0);if(-1===n.snapshot._lastPathIndex)return new wd(n.snapshot._urlSegment,!0,0);const o=bd(e.commands[0])?0:1;return function(e,t,n){let o=e,a=t,r=n;for(;r>a;){if(r-=a,o=o.parent,!o)throw new Error("Invalid number of '../'");a=o.segments.length}return new wd(o,!1,a-r)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+o,e.numberOfDoubleDots)}(r,t,e),i=s.processChildren?kd(s.segmentGroup,s.index,r.commands):Td(s.segmentGroup,s.index,r.commands);return vd(s.segmentGroup,i,t,o,a)}(l,this.currentUrlTree,e,c,u)}navigateByUrl(e,t={skipLocationChange:!1}){so()&&this.isNgZoneEnabled&&!Zi.isInAngularZone()&&this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");const n=Ad(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(n,this.rawUrlTree);return this.scheduleNavigation(o,"imperative",null,t)}navigate(e,t={skipLocationChange:!1}){return function(e){for(let t=0;t<e.length;t++){const n=e[t];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,t),t)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let t;try{t=this.urlSerializer.parse(e)}catch(n){t=this.malformedUriErrorHandler(n,this.urlSerializer,e)}return t}isActive(e,t){if(Ad(e))return jp(this.currentUrlTree,e,t);const n=this.parseUrl(e);return jp(this.currentUrlTree,n,t)}removeEmptyProps(e){return Object.keys(e).reduce((t,n)=>{const o=e[n];return null!=o&&(t[n]=o),t},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.events.next(new sp(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,this.currentNavigation=null,e.resolve(!0)},e=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(e,t,n,o,a){const r=this.getTransition();if(r&&"imperative"!==t&&"imperative"===r.source&&r.rawUrl.toString()===e.toString())return Promise.resolve(!0);if(r&&"hashchange"==t&&"popstate"===r.source&&r.rawUrl.toString()===e.toString())return Promise.resolve(!0);if(r&&"popstate"==t&&"hashchange"===r.source&&r.rawUrl.toString()===e.toString())return Promise.resolve(!0);let s,i,l;a?(s=a.resolve,i=a.reject,l=a.promise):l=new Promise((e,t)=>{s=e,i=t});const u=++this.navigationId;return this.setTransition({id:u,source:t,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:o,resolve:s,reject:i,promise:l,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),l.catch(e=>Promise.reject(e))}setBrowserUrl(e,t,n,o){const a=this.urlSerializer.serialize(e);o=o||{},this.location.isCurrentPathEqualTo(a)||t?this.location.replaceState(a,"",Object.assign(Object.assign({},o),{navigationId:n})):this.location.go(a,"",Object.assign(Object.assign({},o),{navigationId:n}))}resetStateAndUrl(e,t,n){this.routerState=e,this.currentUrlTree=t,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return e.\u0275fac=function(e){Ar()},e.\u0275dir=mt({type:e}),e})();class vh{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new xh,this.attachRef=null}}class xh{constructor(){this.contexts=new Map}onChildOutletCreated(e,t){const n=this.getOrCreateContext(e);n.outlet=t,this.contexts.set(e,n)}onChildOutletDestroyed(e){const t=this.getContext(e);t&&(t.outlet=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let t=this.getContext(e);return t||(t=new vh,this.contexts.set(e,t)),t}getContext(e){return this.contexts.get(e)||null}}let wh=(()=>{class e{constructor(e,t,n,o,a){this.parentContexts=e,this.location=t,this.resolver=n,this.changeDetector=a,this.activated=null,this._activatedRoute=null,this.activateEvents=new di,this.deactivateEvents=new di,this.name=o||"primary",e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,t){this.activated=e,this._activatedRoute=t,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,t){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const n=(t=t||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),o=this.parentContexts.getOrCreateContext(this.name).children,a=new Ch(e,o,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,a),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return e.\u0275fac=function(t){return new(t||e)(Dr(xh),Dr(Bs),Dr(fs),("name",function(e,t){const n=e.attrs;if(n){const e=n.length;let t=0;for(;t<e;){const o=n[t];if(Tn(o))break;if(0===o)t+=2;else if("number"==typeof o)for(t++;t<e&&"string"==typeof n[t];)t++;else{if("name"===o)return n[t+1];t+=2}}}return null}(Gt())),Dr(Ya))},e.\u0275dir=mt({type:e,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),e})();class Ch{constructor(e,t,n){this.route=e,this.childContexts=t,this.parent=n}get(e,t){return e===pd?this.route:e===xh?this.childContexts:this.parent.get(e,t)}}class Th{}class kh{preload(e,t){return cc(null)}}let Ph=(()=>{class e{constructor(e,t,n,o,a){this.router=e,this.injector=o,this.preloadingStrategy=a,this.loader=new mh(t,n,t=>e.triggerEvent(new mp(t)),t=>e.triggerEvent(new fp(t)))}setUpPreloading(){this.subscription=this.router.events.pipe(vc(e=>e instanceof sp),Jc(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(Ze);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription.unsubscribe()}processRoutes(e,t){const n=[];for(const o of t)if(o.loadChildren&&!o.canLoad&&o._loadedConfig){const e=o._loadedConfig;n.push(this.processRoutes(e.module,e.routes))}else o.loadChildren&&!o.canLoad?n.push(this.preloadConfig(e,o)):o.children&&n.push(this.processRoutes(e,o.children));return U(n).pipe(q(),j(e=>{}))}preloadConfig(e,t){return this.preloadingStrategy.preload(t,()=>this.loader.load(e.injector,t).pipe(B(e=>(t._loadedConfig=e,this.processRoutes(e.module,e.routes)))))}}return e.\u0275fac=function(t){return new(t||e)(qe(bh),qe(_l),qe(qi),qe(mr),qe(Th))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),Sh=(()=>{class e{constructor(e,t,n={}){this.router=e,this.viewportScroller=t,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof rp?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof sp&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof vp&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,t){this.router.triggerEvent(new vp(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,t))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return e.\u0275fac=function(e){Ar()},e.\u0275dir=mt({type:e}),e})();const Mh=new Re("ROUTER_CONFIGURATION"),Oh=new Re("ROUTER_FORROOT_GUARD"),Ih=[Bl,{provide:Vp,useClass:Hp},{provide:bh,useFactory:function(e,t,n,o,a,r,s,i={},l,u){const c=new bh(null,e,t,n,o,a,r,Ap(s));if(l&&(c.urlHandlingStrategy=l),u&&(c.routeReuseStrategy=u),i.errorHandler&&(c.errorHandler=i.errorHandler),i.malformedUriErrorHandler&&(c.malformedUriErrorHandler=i.malformedUriErrorHandler),i.enableTracing){const e=Pl();c.events.subscribe(t=>{e.logGroup("Router Event: "+t.constructor.name),e.log(t.toString()),e.log(t),e.logGroupEnd()})}return i.onSameUrlNavigation&&(c.onSameUrlNavigation=i.onSameUrlNavigation),i.paramsInheritanceStrategy&&(c.paramsInheritanceStrategy=i.paramsInheritanceStrategy),i.urlUpdateStrategy&&(c.urlUpdateStrategy=i.urlUpdateStrategy),i.relativeLinkResolution&&(c.relativeLinkResolution=i.relativeLinkResolution),c},deps:[Vp,xh,Bl,mr,_l,qi,hh,Mh,[class{},new oe],[class{},new oe]]},xh,{provide:pd,useFactory:function(e){return e.routerState.root},deps:[bh]},{provide:_l,useClass:vl},Ph,kh,class{preload(e,t){return t().pipe(Rc(()=>cc(null)))}},{provide:Mh,useValue:{enableTracing:!1}}];function Fh(){return new cl("Router",bh)}let Dh=(()=>{class e{constructor(e,t){}static forRoot(t,n){return{ngModule:e,providers:[Ih,Nh(t),{provide:Oh,useFactory:Rh,deps:[[bh,new oe,new re]]},{provide:Mh,useValue:n||{}},{provide:jl,useFactory:Eh,deps:[Ml,[new ne(Ll),new oe],Mh]},{provide:Sh,useFactory:Ah,deps:[bh,Eu,Mh]},{provide:Th,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:kh},{provide:cl,multi:!0,useFactory:Fh},[jh,{provide:Si,multi:!0,useFactory:zh,deps:[jh]},{provide:Xh,useFactory:Lh,deps:[jh]},{provide:Ei,multi:!0,useExisting:Xh}]]}}static forChild(t){return{ngModule:e,providers:[Nh(t)]}}}return e.\u0275mod=dt({type:e}),e.\u0275inj=ue({factory:function(t){return new(t||e)(qe(Oh,8),qe(bh,8))}}),e})();function Ah(e,t,n){return n.scrollOffset&&t.setOffset(n.scrollOffset),new Sh(e,t,n)}function Eh(e,t,n={}){return n.useHash?new Ul(e,t):new Xl(e,t)}function Rh(e){if(e)throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");return"guarded"}function Nh(e){return[{provide:fr,multi:!0,useValue:e},{provide:hh,multi:!0,useValue:e}]}let jh=(()=>{class e{constructor(e){this.injector=e,this.initNavigation=!1,this.resultOfPreactivationDone=new k}appInitializer(){return this.injector.get(Il,Promise.resolve(null)).then(()=>{let e=null;const t=new Promise(t=>e=t),n=this.injector.get(bh),o=this.injector.get(Mh);if(this.isLegacyDisabled(o)||this.isLegacyEnabled(o))e(!0);else if("disabled"===o.initialNavigation)n.setUpLocationChangeListener(),e(!0);else{if("enabled"!==o.initialNavigation)throw new Error(`Invalid initialNavigation options: '${o.initialNavigation}'`);n.hooks.afterPreactivation=()=>this.initNavigation?cc(null):(this.initNavigation=!0,e(!0),this.resultOfPreactivationDone),n.initialNavigation()}return t})}bootstrapListener(e){const t=this.injector.get(Mh),n=this.injector.get(Ph),o=this.injector.get(Sh),a=this.injector.get(bh),r=this.injector.get(fl);e===r.components[0]&&(this.isLegacyEnabled(t)?a.initialNavigation():this.isLegacyDisabled(t)&&a.setUpLocationChangeListener(),n.setUpPreloading(),o.init(),a.resetRootComponentType(r.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}isLegacyEnabled(e){return"legacy_enabled"===e.initialNavigation||!0===e.initialNavigation||void 0===e.initialNavigation}isLegacyDisabled(e){return"legacy_disabled"===e.initialNavigation||!1===e.initialNavigation}}return e.\u0275fac=function(t){return new(t||e)(qe(mr))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();function zh(e){return e.appInitializer.bind(e)}function Lh(e){return e.bootstrapListener.bind(e)}const Xh=new Re("Router Initializer");let Uh=(()=>{class e{}return e.baseURL="http://127.0.0.1:5000",e.newProject=e.baseURL+"/projects/n/",e.getProjects=e.baseURL+"/projects/a/",e.openProject=e.baseURL+"/api/v1/openProject",e.runPipeline=e.baseURL+"/execute/",e.fileUploadURL=e.baseURL+"/upload_files/",e.getProjectFiles=e.baseURL+"/get_project_file_names/",e.getResults=e.baseURL+"/get_results/",e})();class Bh{}class Vh{}class Hh{constructor(e){this.normalizedNames=new Map,this.lazyUpdate=null,e?this.lazyInit="string"==typeof e?()=>{this.headers=new Map,e.split("\n").forEach(e=>{const t=e.indexOf(":");if(t>0){const n=e.slice(0,t),o=n.toLowerCase(),a=e.slice(t+1).trim();this.maybeSetNormalizedName(n,o),this.headers.has(o)?this.headers.get(o).push(a):this.headers.set(o,[a])}})}:()=>{this.headers=new Map,Object.keys(e).forEach(t=>{let n=e[t];const o=t.toLowerCase();"string"==typeof n&&(n=[n]),n.length>0&&(this.headers.set(o,n),this.maybeSetNormalizedName(t,o))})}:this.headers=new Map}has(e){return this.init(),this.headers.has(e.toLowerCase())}get(e){this.init();const t=this.headers.get(e.toLowerCase());return t&&t.length>0?t[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(e){return this.init(),this.headers.get(e.toLowerCase())||null}append(e,t){return this.clone({name:e,value:t,op:"a"})}set(e,t){return this.clone({name:e,value:t,op:"s"})}delete(e,t){return this.clone({name:e,value:t,op:"d"})}maybeSetNormalizedName(e,t){this.normalizedNames.has(t)||this.normalizedNames.set(t,e)}init(){this.lazyInit&&(this.lazyInit instanceof Hh?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(e=>this.applyUpdate(e)),this.lazyUpdate=null))}copyFrom(e){e.init(),Array.from(e.headers.keys()).forEach(t=>{this.headers.set(t,e.headers.get(t)),this.normalizedNames.set(t,e.normalizedNames.get(t))})}clone(e){const t=new Hh;return t.lazyInit=this.lazyInit&&this.lazyInit instanceof Hh?this.lazyInit:this,t.lazyUpdate=(this.lazyUpdate||[]).concat([e]),t}applyUpdate(e){const t=e.name.toLowerCase();switch(e.op){case"a":case"s":let n=e.value;if("string"==typeof n&&(n=[n]),0===n.length)return;this.maybeSetNormalizedName(e.name,t);const o=("a"===e.op?this.headers.get(t):void 0)||[];o.push(...n),this.headers.set(t,o);break;case"d":const a=e.value;if(a){let e=this.headers.get(t);if(!e)return;e=e.filter(e=>-1===a.indexOf(e)),0===e.length?(this.headers.delete(t),this.normalizedNames.delete(t)):this.headers.set(t,e)}else this.headers.delete(t),this.normalizedNames.delete(t)}}forEach(e){this.init(),Array.from(this.normalizedNames.keys()).forEach(t=>e(this.normalizedNames.get(t),this.headers.get(t)))}}class qh{encodeKey(e){return Gh(e)}encodeValue(e){return Gh(e)}decodeKey(e){return decodeURIComponent(e)}decodeValue(e){return decodeURIComponent(e)}}function Gh(e){return encodeURIComponent(e).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/gi,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%2B/gi,"+").replace(/%3D/gi,"=").replace(/%3F/gi,"?").replace(/%2F/gi,"/")}class Wh{constructor(e={}){if(this.updates=null,this.cloneFrom=null,this.encoder=e.encoder||new qh,e.fromString){if(e.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function(e,t){const n=new Map;return e.length>0&&e.split("&").forEach(e=>{const o=e.indexOf("="),[a,r]=-1==o?[t.decodeKey(e),""]:[t.decodeKey(e.slice(0,o)),t.decodeValue(e.slice(o+1))],s=n.get(a)||[];s.push(r),n.set(a,s)}),n}(e.fromString,this.encoder)}else e.fromObject?(this.map=new Map,Object.keys(e.fromObject).forEach(t=>{const n=e.fromObject[t];this.map.set(t,Array.isArray(n)?n:[n])})):this.map=null}has(e){return this.init(),this.map.has(e)}get(e){this.init();const t=this.map.get(e);return t?t[0]:null}getAll(e){return this.init(),this.map.get(e)||null}keys(){return this.init(),Array.from(this.map.keys())}append(e,t){return this.clone({param:e,value:t,op:"a"})}set(e,t){return this.clone({param:e,value:t,op:"s"})}delete(e,t){return this.clone({param:e,value:t,op:"d"})}toString(){return this.init(),this.keys().map(e=>{const t=this.encoder.encodeKey(e);return this.map.get(e).map(e=>t+"="+this.encoder.encodeValue(e)).join("&")}).filter(e=>""!==e).join("&")}clone(e){const t=new Wh({encoder:this.encoder});return t.cloneFrom=this.cloneFrom||this,t.updates=(this.updates||[]).concat([e]),t}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(e=>this.map.set(e,this.cloneFrom.map.get(e))),this.updates.forEach(e=>{switch(e.op){case"a":case"s":const t=("a"===e.op?this.map.get(e.param):void 0)||[];t.push(e.value),this.map.set(e.param,t);break;case"d":if(void 0===e.value){this.map.delete(e.param);break}{let t=this.map.get(e.param)||[];const n=t.indexOf(e.value);-1!==n&&t.splice(n,1),t.length>0?this.map.set(e.param,t):this.map.delete(e.param)}}}),this.cloneFrom=this.updates=null)}}function $h(e){return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer}function Zh(e){return"undefined"!=typeof Blob&&e instanceof Blob}function Kh(e){return"undefined"!=typeof FormData&&e instanceof FormData}class Jh{constructor(e,t,n,o){let a;if(this.url=t,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=e.toUpperCase(),function(e){switch(e){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||o?(this.body=void 0!==n?n:null,a=o):a=n,a&&(this.reportProgress=!!a.reportProgress,this.withCredentials=!!a.withCredentials,a.responseType&&(this.responseType=a.responseType),a.headers&&(this.headers=a.headers),a.params&&(this.params=a.params)),this.headers||(this.headers=new Hh),this.params){const e=this.params.toString();if(0===e.length)this.urlWithParams=t;else{const n=t.indexOf("?");this.urlWithParams=t+(-1===n?"?":n<t.length-1?"&":"")+e}}else this.params=new Wh,this.urlWithParams=t}serializeBody(){return null===this.body?null:$h(this.body)||Zh(this.body)||Kh(this.body)||"string"==typeof this.body?this.body:this.body instanceof Wh?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||Kh(this.body)?null:Zh(this.body)?this.body.type||null:$h(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof Wh?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||Array.isArray(this.body)?"application/json":null}clone(e={}){const t=e.method||this.method,n=e.url||this.url,o=e.responseType||this.responseType,a=void 0!==e.body?e.body:this.body,r=void 0!==e.withCredentials?e.withCredentials:this.withCredentials,s=void 0!==e.reportProgress?e.reportProgress:this.reportProgress;let i=e.headers||this.headers,l=e.params||this.params;return void 0!==e.setHeaders&&(i=Object.keys(e.setHeaders).reduce((t,n)=>t.set(n,e.setHeaders[n]),i)),e.setParams&&(l=Object.keys(e.setParams).reduce((t,n)=>t.set(n,e.setParams[n]),l)),new Jh(t,n,a,{params:l,headers:i,reportProgress:s,responseType:o,withCredentials:r})}}const Qh=function(){var e={Sent:0,UploadProgress:1,ResponseHeader:2,DownloadProgress:3,Response:4,User:5};return e[e.Sent]="Sent",e[e.UploadProgress]="UploadProgress",e[e.ResponseHeader]="ResponseHeader",e[e.DownloadProgress]="DownloadProgress",e[e.Response]="Response",e[e.User]="User",e}();class Yh{constructor(e,t=200,n="OK"){this.headers=e.headers||new Hh,this.status=void 0!==e.status?e.status:t,this.statusText=e.statusText||n,this.url=e.url||null,this.ok=this.status>=200&&this.status<300}}class em extends Yh{constructor(e={}){super(e),this.type=Qh.ResponseHeader}clone(e={}){return new em({headers:e.headers||this.headers,status:void 0!==e.status?e.status:this.status,statusText:e.statusText||this.statusText,url:e.url||this.url||void 0})}}class tm extends Yh{constructor(e={}){super(e),this.type=Qh.Response,this.body=void 0!==e.body?e.body:null}clone(e={}){return new tm({body:void 0!==e.body?e.body:this.body,headers:e.headers||this.headers,status:void 0!==e.status?e.status:this.status,statusText:e.statusText||this.statusText,url:e.url||this.url||void 0})}}class nm extends Yh{constructor(e){super(e,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?"Http failure during parsing for "+(e.url||"(unknown url)"):`Http failure response for ${e.url||"(unknown url)"}: ${e.status} ${e.statusText}`,this.error=e.error||null}}function om(e,t){return{body:t,headers:e.headers,observe:e.observe,params:e.params,reportProgress:e.reportProgress,responseType:e.responseType,withCredentials:e.withCredentials}}let am=(()=>{class e{constructor(e){this.handler=e}request(e,t,n={}){let o;if(e instanceof Jh)o=e;else{let a=void 0;a=n.headers instanceof Hh?n.headers:new Hh(n.headers);let r=void 0;n.params&&(r=n.params instanceof Wh?n.params:new Wh({fromObject:n.params})),o=new Jh(e,t,void 0!==n.body?n.body:null,{headers:a,params:r,reportProgress:n.reportProgress,responseType:n.responseType||"json",withCredentials:n.withCredentials})}const a=cc(o).pipe(Jc(e=>this.handler.handle(e)));if(e instanceof Jh||"events"===n.observe)return a;const r=a.pipe(vc(e=>e instanceof tm));switch(n.observe||"body"){case"body":switch(o.responseType){case"arraybuffer":return r.pipe(j(e=>{if(null!==e.body&&!(e.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return e.body}));case"blob":return r.pipe(j(e=>{if(null!==e.body&&!(e.body instanceof Blob))throw new Error("Response is not a Blob.");return e.body}));case"text":return r.pipe(j(e=>{if(null!==e.body&&"string"!=typeof e.body)throw new Error("Response is not a string.");return e.body}));case"json":default:return r.pipe(j(e=>e.body))}case"response":return r;default:throw new Error(`Unreachable: unhandled observe type ${n.observe}}`)}}delete(e,t={}){return this.request("DELETE",e,t)}get(e,t={}){return this.request("GET",e,t)}head(e,t={}){return this.request("HEAD",e,t)}jsonp(e,t){return this.request("JSONP",e,{params:(new Wh).append(t,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,t={}){return this.request("OPTIONS",e,t)}patch(e,t,n={}){return this.request("PATCH",e,om(n,t))}post(e,t,n={}){return this.request("POST",e,om(n,t))}put(e,t,n={}){return this.request("PUT",e,om(n,t))}}return e.\u0275fac=function(t){return new(t||e)(qe(Bh))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();class rm{constructor(e,t){this.next=e,this.interceptor=t}handle(e){return this.interceptor.intercept(e,this.next)}}const sm=new Re("HTTP_INTERCEPTORS");let im=(()=>{class e{intercept(e,t){return t.handle(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();const lm=/^\)\]\}',?\n/;class um{}let cm=(()=>{class e{constructor(){}build(){return new XMLHttpRequest}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),pm=(()=>{class e{constructor(e){this.xhrFactory=e}handle(e){if("JSONP"===e.method)throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");return new v(t=>{const n=this.xhrFactory.build();if(n.open(e.method,e.urlWithParams),e.withCredentials&&(n.withCredentials=!0),e.headers.forEach((e,t)=>n.setRequestHeader(e,t.join(","))),e.headers.has("Accept")||n.setRequestHeader("Accept","application/json, text/plain, */*"),!e.headers.has("Content-Type")){const t=e.detectContentTypeHeader();null!==t&&n.setRequestHeader("Content-Type",t)}if(e.responseType){const t=e.responseType.toLowerCase();n.responseType="json"!==t?t:"text"}const o=e.serializeBody();let a=null;const r=()=>{if(null!==a)return a;const t=1223===n.status?204:n.status,o=n.statusText||"OK",r=new Hh(n.getAllResponseHeaders()),s=function(e){return"responseURL"in e&&e.responseURL?e.responseURL:/^X-Request-URL:/m.test(e.getAllResponseHeaders())?e.getResponseHeader("X-Request-URL"):null}(n)||e.url;return a=new em({headers:r,status:t,statusText:o,url:s}),a},s=()=>{let{headers:o,status:a,statusText:s,url:i}=r(),l=null;204!==a&&(l=void 0===n.response?n.responseText:n.response),0===a&&(a=l?200:0);let u=a>=200&&a<300;if("json"===e.responseType&&"string"==typeof l){const e=l;l=l.replace(lm,"");try{l=""!==l?JSON.parse(l):null}catch(c){l=e,u&&(u=!1,l={error:c,text:l})}}u?(t.next(new tm({body:l,headers:o,status:a,statusText:s,url:i||void 0})),t.complete()):t.error(new nm({error:l,headers:o,status:a,statusText:s,url:i||void 0}))},i=e=>{const{url:o}=r(),a=new nm({error:e,status:n.status||0,statusText:n.statusText||"Unknown Error",url:o||void 0});t.error(a)};let l=!1;const u=o=>{l||(t.next(r()),l=!0);let a={type:Qh.DownloadProgress,loaded:o.loaded};o.lengthComputable&&(a.total=o.total),"text"===e.responseType&&n.responseText&&(a.partialText=n.responseText),t.next(a)},c=e=>{let n={type:Qh.UploadProgress,loaded:e.loaded};e.lengthComputable&&(n.total=e.total),t.next(n)};return n.addEventListener("load",s),n.addEventListener("error",i),e.reportProgress&&(n.addEventListener("progress",u),null!==o&&n.upload&&n.upload.addEventListener("progress",c)),n.send(o),t.next({type:Qh.Sent}),()=>{n.removeEventListener("error",i),n.removeEventListener("load",s),e.reportProgress&&(n.removeEventListener("progress",u),null!==o&&n.upload&&n.upload.removeEventListener("progress",c)),n.abort()}})}}return e.\u0275fac=function(t){return new(t||e)(qe(um))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})();const dm=new Re("XSRF_COOKIE_NAME"),hm=new Re("XSRF_HEADER_NAME");class mm{}let fm=(()=>{class e{constructor(e,t,n){this.doc=e,this.platform=t,this.cookieName=n,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const e=this.doc.cookie||"";return e!==this.lastCookieString&&(this.parseCount++,this.lastToken=vu(e,this.cookieName),this.lastCookieString=e),this.lastToken}}return e.\u0275fac=function(t){return new(t||e)(qe(Sl),qe(Ai),qe(dm))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),gm=(()=>{class e{constructor(e,t){this.tokenService=e,this.headerName=t}intercept(e,t){const n=e.url.toLowerCase();if("GET"===e.method||"HEAD"===e.method||n.startsWith("http://")||n.startsWith("https://"))return t.handle(e);const o=this.tokenService.getToken();return null===o||e.headers.has(this.headerName)||(e=e.clone({headers:e.headers.set(this.headerName,o)})),t.handle(e)}}return e.\u0275fac=function(t){return new(t||e)(qe(mm),qe(hm))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),_m=(()=>{class e{constructor(e,t){this.backend=e,this.injector=t,this.chain=null}handle(e){if(null===this.chain){const e=this.injector.get(sm,[]);this.chain=e.reduceRight((e,t)=>new rm(e,t),this.backend)}return this.chain.handle(e)}}return e.\u0275fac=function(t){return new(t||e)(qe(Vh),qe(mr))},e.\u0275prov=le({token:e,factory:e.\u0275fac}),e})(),ym=(()=>{class e{static disable(){return{ngModule:e,providers:[{provide:gm,useClass:im}]}}static withOptions(t={}){return{ngModule:e,providers:[t.cookieName?{provide:dm,useValue:t.cookieName}:[],t.headerName?{provide:hm,useValue:t.headerName}:[]]}}}return e.\u0275mod=dt({type:e}),e.\u0275inj=ue({factory:function(t){return new(t||e)},providers:[gm,{provide:sm,useExisting:gm,multi:!0},{provide:mm,useClass:fm},{provide:dm,useValue:"XSRF-TOKEN"},{provide:hm,useValue:"X-XSRF-TOKEN"}]}),e})(),bm=(()=>{class e{}return e.\u0275mod=dt({type:e}),e.\u0275inj=ue({factory:function(t){return new(t||e)},providers:[am,{provide:Bh,useClass:_m},pm,{provide:Vh,useExisting:pm},cm,{provide:um,useExisting:cm}],imports:[[ym.withOptions({cookieName:"XSRF-TOKEN",headerName:"X-XSRF-TOKEN"})]]}),e})(),vm=(()=>{class e{constructor(e){this.http=e}handleError(e="operation",t){return n=>(console.error(n),this.log(`${e} failed: ${n.message}`),cc(t))}log(e){console.log("HeroService: "+e)}getProjects(){return this.http.get(Uh.getProjects).pipe(Rc(this.handleError("getProjects",[])))}getResults(e){return this.http.get(Uh.getResults+e).pipe(Rc(this.handleError("getResults",[])))}createProject(e){return this.http.get(Uh.newProject+e).pipe(Rc(this.handleError("newProject",[])))}runPipeline(e,t){return this.http.post(Uh.runPipeline+e,JSON.stringify({data:t})).pipe(Rc(this.handleError("runPipeline",[])))}postFile(e,t){console.log(e,t);const n=Uh.fileUploadURL+t,o=new FormData;return o.append("file",e,e.name),this.http.post(n,o)}getProjectFiles(e){return this.http.get(Uh.getProjectFiles+e).pipe(Rc(this.handleError("getProjectFiles",[])))}}return e.\u0275fac=function(t){return new(t||e)(qe(am))},e.\u0275prov=le({token:e,factory:e.\u0275fac,providedIn:"root"}),e})(),xm=(()=>{class e{constructor(){this.execChange=new k,this.defaultProjectInfo={project_name:"Default ChemML Project"},this.chemMLJsonChange=new k,this.chemMLJson={nodes:{}},this.execChange.next(this.defaultProjectInfo),this.chemMLJsonChange.next(this.chemMLJson)}updateProjectInfo(e){this.execChange.next(e)}getCurrentProject(){return this.defaultProjectInfo}updateCurrentChemMLJson(e){this.chemMLJsonChange.next(e)}getCurrentChemMLJson(){return this.chemMLJson}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=le({token:e,factory:e.\u0275fac,providedIn:"root"}),e})(),wm=(()=>{class e{constructor(){this.callFunction=new di}ngOnInit(){}onClick(e){this.callFunction.emit(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=lt({type:e,selectors:[["nav-button"]],inputs:{group:"group",type:"type",description:"description",class:"class",data:"data"},outputs:{callFunction:"callFunction"},decls:2,vars:4,consts:[[3,"type","click"]],template:function(e,t){1&e&&(Nr(0,"button",0),Ur("click",(function(e){return t.onClick(e)})),ls(1),jr()),2&e&&(function(e,t,n,o){const a=Ht(),r=en(2);a.firstUpdatePass&&function(e,t,n,o){const a=e.data;if(null===a[n+1]){const o=a[hn()+20],r=ts(e,n);is(o,!0)&&null===t&&!r&&(t=!1),t=function(e,t,n,o){const a=function(e){const t=Ut.lFrame.currentDirectiveIndex;return-1===t?null:e[t]}(e);let r=t.residualClasses;if(null===a)0===t.classBindings&&(n=os(n=ns(null,e,t,n,!0),t.attrs,!0),r=null);else{const o=t.directiveStylingLast;if(-1===o||e[o]!==a)if(n=ns(a,e,t,n,!0),null===r){let n=function(e,t,n){const o=t.classBindings;if(0!==Ro(o))return e[Ao(o)]}(e,t);void 0!==n&&Array.isArray(n)&&(n=ns(null,e,t,n[1],!0),n=os(n,t.attrs,!0),function(e,t,n,o){e[Ao(t.classBindings)]=o}(e,t,0,n))}else r=function(e,t,n){let o=void 0;const a=t.directiveEnd;for(let r=1+t.directiveStylingLast;r<a;r++)o=os(o,e[r].hostAttrs,!0);return os(o,t.attrs,!0)}(e,t)}return void 0!==r&&(t.residualClasses=r),n}(a,o,t),function(e,t,n,o,a,r){let s=t.classBindings,i=Ao(s),l=Ro(s);e[o]=n;let u,c=!1;if(Array.isArray(n)){const e=n;u=e[1],(null===u||nt(e,u)>0)&&(c=!0)}else u=n;if(a)if(0!==l){const t=Ao(e[i+1]);e[o+1]=Do(t,i),0!==t&&(e[t+1]=No(e[t+1],o)),e[i+1]=131071&e[i+1]|o<<17}else e[o+1]=Do(i,0),0!==i&&(e[i+1]=No(e[i+1],o)),i=o;else e[o+1]=Do(l,0),0===i?i=o:e[l+1]=No(e[l+1],o),l=o;c&&(e[o+1]=Eo(e[o+1])),$r(e,u,o,!0),$r(e,u,o,!1),function(e,t,n,o,a){const r=e.residualClasses;null!=r&&"string"==typeof t&&nt(r,t)>=0&&(n[o+1]=jo(n[o+1]))}(t,u,e,o),s=Do(i,l),t.classBindings=s}(a,o,t,n,r)}}(a,null,r);const s=Vt();if(n!==ko&&Sr(s,r,n)){const o=a.data[hn()+20];if(is(o,!0)&&!ts(a,r)){let e=o.classesWithoutHost;null!==e&&(n=be(e,n||"")),Rr(a,o,s,n,!0)}else!function(e,t,n,o,a,r,s,i){a===ko&&(a=Wr);let l=0,u=0,c=0<a.length?a[0]:null,p=0<r.length?r[0]:null;for(;null!==c||null!==p;){const s=l<a.length?a[l+1]:void 0,d=u<r.length?r[u+1]:void 0;let h=null,m=void 0;c===p?(l+=2,u+=2,s!==d&&(h=p,m=d)):null===p||null!==c&&c<p?(l+=2,h=c):(u+=2,h=p,m=d),null!==h&&as(e,t,n,o,h,m,!0,i),c=l<a.length?a[l]:null,p=u<r.length?r[u]:null}}(a,o,s,s[11],s[r+1],s[r+1]=function(e,t,n){if(null==n||""===n)return Wr;const o=[],a=oo(n);if(Array.isArray(a))for(let r=0;r<a.length;r++)e(o,a[r],!0);else if("object"==typeof a)for(const r in a)a.hasOwnProperty(r)&&e(o,r,a[r]);else"string"==typeof a&&t(o,a);return o}(e,t,n),0,r)}}(et,es,t.class),Er("type",t.type),Io(1),cs(" ",t.description,"\n"))},styles:["button{color:#808292;border-radius:29px;border:1px solid #e8e8ef;line-height:39px;background-color:#f1f4fc;padding:0 2%;margin-right:2%;outline:None!important;cursor:pointer}button,button:hover{font-family:Roboto;display:inline-block;font-size:14px;text-align:center}button:hover{background-color:#fbfbfb;-webkit-text-decoration:None;text-decoration:None;outline:None;color:#393c44}"],encapsulation:2}),e})(),Cm=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=lt({type:e,selectors:[["app-global-footer"]],decls:11,vars:0,consts:[[1,"footer"],[1,"left"],["href","/home"],["href","/github-link"],[1,"center"],[1,"right"],["href","email-link"]],template:function(e,t){1&e&&(Nr(0,"div",0),Nr(1,"div",1),Nr(2,"a",2),ls(3," About this project "),jr(),ls(4," \xa0 \xa0 | \xa0 \xa0 "),Nr(5,"a",3),ls(6,"Contribute to the project on Github "),jr(),jr(),zr(7,"div",4),Nr(8,"div",5),Nr(9,"a",6),ls(10,"Report a bug"),jr(),jr(),jr())},styles:[".footer[_ngcontent-%COMP%]{z-index:1000;position:absolute;bottom:0;left:0;width:-webkit-fill-available;padding:1%;background-color:#fff;border-top:1px solid #e2e2e2}.footer[_ngcontent-%COMP%], a[_ngcontent-%COMP%]{font-family:Roboto;color:#8c8c8c}a[_ngcontent-%COMP%], a[_ngcontent-%COMP%]:hover{text-decoration:none}a[_ngcontent-%COMP%]:hover{font-family:Roboto;color:#545454}.left[_ngcontent-%COMP%]{float:left}.left[_ngcontent-%COMP%], .right[_ngcontent-%COMP%]{display:inline-block}.right[_ngcontent-%COMP%]{float:right}"]}),e})(),Tm=(()=>{class e{transform(e){return new Date(e).toDateString()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275pipe=ft({name:"timePipe",type:e,pure:!0}),e})();function km(e,t){if(1&e){const e=Lr();Nr(0,"div",25),Ur("click",(function(){qt(e);const n=t.index,o=t.$implicit;return Hr().selectProject("project_"+n,o)})),Nr(1,"div",26),ls(2),jr(),Nr(3,"div",27),ls(4),li(5,"timePipe"),jr(),Nr(6,"div",28),ls(7,"Bhavin"),jr(),Nr(8,"div",29),zr(9,"img",30),jr(),Nr(10,"div",29),zr(11,"img",31),jr(),Nr(12,"div",29),zr(13,"img",32),jr(),jr()}if(2&e){const e=t.$implicit,n=t.index;Gr("id","project_",n,""),Or("data-index",n),Io(2),us(e.project_name),Io(2),us(ui(5,4,e.created_date.$date))}}let Pm=(()=>{class e{constructor(e,t){this.dataServiceService=e,this.currentProjectService=t,this.closeBoxEmit=new di}goToProjectCanvas(){this.closeBoxEmit.emit()}createProject(e){console.log("Create a new project")}ngOnInit(){this.getProjects()}getProjects(){this.dataServiceService.getProjects().subscribe(e=>{this.projectsList=e.data,this.renderList=this.projectsList,console.log(e)})}selectProject(e,t){let n=document.getElementById(e),o=n.parentElement;for(var a=0;a<o.children.length;a++)if(console.log(o.children[a].classList),o.children[a].classList.contains("selectedProject")){o.children[a].classList.remove("selectedProject"),o.children[a].classList.add("project_list_item");break}this.selectedProject=t,n.classList.remove("project_list_item"),n.classList.add("selectedProject")}searchFilter(e){let t=e.srcElement.value;0!=t.length?(this.renderList=[],this.projectsList.forEach(e=>{e.project_name.includes(t)&&this.renderList.push(e)})):this.renderList=this.projectsList}openProject(){this.currentProjectService.updateProjectInfo(this.selectedProject),this.goToProjectCanvas()}newProject(){}goHome(e){}}return e.\u0275fac=function(t){return new(t||e)(Dr(vm),Dr(xm))},e.\u0275cmp=lt({type:e,selectors:[["app-landing-page"]],outputs:{closeBoxEmit:"closeBoxEmit"},decls:41,vars:1,consts:[[1,"landingPage"],["id","header"],["src","../../assets/University_at_Buffalo_logo.svg.png",1,"ub_logo"],[1,"header-left"],["src","../../assets/nsf_logo.png",1,"nsf_logo"],[1,"made_logo"],["id","navigation"],["id","leftside"],["id","details"],["id","back"],["src","assets/arrow.svg"],["id","names"],["id","title"],["id","subtitle"],["description","Home",1,"button",3,"callFunction"],["description","New Project",1,"button",3,"callFunction"],["description","Open Project",1,"button",3,"callFunction"],["id","buttonsright"],["id","publish",3,"click"],[1,"projects"],[1,"table-container"],[1,"header-container"],[1,"table-item-header"],[1,"table-body"],["class","project_list_item",3,"id","click",4,"ngFor","ngForOf"],[1,"project_list_item",3,"id","click"],[1,"table-item","project_name"],[1,"table-item","created_date"],[1,"table-item","project_author"],[1,"table-item"],["src","../assets/bin.svg",1,"row_icon"],["src","../assets/tab.svg",1,"row_icon"],["src","../assets/copy.svg",1,"row_icon"]],template:function(e,t){1&e&&(Nr(0,"div",0),Nr(1,"div",1),zr(2,"img",2),Nr(3,"div",3),zr(4,"img",4),Nr(5,"p",5),ls(6," MaDE@UB Machine Learning Toolkit "),jr(),jr(),jr(),Nr(7,"div",6),Nr(8,"div",7),Nr(9,"div",8),Nr(10,"div",9),zr(11,"img",10),jr(),Nr(12,"div",11),Nr(13,"p",12),ls(14,"Toolkit Toolbar"),jr(),Nr(15,"p",13),ls(16,"Portal"),jr(),jr(),jr(),jr(),Nr(17,"nav-button",14),Ur("callFunction",(function(e){return t.goHome(e)})),jr(),Nr(18,"nav-button",15),Ur("callFunction",(function(){return t.newProject()})),jr(),Nr(19,"nav-button",16),Ur("callFunction",(function(){return t.openProject()})),jr(),Nr(20,"div",17),Nr(21,"div",18),Ur("click",(function(){return t.openProject()})),ls(22,"Open Selected Project"),jr(),jr(),jr(),Nr(23,"div",19),Nr(24,"div",20),Nr(25,"div",21),Nr(26,"div",22),ls(27,"Project Name"),jr(),Nr(28,"div",22),ls(29,"Created Date"),jr(),Nr(30,"div",22),ls(31,"Author"),jr(),Nr(32,"div",22),ls(33,"Delete"),jr(),Nr(34,"div",22),ls(35,"Open in new tab"),jr(),Nr(36,"div",22),ls(37,"Duplicate Project"),jr(),jr(),Nr(38,"div",23),Fr(39,km,14,6,"div",24),jr(),jr(),jr(),zr(40,"app-global-footer"),jr()),2&e&&(Io(39),Er("ngForOf",t.renderList))},directives:[wm,Cu,Cm],pipes:[Tm],styles:['#header[_ngcontent-%COMP%]{padding:1% 2%!important;background-color:#fff!important;border-bottom:1px solid #e2e2e2!important;z-index:1000!important}.ub_logo[_ngcontent-%COMP%]{width:8%!important}.made_logo[_ngcontent-%COMP%], .ub_logo[_ngcontent-%COMP%]{display:inline-block!important}.made_logo[_ngcontent-%COMP%]{float:right!important;margin:0!important;font-family:Roboto!important;font-weight:800!important;font-size:1.3em!important;color:#393c44!important;width:108%!important;padding-left:5%!important;border-left:2px solid #d4d4d4!important}.nsf_logo[_ngcontent-%COMP%]{width:65px!important;position:absolute!important;top:-12px!important;left:-101px!important;padding-right:10px!important}.header-left[_ngcontent-%COMP%]{display:inline-block;float:right;position:relative}.side[_ngcontent-%COMP%]{width:25%!important;margin-left:10%!important}.select_file_btn[_ngcontent-%COMP%]{display:inline-block;border-radius:5px;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;width:287px;height:38px;line-height:38px;color:#253134;border:1px solid #e8e8ef;transition:all .3s cubic-bezier(.05,.03,.35,1)}.select_file_btn[_ngcontent-%COMP%]:hover{background-color:#217ce8;color:#fff}.items[_ngcontent-%COMP%]{display:inline-block;background-color:#237ce8;color:#fff;border-radius:26px;font-family:Roboto;padding:11px 1%;margin:15px 15px 15px 2%}.visualize[_ngcontent-%COMP%]{height:90%;background-color:#fff;padding:0;border-radius:15px;margin:9% 3% 5%}.axis[_ngcontent-%COMP%]   line[_ngcontent-%COMP%], .axis[_ngcontent-%COMP%]   path[_ngcontent-%COMP%]{fill:none;stroke:#000;shape-rendering:crispEdges}.axis[_ngcontent-%COMP%]   text[_ngcontent-%COMP%]{font-family:sans-serif;font-size:11px}#navigation[_ngcontent-%COMP%]{border-radius:18px;height:71px;background-color:#fff;border-bottom:1px solid #e8e8ef;width:96%;display:table;box-sizing:border-box;position:fixed;top:0;z-index:100;margin:5% 2% 2%}.projects[_ngcontent-%COMP%]{background-color:#fff;box-shadow:0 0 5px 0 #e2e2e2;border-radius:11px;margin-top:6.5%!important;margin-left:2%;margin-right:2%;border-top:13px solid #3186e9;margin-top:3%;padding:5% 1% 2%}table[_ngcontent-%COMP%]{font-family:arial,sans-serif;border-collapse:collapse;width:auto;font-size:1.4em}td[_ngcontent-%COMP%], th[_ngcontent-%COMP%]{border-bottom:1px solid #828282;text-align:left;padding:1%}#back[_ngcontent-%COMP%]{width:40px;height:40px;border-radius:100px;background-color:#f1f4fc;text-align:center;display:inline-block;vertical-align:top;margin-top:15px;margin-right:10px}#back[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:13px}#names[_ngcontent-%COMP%]{display:inline-block;vertical-align:top}#title[_ngcontent-%COMP%]{font-weight:500;font-size:16px;color:#393c44;margin-bottom:0;margin-top:14%}#subtitle[_ngcontent-%COMP%], #title[_ngcontent-%COMP%]{font-family:Roboto}#subtitle[_ngcontent-%COMP%]{color:#808292;font-size:14px;margin-top:0}#leftside[_ngcontent-%COMP%]{margin-right:2%;display:inline-block;vertical-align:middle;margin-left:20px}#centerswitch[_ngcontent-%COMP%]{position:absolute;width:222px;left:50%;margin-left:-111px;top:15px}#leftswitch[_ngcontent-%COMP%]{border:1px solid #e8e8ef;background-color:#fbfbfb;width:111px;border-radius:5px 0 0 5px;color:#393c44}#leftswitch[_ngcontent-%COMP%], #rightswitch[_ngcontent-%COMP%]{height:39px;line-height:39px;font-family:Roboto;display:inline-block;font-size:14px;text-align:center}#rightswitch[_ngcontent-%COMP%]{color:#808292;border-radius:0 5px 5px 0;width:102px;margin-left:-5px}#discard[_ngcontent-%COMP%], #rightswitch[_ngcontent-%COMP%]{border:1px solid #e8e8ef}#discard[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;color:#a6a6b3;width:95px;height:38px;border-radius:5px;text-align:center;line-height:38px;display:inline-block;vertical-align:top;transition:all .2s cubic-bezier(.05,.03,.35,1)}#discard[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7}#publish[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;color:#217ce8;background-color:#fff;width:auto;padding-left:16px;padding-right:16px;height:45px;padding-top:1%;margin-left:18px;display:inline-block;vertical-align:top;text-align:center;line-height:38px;margin-right:20px;transition:all .2s cubic-bezier(.05,.03,.35,1)}#publish[_ngcontent-%COMP%], #publish[_ngcontent-%COMP%]:hover{border-radius:5px;border:2px solid #217ce8}#publish[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7;background-color:#217ce8;color:#fff}#buttonsright[_ngcontent-%COMP%]{float:right;margin-top:15px}#leftcard[_ngcontent-%COMP%]{width:370px;border:1px solid #e8e8ef;padding-top:3%;padding-left:20px;height:auto;position:absolute;z-index:2;vertical-align:middle;margin-top:9%;border-radius:16px;margin-left:2%;box-shadow:2px 2px 25px 2px #e2e2e2;transition:.5s;padding-bottom:5%}#leftcard[_ngcontent-%COMP%], #search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{background-color:#fff;box-sizing:border-box}#search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:318px;height:40px;border:1px solid #e8e8ef;box-shadow:0 2px 8px rgba(34,34,87,.05);border-radius:5px;text-indent:35px;font-family:Roboto;font-size:16px}[_ngcontent-%COMP%]::-moz-placeholder{color:#c9c9d5}[_ngcontent-%COMP%]::-ms-input-placeholder{color:#c9c9d5}[_ngcontent-%COMP%]::placeholder{color:#c9c9d5}#search[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;margin-top:10px;width:18px;margin-left:12px}#subnav[_ngcontent-%COMP%]{border-bottom:1px solid #e8e8ef;width:calc(100% + 20px);margin-left:-20px;margin-top:10px;overflow:scroll;display:flex;border-top:1px solid #e8e8ef}.navdisabled[_ngcontent-%COMP%]{transition:all .3s cubic-bezier(.05,.03,.35,1)}.navdisabled[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.5}.navactive[_ngcontent-%COMP%]{color:#393c44!important}#triggers[_ngcontent-%COMP%]{margin-left:20px;font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#808292;width:29.33333%;height:48px;line-height:48px;display:inline-block;float:left}.navactive[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}#actions[_ngcontent-%COMP%]{float:left}#actions[_ngcontent-%COMP%], #loggers[_ngcontent-%COMP%]{display:inline-block;font-weight:500;color:#808292;height:48px;line-height:48px;width:29.33333%;text-align:center}#actions[_ngcontent-%COMP%], #footer[_ngcontent-%COMP%], #loggers[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px}#footer[_ngcontent-%COMP%]{position:absolute;left:0;padding-left:20px;line-height:40px;bottom:0;width:362px;border:1px solid #e8e8ef;height:67px;box-sizing:border-box;background-color:#fff}#footer[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none;color:#393c44;transition:all .2s cubic-bezier(.05,.03,.35,1)}#footer[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{opacity:.5}#footer[_ngcontent-%COMP%]   p[_ngcontent-%COMP%], #footer[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#808292}#footer[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{display:inline-block}#footer[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-left:5px;margin-right:5px}.blockelem[_ngcontent-%COMP%]:first-child{margin-top:20px}.block[_ngcontent-%COMP%], .blockintree[_ngcontent-%COMP%]{padding-top:10px;width:350px;border:1px solid transparent;transition-property:box-shadow,height;transition-duration:.2s;transition-timing-function:cubic-bezier(.05,.03,.35,1);border-radius:5px;box-shadow:11px 11px 30px #e2e2e2;box-sizing:border-box}.blockintree[_ngcontent-%COMP%]{background-color:#fff}.blockelem[_ngcontent-%COMP%]{padding-top:10px;width:350px;border:1px solid transparent;transition-property:box-shadow,height;transition-duration:.2s;transition-timing-function:cubic-bezier(.05,.03,.35,1);border-radius:5px;box-shadow:0 0 30px rgba(22,33,74,0);box-sizing:border-box}.blockelem[_ngcontent-%COMP%]:hover{box-shadow:0 4px 30px rgba(22,33,74,.08);border-radius:5px;background-color:#fff;cursor:pointer}.blockico[_ngcontent-%COMP%], .grabme[_ngcontent-%COMP%]{display:inline-block}.grabme[_ngcontent-%COMP%]{margin-top:10px;margin-left:10px;margin-bottom:-14px;width:15px}.np-box-container[_ngcontent-%COMP%]{position:absolute;left:42%;top:40%;background-color:#fff;padding:2%;border-radius:11px;box-shadow:2px 2px 25px 2px #292929;z-index:1000;border-top:19px solid #227ce8}.title[_ngcontent-%COMP%]{font-family:Roboto;font-weight:800;font-size:19px;margin-bottom:8%;color:#393c44}.overlay[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;background-color:rgba(0,0,0,.72);z-index:999}.input_text[_ngcontent-%COMP%]{width:318px;height:40px;border:1px solid #e8e8ef;box-sizing:border-box;box-shadow:0 2px 8px rgba(34,34,87,.05);border-radius:5px;text-indent:35px;font-size:20px;width:100%;color:#393c44;padding:8% 3%}.input_text[_ngcontent-%COMP%], .submit-btn[_ngcontent-%COMP%]{background-color:#fff;font-family:Roboto}.submit-btn[_ngcontent-%COMP%]{color:#217ce8;border-radius:5px;border:2px solid #217ce8;margin-top:2%;float:right}.close-btn[_ngcontent-%COMP%], .submit-btn[_ngcontent-%COMP%]{font-weight:800;font-size:14px;padding:1% 5%;display:inline-block;vertical-align:top;text-align:center;line-height:38px;transition:all .2s cubic-bezier(.05,.03,.35,1);cursor:pointer}.close-btn[_ngcontent-%COMP%]{font-family:Roboto;color:#9c9c9c;background-color:#fff;border-radius:5px;border:2px solid #9c9c9c;margin-top:8%;float:left}.options[_ngcontent-%COMP%]{margin-top:9%;margin-left:2%}.close-btn[_ngcontent-%COMP%]:hover{color:#fff;background-color:#9c9c9c}.table-item[_ngcontent-%COMP%], .table-item-header[_ngcontent-%COMP%]{display:inline-block;float:left;font-size:16px;width:13em;font-family:Roboto;color:#393c44}.table-item-header[_ngcontent-%COMP%]{font-weight:700}#blocklist[_ngcontent-%COMP%]{height:calc(100% - 220px);overflow:auto}#proplist[_ngcontent-%COMP%]{height:calc(100% - 305px);overflow:auto;margin-top:-30px;padding-top:13px}.blockin[_ngcontent-%COMP%]{display:inline-block;vertical-align:top;margin-left:12px}.blockico[_ngcontent-%COMP%]{width:36px;height:36px;background-color:#f1f4fc;border-radius:5px;text-align:center;white-space:nowrap}.blockico[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{height:100%;width:0}.blockico[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .blockico[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.blockico[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-left:auto;margin-right:auto;width:52%}.blocktext[_ngcontent-%COMP%]{display:inline-block;width:220px;vertical-align:top;margin-left:12px}.blocktitle[_ngcontent-%COMP%]{margin:0!important;padding:0!important;font-family:Roboto;font-weight:500;font-size:16px;color:#393c44}.blockdesc[_ngcontent-%COMP%]{margin-top:5px;font-family:Roboto;color:#808292;font-size:14px;line-height:21px}.blockdisabled[_ngcontent-%COMP%]{background-color:#f0f2f9;opacity:.5}.project_name_input[_ngcontent-%COMP%]{padding:1%;font-size:1.3em;border:1px solid #e2e2e2;display:inline-block}.project_list_item[_ngcontent-%COMP%]{cursor:pointer;height:9%!important;display:flex;border-top:2px solid #e6e6e6;padding:20px}.header-container[_ngcontent-%COMP%]{position:fixed;height:6%;background-color:#f1f4fc;border-radius:12px;margin-bottom:0;width:92%;margin-top:-4%;padding:.9% 1% 1%}#closecard[_ngcontent-%COMP%]{position:absolute;margin-left:348px;background-color:#fff;border-radius:0 5px 5px 0;border-bottom:1px solid #e8e8ef;border-right:1px solid #e8e8ef;border-top:1px solid #e8e8ef;width:53px;height:53px;text-align:center;z-index:10}#closecard[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:15px}#canvas[_ngcontent-%COMP%]{position:absolute;width:calc(100% - 361px);height:calc(100% - 71px);top:71px;left:361px;z-index:0;overflow:auto}#search[_ngcontent-%COMP%]{margin-bottom:7%!important}#propwrap[_ngcontent-%COMP%]{right:0;width:40%;overflow:hidden;z-index:-2}#properties[_ngcontent-%COMP%], #propwrap[_ngcontent-%COMP%]{position:absolute;top:0;height:100%;padding-left:20px}#properties[_ngcontent-%COMP%]{width:70%;background-color:#fff;right:-150px;opacity:0;z-index:2;box-shadow:-4px 0 40px rgba(26,26,73,0);transition:all .25s cubic-bezier(.05,.03,.35,1)}.itson[_ngcontent-%COMP%]{z-index:2!important}.expanded[_ngcontent-%COMP%]{right:0!important;opacity:1!important;box-shadow:-4px 0 40px rgba(26,26,73,.05);z-index:2}#header2[_ngcontent-%COMP%]{font-size:20px;font-family:Roboto;font-weight:700;color:#393c44;margin-top:101px}#close[_ngcontent-%COMP%]{margin-top:100px;position:absolute;right:20px;z-index:9999;transition:all .25s cubic-bezier(.05,.03,.35,1)}#close[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7}#propswitch[_ngcontent-%COMP%]{border-bottom:1px solid #e8e8ef;width:100%;margin-top:10px;margin-left:-20px;margin-bottom:30px}#dataprop[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#393c44;width:29.33333%;height:48px;line-height:48px;display:inline-block;float:left;margin-left:20px}#dataprop[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}#alertprop[_ngcontent-%COMP%]{float:left}#alertprop[_ngcontent-%COMP%], #logsprop[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto;font-weight:500;color:#808292;font-size:14px;height:48px;line-height:48px;width:29.33333%;text-align:center}.dropme[_ngcontent-%COMP%], .inputlabel[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;color:#253134}.dropme[_ngcontent-%COMP%]{background-color:#fff;border-radius:5px;border:1px solid #e8e8ef;box-shadow:0 2px 8px rgba(34,34,87,.05);text-indent:20px;height:40px;line-height:40px;width:287px;margin-bottom:25px}.dropme[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:17px;float:right;margin-right:15px}.checkus[_ngcontent-%COMP%]{margin-bottom:10px}.checkus[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;margin-left:10px}#divisionthing[_ngcontent-%COMP%]{height:1px;width:100%;background-color:#e8e8ef;position:absolute;right:0;bottom:80}#removeblock[_ngcontent-%COMP%]{width:287px;color:#253134}#removeblock[_ngcontent-%COMP%], #visualize_btn[_ngcontent-%COMP%]{border-radius:5px;position:absolute;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;height:38px;line-height:38px;border:1px solid #e8e8ef;transition:all .3s cubic-bezier(.05,.03,.35,1)}#visualize_btn[_ngcontent-%COMP%]{width:23%;color:#fff;right:21px;background-color:#247ce8}#table_preview[_ngcontent-%COMP%]{font-family:Trebuchet MS,Arial,Helvetica,sans-serif;border-collapse:collapse;width:81%;margin-left:2%}#customers[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], #table_preview[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{border:1px solid #ddd;padding:8px}#table_preview[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:nth-child(2n){background-color:#f2f2f2}#table_preview[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover{background-color:#ddd}#table_preview[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{padding-top:12px;padding-bottom:12px;text-align:left;background-color:#247ce8;color:#fff;text-align:center}#visualize_btn[_ngcontent-%COMP%]:hover{border-radius:5px;position:absolute;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;width:23%;height:38px;line-height:38px;color:#247ce8;right:21px;border:1px solid #e8e8ef;background-color:#fff;transition:all .3s cubic-bezier(.05,.03,.35,1)}#filename[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto;margin-left:2%;font-weight:800}#removeblock[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.5}.noselect[_ngcontent-%COMP%]{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.blockyname[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;color:#253134;margin-left:8px;font-size:16px}.blockyleft[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .blockyname[_ngcontent-%COMP%], .blockyright[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.blockyright[_ngcontent-%COMP%]{float:right;margin-right:20px;margin-top:10px;width:28px;height:28px;border-radius:5px;text-align:center;background-color:#fff;transition:all .3s cubic-bezier(.05,.03,.35,1);z-index:10}.blockyright[_ngcontent-%COMP%]:hover{background-color:#f1f4fc;cursor:pointer}.blockyright[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:12px}.blockyleft[_ngcontent-%COMP%]{display:inline-block;margin-left:20px}.blockydiv[_ngcontent-%COMP%]{width:100%;height:1px;background-color:#e9e9ef}.blockyinfo[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;color:#808292;margin-top:15px;text-indent:20px;margin-bottom:20px}.blockyinfo[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#253134;font-weight:500;display:inline-block;border-bottom:1px solid #d3dcea;line-height:20px;text-indent:0}.selectedProject[_ngcontent-%COMP%]{color:#fff;cursor:pointer;height:9%!important;display:flex;border-left:6px solid #217ce8;background-color:#f7f5f5;padding:20px 20px 20px 14px;border-top:2px solid #e6e6e6;border-right:6px solid #217ce8}.newProjectButton[_ngcontent-%COMP%]{display:inline-block;margin-right:4%;font-family:Roboto;font-weight:800;font-size:18px!important;color:#217ce8;background-color:#fff;border:2px solid #217ce8;font-size:14px;padding:.7% 2%;vertical-align:top;text-align:center;line-height:38px;transition:all .2s cubic-bezier(.05,.03,.35,1);cursor:pointer}.row_icon[_ngcontent-%COMP%]{width:10%}.submit-btn[_ngcontent-%COMP%]:hover{color:#fff;background-color:#217ce8}.table-container[_ngcontent-%COMP%]{height:500px!important;overflow-y:scroll}.block[_ngcontent-%COMP%]{width:40%!important;background-color:#fff;margin-top:0!important;box-shadow:0 4px 30px rgba(22,33,74,.05)}.selectedblock[_ngcontent-%COMP%]{border:2px solid #217ce8;box-shadow:0 4px 30px rgba(22,33,74,.08)}.custom-select[_ngcontent-%COMP%]{position:relative;font-family:Arial}.custom-select[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]{display:none}.select-selected[_ngcontent-%COMP%]{background-color:#1e90ff}.select-selected[_ngcontent-%COMP%]:after{position:absolute;content:"";top:14px;right:10px;width:0;height:0;border:6px solid transparent;border-top-color:#fff}.select-selected.select-arrow-active[_ngcontent-%COMP%]:after{border-color:transparent transparent #fff;top:7px}.select-items[_ngcontent-%COMP%]   div[_ngcontent-%COMP%], .select-selected[_ngcontent-%COMP%]{color:#fff;padding:8px 16px;border:1px solid transparent;border-bottom-color:rgba(0,0,0,.1);cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.select-items[_ngcontent-%COMP%]{position:absolute;background-color:#1e90ff;top:100%;left:0;right:0;z-index:99}.select-hide[_ngcontent-%COMP%]{display:none}.same-as-selected[_ngcontent-%COMP%], .select-items[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.1)}@media only screen and (max-width:832px){#centerswitch[_ngcontent-%COMP%]{display:none}}@media only screen and (max-width:560px){#names[_ngcontent-%COMP%]{display:none}}']}),e})();const Sm=[{path:"",component:(()=>{class e{constructor(e){this.router=e}ngOnInit(){}sendToPortal(){this.router.navigate(["/portal"])}}return e.\u0275fac=function(t){return new(t||e)(Dr(bh))},e.\u0275cmp=lt({type:e,selectors:[["app-home-page"]],decls:34,vars:0,consts:[[1,"main-container"],["id","header"],["src","../../assets/University_at_Buffalo_logo.svg.png",1,"ub_logo"],[1,"header-left"],["src","../../assets/nsf_logo.png",1,"nsf_logo"],[1,"made_logo"],[1,"quick-intro"],[1,"left-image"],["src","../../assets/mlflow.PNG",1,"ml-image"],[1,"right-text"],[1,"text-title"],[1,"text-subtitle"],[1,"text-info"],[1,"links"],[1,"link-block","about"],[1,"link-block-text"],[1,"link-block-subtext"],[1,"link-block","faq-help"],[1,"link-block","portal",3,"click"]],template:function(e,t){1&e&&(Nr(0,"div",0),Nr(1,"div",1),zr(2,"img",2),Nr(3,"div",3),zr(4,"img",4),Nr(5,"p",5),ls(6," MaDE@UB Machine Learning Toolkit "),jr(),jr(),jr(),Nr(7,"div",6),Nr(8,"div",7),zr(9,"img",8),jr(),Nr(10,"div",9),Nr(11,"div",10),ls(12," Machine Learning Toolkit "),jr(),Nr(13,"div",11),ls(14," Materials Data Engineering @ UB "),jr(),Nr(15,"div",12),ls(16," An easy-to-use GUI has been developed to reduce the time it takes to build prototypes for ML models as well as experiment with various feature extraction methods available. Further, plug-and-play-style interactions for the different blocks associated with a typical ML pipeline via a graphical representation with directed edges make the GUI intuitive to use and easy to learn. "),jr(),jr(),jr(),Nr(17,"div",13),Nr(18,"div",14),Nr(19,"div",15),ls(20," About "),jr(),Nr(21,"div",16),ls(22," About Made at Machine Learning Toolkit "),jr(),jr(),Nr(23,"div",17),Nr(24,"div",15),ls(25," FAQ/Help "),jr(),Nr(26,"div",16),ls(27," Get quick help regarding most frequent asked questions about toolkit. "),jr(),jr(),Nr(28,"div",18),Ur("click",(function(){return t.sendToPortal()})),Nr(29,"div",15),ls(30," Get Started "),jr(),Nr(31,"div",16),ls(32," Go ML Toolkit Portal "),jr(),jr(),jr(),zr(33,"app-global-footer"),jr())},directives:[Cm],styles:[".links[_ngcontent-%COMP%]{clear:both}.portal[_ngcontent-%COMP%]{display:inline-block;width:29.33333%;margin:2%;font-family:Roboto;height:200px;background-color:#fff;border:5px solid #217ce8!important;text-align:-webkit-center;padding:4% 1% 8%;color:#000}.link-block-text[_ngcontent-%COMP%]{font-size:1.4em;font-weight:800;text-align:center;background-color:#217ce8;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;text-align:-webkit-center;border-radius:32px;padding:1% 5%;margin-bottom:3%;color:#fff}.link-block[_ngcontent-%COMP%]{display:inline-block;width:28.33333%;margin:0 2% 2% 50px;font-family:Roboto;height:200px;background-color:#fff;border:1px solid #e2e2e2;text-align:-webkit-center;padding:4% 1% 8%;box-shadow:1px 3px 20px -4px #e2e2e2;cursor:pointer}.left-image[_ngcontent-%COMP%]{display:inline-block;float:left}.ml-image[_ngcontent-%COMP%]{width:80%;margin-left:10%}.right-text[_ngcontent-%COMP%]{display:inline-block;float:right;width:49%;padding:2%;margin:3%}.text-title[_ngcontent-%COMP%]{font-size:3em;font-family:Roboto;font-weight:500}.text-subtitle[_ngcontent-%COMP%]{font-size:1.5em;font-family:Roboto;font-weight:200}.text-info[_ngcontent-%COMP%]{font-family:Roboto;font-size:1.2em;margin-top:5%;padding-right:7%;text-align:justify}#header[_ngcontent-%COMP%]{padding:1% 2%!important;background-color:#fff!important;border-bottom:1px solid #e2e2e2!important;z-index:1000!important}.ub_logo[_ngcontent-%COMP%]{width:8%!important}.made_logo[_ngcontent-%COMP%], .ub_logo[_ngcontent-%COMP%]{display:inline-block!important}.made_logo[_ngcontent-%COMP%]{float:right!important;margin:0!important;font-family:Roboto!important;font-weight:800!important;font-size:1.3em!important;color:#393c44!important;width:108%!important;padding-left:5%!important;border-left:2px solid #d4d4d4!important}.nsf_logo[_ngcontent-%COMP%]{width:65px!important;position:absolute!important;top:-12px!important;left:-101px!important;padding-right:10px!important}.header-left[_ngcontent-%COMP%]{display:inline-block;float:right;position:relative}"]}),e})()},{path:"portal",component:Pm}];let Mm=(()=>{class e{}return e.\u0275mod=dt({type:e}),e.\u0275inj=ue({factory:function(t){return new(t||e)},imports:[[Dh.forRoot(Sm)],Dh]}),e})();var Om={name:"pandas",docstring:"",inputs:[],outputs:[],node_functions:[{name:"read_csv",docstring:"\nRead a comma-separated values (csv) file into DataFrame.",inputs:[{name:"filepath_or_buffer",docstring:"Choose a CSV file to upload.",param_type:["object","str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"sep",docstring:"Delimiter to use. Use \\s+ for whitespace",param_type:["str"],expected_shape:null,is_optional:!0,default_value:",",options:null},{name:"header",docstring:"Row number(s) to use as the column names, and the start of the data.  Default behavior is to infer the column names: if no names are passed the behavior is identical to ``header=0`` and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to ``header=None``. Explicitly pass ``header=0`` to be able to replace existing names. The header can be a list of integers that specify row locations for a multi-index on the columns e.g. [0,1,3]. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if ``skip_blank_lines=True``, so ``header=0`` denotes the first line of data rather than the first line of the file.",param_type:["int","list"],expected_shape:null,is_optional:!0,default_value:"infer",options:null},{name:"names",docstring:"List of column names to use. If file contains no header row, then you should explicitly pass ``header=None``. Duplicates in this list are not allowed.",param_type:["array"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"index_col",docstring:"Column(s) to use as the row labels of the ``DataFrame``, either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used.  Note: ``index_col=False`` can be used to force pandas to *not* use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line.",param_type:["int","str",null],expected_shape:null,is_optional:!0,default_value:"``None``",options:null},{name:"usecols",docstring:"Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in `names` or inferred from the document header row(s). For example, a valid list-like `usecols` parameter would be ``[0, 1, 2]`` or ``['foo', 'bar', 'baz']``. Element order is ignored, so ``usecols=[0, 1]`` is the same as ``[1, 0]``.",param_type:["list","callable"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"mangle_dupe_cols",docstring:"Duplicate columns will be specified as 'X', 'X.1', ...'X.N', rather than 'X'...'X'. Passing in False will cause data to be overwritten if there are duplicate names in the columns.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"skiprows",docstring:"Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file. By default no rows are skipped",param_type:["int","list","callable"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"skipfooter",docstring:"Number of lines at bottom of file to skip (Unsupported with engine='c').",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"0",options:null},{name:"nrows",docstring:"Number of rows of file to read. Useful for reading pieces of large files.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"na_values",docstring:"Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values.  By default the following values are interpreted as NaN: '', '#N/A', '#N/A N/A', '#NA', '-1.#IND', '-1.#QNAN', '-NaN', '-nan', '1.#IND', '1.#QNAN', 'N/A', 'NA', 'NULL', 'NaN', 'n/a', 'nan', 'null'.",param_type:["str","dict","list"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"keep_default_na",docstring:"Whether or not to include the default NaN values when parsing the data. Depending on whether `na_values` is passed in, the behavior is as follows:  * If `keep_default_na` is True, and `na_values` are specified, `na_values`   is appended to the default NaN values used for parsing. * If `keep_default_na` is True, and `na_values` are not specified, only   the default NaN values are used for parsing. * If `keep_default_na` is False, and `na_values` are specified, only   the NaN values specified `na_values` are used for parsing. * If `keep_default_na` is False, and `na_values` are not specified, no   strings will be parsed as NaN.  Note that if `na_filter` is passed in as False, the `keep_default_na` and `na_values` parameters will be ignored.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"na_filter",docstring:"Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing na_filter=False can improve the performance of reading a large file.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"skip_blank_lines",docstring:"If True, skip over blank lines rather than interpreting as NaN values.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"compression",docstring:"For on-the-fly decompression of on-disk data. If 'infer' and `filepath_or_buffer` is path-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise no decompression). If using 'zip', the ZIP file must contain only one data file to be read in. Set to None for no decompression.  .. versionadded:: 0.18.1 support for 'zip' and 'xz' compression.",param_type:["LIST_VALID_OPTIONS",null],expected_shape:null,is_optional:!0,default_value:"infer",options:["infer","gzip","bz2","zip","xz","None"]},{name:"thousands",docstring:"Thousands separator.",param_type:["str"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"decimal",docstring:"Character to recognize as decimal point (e.g. use ',' for European data).",param_type:["str"],expected_shape:null,is_optional:!0,default_value:".",options:null},{name:"comment",docstring:"Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as ``skip_blank_lines=True``), fully commented lines are ignored by the parameter `header` but not by `skiprows`. For example, if ``comment='#'``, parsing ``#empty\\na,b,c\\n1,2,3`` with ``header=0`` will result in 'a,b,c' being treated as the header.",param_type:["str"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"data",docstring:"A comma-separated values (csv) file is returned as two-dimensional data structure with labeled axes.",param_type:["dataframe"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[],library:"pandas",module:null},Im={name:"chemml.datasets",docstring:"",inputs:[],outputs:[],node_functions:[{name:"load_cep_homo",docstring:"Load and return a small sample of HOMO energies of organic photovoltaic candidates from CEP database (regression).\n    Clean Energy Project (CEP) database is available at: https://cepdb.molecularspace.org\n    The unit of HOMO (highest occupied molecular orbitals) energies is electron Volt (eV).\n    The photovaltaic candidates are provided using SMILES representation.\n\n    =================   ==============\n    rows                           500\n    Columns                          2\n    headers             smiles,homo_eV\n    molecules rep.              SMILES\n    Features                         0\n    Returns               2 dataframes\n    =================   ==============\n\n    Returns\n    -------\n    smiles: pandas dataframe\n        The SMILES representation of molecules, shape: (500,1)\n\n    homo: pandas dataframe\n        The HOMO energies of the molecules (eV), shape: (500,1)\n\n    Examples\n    --------\n    >>> from chemml.datasets import load_cep_homo\n    >>> smi, homo  = load_cep_homo()\n    >>> print(list(smi.columns))\n    ['smiles']\n    >>> print(homo.shape)\n    (500, 1)\n    ",inputs:[],outputs:[{name:"smiles",docstring:"The SMILES representation of molecules, shape: (500,1)",param_type:["dataframe"],returned:!0},{name:"homo",docstring:"The HOMO energies of the molecules (eV), shape: (500,1)",param_type:["dataframe"],returned:!0}]},{name:"load_comp_energy",docstring:"Load and return composition entries and formation energies (eV).\n    From Magpie https://bitbucket.org/wolverton/magpie\n\n    =================   ======================\n    rows                                   630\n    header                    formation_energy\n    molecules rep.                 composition\n    Features                                 0\n    Returns             1 dataframe and 1 list\n    =================   ======================\n\n    Returns\n    -------\n    entries: list\n        The list of composition entries from CompositionEntry class.\n\n    energy: pandas dataframe\n        The formation energy for each composition.\n\n    Examples\n    --------\n    >>> from chemml.datasets import load_comp_energy\n    >>> entries, df = load_comp_energy()\n    >>> print(df.shape)\n    (630, 1)\n    ",inputs:[],outputs:[{name:"entries",docstring:"The list of composition entries from CompositionEntry class.",param_type:["list"],returned:!0},{name:"energy",docstring:"The formation energy for each composition.",param_type:["dataframe"],returned:!0}]},{name:"load_crystal_structures",docstring:"Load and return crystal structure entries.\n    From Magpie https://bitbucket.org/wolverton/magpie\n\n    =================   ======================\n    length                                  18\n    header                    formation_energy\n    molecules rep.                 composition\n    Features                                 0\n    Returns                             1 list\n    =================   ======================\n\n    Returns\n    -------\n    entries: list\n        The list of crystal structure entries from CrystalStructureEntry class.\n\n    Examples\n    --------\n    >>> from chemml.datasets import load_crystal_structures\n    >>> entries = load_crystal_structures()\n    >>> print(len(entries))\n    18\n    ",inputs:[],outputs:[{name:"entries",docstring:"The list of crystal structure entries from CrystalStructureEntry class.",param_type:["list"],returned:!0}]},{name:"load_organic_density",docstring:"Load and return 500 small organic molecules with their density and molecular descriptors.\n\n    =================   ======================\n    rows                                   500\n    Columns                                202\n    last twoo headers     smiles,density_Kg/m3\n    molecules rep.                      SMILES\n    Features                               200\n    Returns                       3 dataframes\n    =================   ======================\n\n    Returns\n    -------\n    smiles: pandas dataframe\n        The SMILES representation of molecules, shape: (500,1)\n\n    density: pandas dataframe\n        The density of molecules (Kg/m3), shape: (500,1)\n\n    features: pandas dataframe\n        The molecular descriptors of molecules, shape: (500,200)\n\n    Examples\n    --------\n    >>> from chemml.datasets import load_organic_density\n    >>> smi, density, features = load_organic_density()\n    >>> print(list(smi.columns))\n    ['smiles']\n    >>> print(features.shape)\n    (500, 200)\n    ",inputs:[],outputs:[{name:"smiles",docstring:"The SMILES representation of molecules, shape: (500,1)",param_type:["dataframe"],returned:!0},{name:"density",docstring:"The density of molecules (Kg/m3), shape: (500,1)",param_type:["dataframe"],returned:!0},{name:"features",docstring:"The molecular descriptors of molecules, shape: (500,200)",param_type:["dataframe"],returned:!0}]},{name:"load_xyz_polarizability",docstring:"Load and return xyz files and polarizability (Bohr^3).\n    The xyz coordinates of small organic molecules are optimized with BP86/def2svp level of theory.\n    Polarizability of the molecules are also calcualted in the same level of thoery.\n\n    =================   ======================\n    rows                                    50\n    Columns                                  1\n    header                      polarizability\n    molecules rep.                         xyz\n    Features                                 0\n    Returns             1 dataframe and 1 dict\n    =================   ======================\n\n    Returns\n    -------\n    molecules: list\n        The list of molecule objects with xyz coordinates.\n\n    pol: pandas dataframe\n        The polarizability of each molecule as a column of dataframe.\n\n    Examples\n    --------\n    >>> from chemml.datasets import load_xyz_polarizability\n    >>> molecules, polarizabilities = load_xyz_polarizability()\n    >>> print(len(molecules))\n    50\n    >>> print(polarizabilities.shape)\n    (50, 1)\n    ",inputs:[],outputs:[{name:"molecules",docstring:"The list of molecule objects with xyz coordinates.",param_type:["list"],returned:!0},{name:"pol",docstring:"The polarizability of each molecule as a column of dataframe.",param_type:["dataframe"],returned:!0}]}],nodes:[],library:"chemml",module:"datasets"},Fm={name:"sklearn.svm",docstring:"",inputs:[],outputs:[],node_functions:[{name:"l1_min_c",docstring:"\n    Return the lowest bound for C such that for C in (l1_min_C, infinity)\n    the model is guaranteed not to be empty. This applies to l1 penalized\n    classifiers, such as LinearSVC with penalty='l1' and\n    linear_model.LogisticRegression with penalty='l1'.\n\n    This value is valid if class_weight parameter in fit() is not set.\n\n    Parameters\n    ----------\n    X : array-like or sparse matrix, shape = [n_samples, n_features]\n        Training vector, where n_samples in the number of samples and\n        n_features is the number of features.\n\n    y : array, shape = [n_samples]\n        Target vector relative to X\n\n    loss : {'squared_hinge', 'log'}, default 'squared_hinge'\n        Specifies the loss function.\n        With 'squared_hinge' it is the squared hinge loss (a.k.a. L2 loss).\n        With 'log' it is the loss of logistic regression models.\n\n    fit_intercept : bool, default: True\n        Specifies if the intercept should be fitted by the model.\n        It must match the fit() method parameter.\n\n    intercept_scaling : float, default: 1\n        when fit_intercept is True, instance vector x becomes\n        [x, intercept_scaling],\n        i.e. a \"synthetic\" feature with constant value equals to\n        intercept_scaling is appended to the instance vector.\n        It must match the fit() method parameter.\n\n    Returns\n    -------\n    l1_min_c : float\n        minimum value for C\n    ",inputs:[{name:"X",docstring:"Training vector, where n_samples in the number of samples and n_features is the number of features.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Target vector relative to X",param_type:["array"],expected_shape:"[n_samples]",is_optional:!1,default_value:null,options:null},{name:"loss",docstring:"Specifies the loss function. With 'squared_hinge' it is the squared hinge loss (a.k.a. L2 loss). With 'log' it is the loss of logistic regression models.",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,is_optional:!0,default_value:"squared_hinge",options:["squared_hinge","log","default squared_hinge"]},{name:"fit_intercept",docstring:"Specifies if the intercept should be fitted by the model. It must match the fit() method parameter.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"intercept_scaling",docstring:'when fit_intercept is True, instance vector x becomes [x, intercept_scaling], i.e. a "synthetic" feature with constant value equals to intercept_scaling is appended to the instance vector. It must match the fit() method parameter.',param_type:["float"],expected_shape:null,is_optional:!0,default_value:"1",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"l1_min_c",docstring:"minimum value for C",param_type:["float"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[{name:"OneClassSVM",docstring:"Unsupervised Outlier Detection.\n\n    Estimate the support of a high-dimensional distribution",inputs:[{name:"kernel",docstring:"Specifies the kernel type to be used in the algorithm. It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or a callable. If none is given, 'rbf' will be used. If a callable is given it is used to precompute the kernel matrix.",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,is_optional:!0,default_value:"rbf",options:["linear","poly","rbf","sigmoid","precomputed"]},{name:"degree",docstring:"Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"3",options:null},{name:"gamma",docstring:"Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.  Current default is 'auto' which uses 1 / n_features, if ``gamma='scale'`` is passed then it uses 1 / (n_features * X.var()) as value of gamma.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"auto",options:null},{name:"coef0",docstring:"Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"0.0",options:null},{name:"tol",docstring:"Tolerance for stopping criterion.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"nu",docstring:"An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1]. By default 0.5 will be taken.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"0.5",options:null},{name:"shrinking",docstring:"Whether to use the shrinking heuristic.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"cache_size",docstring:"Specify the size of the kernel cache (in MB).",param_type:["float"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"verbose",docstring:"Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null},{name:"max_iter",docstring:"Hard limit on iterations within solver, or -1 for no limit.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"-1",options:null}],outputs:[{name:"support_",docstring:"Indices of support vectors.",param_type:["array"],returned:!1},{name:"support_vectors_",docstring:"Support vectors.",param_type:["array"],returned:!1},{name:"dual_coef_",docstring:"Coefficients of the support vectors in the decision function.",param_type:["array"],returned:!1},{name:"coef_",docstring:"Weights assigned to the features (coefficients in the primal problem). This is only available in the case of a linear kernel.  `coef_` is readonly property derived from `dual_coef_` and `support_vectors_`",param_type:["array"],returned:!1},{name:"intercept_",docstring:"Constant in the decision function.",param_type:["array"],returned:!1},{name:"offset_",docstring:"Offset used to define the decision function from the raw scores. We have the relation: decision_function = score_samples - `offset_`. The offset is the opposite of `intercept_` and is provided for consistency with other outlier detection algorithms.",param_type:["float"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_compute_kernel",docstring:"Return the data transformed by a callable kernel",inputs:[],outputs:[]},{name:"_decision_function",docstring:"Evaluates the decision function for the samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        X : array-like, shape (n_samples, n_class * (n_class-1) / 2)\n            Returns the decision function of the sample for each class\n            in the model.\n        ",inputs:[{name:"X",docstring:"",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null}],outputs:[{name:"X",docstring:"Returns the decision function of the sample for each class in the model.",param_type:["array"],returned:!0}]},{name:"_dense_decision_function",docstring:"None",inputs:[],outputs:[]},{name:"_dense_fit",docstring:"None",inputs:[],outputs:[]},{name:"_dense_predict",docstring:"None",inputs:[],outputs:[]},{name:"_get_coef",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_decision_function",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_fit",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_predict",docstring:"None",inputs:[],outputs:[]},{name:"_validate_for_predict",docstring:"None",inputs:[],outputs:[]},{name:"_validate_targets",docstring:"Validation of y and class_weight.\n\n        Default implementation for SVR and one-class; overridden in BaseSVC.\n        ",inputs:[],outputs:[]},{name:"_warn_from_fit_status",docstring:"None",inputs:[],outputs:[]},{name:"decision_function",docstring:"Signed distance to the separating hyperplane.\n\n        Signed distance is positive for an inlier and negative for an outlier.",inputs:[{name:"X",docstring:"Data.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"dec",docstring:"Returns the decision function of the samples.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"fit",docstring:"\n        Detects the soft boundary of the set of samples X.",inputs:[{name:"X",docstring:"Set of samples, where n_samples is the number of samples and n_features is the number of features.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"sample_weight",docstring:"Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.",param_type:["array"],expected_shape:"(n_samples,)",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"not used, present for API consistency by convention.",param_type:[null],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"fit_predict",docstring:"Performs fit on X and returns labels for X.\n\n        Returns -1 for outliers and 1 for inliers.",inputs:[{name:"X",docstring:"Input data.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"not used, present for API consistency by convention.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"y",docstring:"1 for inliers, -1 for outliers.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"predict",docstring:"\n        Perform classification on samples in X.\n\n        For a one-class model, +1 or -1 is returned.",inputs:[{name:"X",docstring:'For kernel="precomputed", the expected shape of X is [n_samples_test, n_samples_train]',param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"y_pred",docstring:"Class labels for samples in X.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"score_samples",docstring:"Raw scoring function of the samples.",inputs:[{name:"X",docstring:"",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"score_samples",docstring:"Returns the (unshifted) scoring function of the samples.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[]},{name:"SVC",docstring:"C-Support Vector Classification.\n\n    The implementation is based on libsvm. The fit time scales at least\n    quadratically with the number of samples and may be impractical\n    beyond tens of thousands of samples.\n\n    The multiclass support is handled according to a one-vs-one scheme.\n\n    For details on the precise mathematical formulation of the provided\n    kernel functions and how `gamma`, `coef0` and `degree` affect each\n    other, see the corresponding section in the narrative documentation:\n    :ref:`svm_kernels`.",inputs:[{name:"C",docstring:"Penalty parameter C of the error term.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"1.0",options:null},{name:"kernel",docstring:"Specifies the kernel type to be used in the algorithm. It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or a callable. If none is given, 'rbf' will be used. If a callable is given it is used to pre-compute the kernel matrix from data matrices; that matrix should be an array of shape ``(n_samples, n_samples)``.",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,is_optional:!0,default_value:"rbf",options:["linear","poly","rbf","sigmoid","precomputed"]},{name:"degree",docstring:"Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"3",options:null},{name:"gamma",docstring:"Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.  Current default is 'auto' which uses 1 / n_features, if ``gamma='scale'`` is passed then it uses 1 / (n_features * X.var()) as value of gamma.",param_type:["float","str"],expected_shape:null,is_optional:!0,default_value:"auto",options:null},{name:"coef0",docstring:"Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"0.0",options:null},{name:"shrinking",docstring:"Whether to use the shrinking heuristic.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"probability",docstring:"Whether to enable probability estimates. This must be enabled prior to calling `fit`, and will slow down that method.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null},{name:"tol",docstring:"Tolerance for stopping criterion.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"1e-3",options:null},{name:"class_weight",docstring:'Set the parameter C of class i to class_weight[i]*C for SVC. If not given, all classes are supposed to have weight one. The "balanced" mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as ``n_samples / (n_classes * np.bincount(y))``',param_type:["str","dict"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"verbose",docstring:"Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null},{name:"max_iter",docstring:"Hard limit on iterations within solver, or -1 for no limit.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"-1",options:null},{name:"decision_function_shape",docstring:"Whether to return a one-vs-rest ('ovr') decision function of shape (n_samples, n_classes) as all other classifiers, or the original one-vs-one ('ovo') decision function of libsvm which has shape (n_samples, n_classes * (n_classes - 1) / 2). However, one-vs-one ('ovo') is always used as multi-class strategy.",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,is_optional:!0,default_value:"ovr",options:["ovr","ovo"]}],outputs:[{name:"support_",docstring:"Indices of support vectors.",param_type:["array"],returned:!1},{name:"support_vectors_",docstring:"Support vectors.",param_type:["array"],returned:!1},{name:"n_support_",docstring:"Number of support vectors for each class.",param_type:["array"],returned:!1},{name:"dual_coef_",docstring:"Coefficients of the support vector in the decision function. For multiclass, coefficient for all 1-vs-1 classifiers. The layout of the coefficients in the multiclass case is somewhat non-trivial.",param_type:["array"],returned:!1},{name:"coef_",docstring:"Weights assigned to the features (coefficients in the primal problem). This is only available in the case of a linear kernel.  `coef_` is a readonly property derived from `dual_coef_` and `support_vectors_`.",param_type:["array"],returned:!1},{name:"intercept_",docstring:"Constants in decision function.",param_type:["array"],returned:!1},{name:"fit_status_",docstring:"0 if correctly fitted, 1 otherwise (will raise warning)",param_type:["int"],returned:!1},{name:"probA_",docstring:"",param_type:["array"],returned:!1},{name:"probB_",docstring:"If probability=True, the parameters learned in Platt scaling to produce probability estimates from decision values. If probability=False, an empty array. Platt scaling uses the logistic function ``1 / (1 + exp(decision_value * probA_ + probB_))`` where ``probA_`` and ``probB_`` are learned from the dataset.",param_type:["array"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_check_proba",docstring:"None",inputs:[],outputs:[]},{name:"_compute_kernel",docstring:"Return the data transformed by a callable kernel",inputs:[],outputs:[]},{name:"_decision_function",docstring:"Evaluates the decision function for the samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        X : array-like, shape (n_samples, n_class * (n_class-1) / 2)\n            Returns the decision function of the sample for each class\n            in the model.\n        ",inputs:[{name:"X",docstring:"",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null}],outputs:[{name:"X",docstring:"Returns the decision function of the sample for each class in the model.",param_type:["array"],returned:!0}]},{name:"_dense_decision_function",docstring:"None",inputs:[],outputs:[]},{name:"_dense_fit",docstring:"None",inputs:[],outputs:[]},{name:"_dense_predict",docstring:"None",inputs:[],outputs:[]},{name:"_dense_predict_proba",docstring:"None",inputs:[],outputs:[]},{name:"_get_coef",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_predict_log_proba",docstring:"None",inputs:[],outputs:[]},{name:"_predict_proba",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_decision_function",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_fit",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_predict",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_predict_proba",docstring:"None",inputs:[],outputs:[]},{name:"_validate_for_predict",docstring:"None",inputs:[],outputs:[]},{name:"_validate_targets",docstring:"None",inputs:[],outputs:[]},{name:"_warn_from_fit_status",docstring:"None",inputs:[],outputs:[]},{name:"decision_function",docstring:"Evaluates the decision function for the samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        X : array-like, shape (n_samples, n_classes * (n_classes-1) / 2)\n            Returns the decision function of the sample for each class\n            in the model.\n            If decision_function_shape='ovr', the shape is (n_samples,\n            n_classes).\n\n        Notes\n        -----\n        If decision_function_shape='ovo', the function values are proportional\n        to the distance of the samples X to the separating hyperplane. If the\n        exact distances are required, divide the function values by the norm of\n        the weight vector (``coef_``). See also `this question\n        <https://stats.stackexchange.com/questions/14876/\n        interpreting-distance-from-hyperplane-in-svm>`_ for further details.\n        If decision_function_shape='ovr', the decision function is a monotonic\n        transformation of ovo decision function.\n        ",inputs:[{name:"X",docstring:"Data.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X",docstring:"Returns the decision function of the sample for each class in the model. If decision_function_shape='ovr', the shape is (n_samples, n_classes), (n_samples, n_classes * (n_classes-1) / 2) otherwise",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"fit",docstring:"Fit the SVM model according to the given training data.",inputs:[{name:"X",docstring:'Training vectors, where n_samples is the number of samples and n_features is the number of features. For kernel="precomputed", the expected shape of X is (n_samples, n_samples).',param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Target values (class labels in classification, real numbers in regression)",param_type:["array"],expected_shape:"(n_samples,)",is_optional:!1,default_value:null,options:null},{name:"sample_weight",docstring:"Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.",param_type:["array"],expected_shape:"(n_samples,)",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"predict",docstring:"Perform classification on samples in X.\n\n        For an one-class model, +1 or -1 is returned.",inputs:[{name:"X",docstring:'For kernel="precomputed", the expected shape of X is [n_samples_test, n_samples_train]',param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"y_pred",docstring:"Class labels for samples in X.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"score",docstring:"Returns the mean accuracy on the given test data and labels.\n\n        In multi-label classification, this is the subset accuracy\n        which is a harsh metric since you require for each sample that\n        each label set be correctly predicted.",inputs:[{name:"X",docstring:"Test samples.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"True labels for X.",param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",is_optional:!1,default_value:null,options:null},{name:"sample_weight",docstring:"Sample weights.",param_type:["array"],expected_shape:"[n_samples], optional",is_optional:!0,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"score",docstring:"Mean accuracy of self.predict(X) wrt. y.",param_type:["float"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[]},{name:"SVR",docstring:"Epsilon-Support Vector Regression.\n\n    The free parameters in the model are C and epsilon.\n\n    The implementation is based on libsvm. The fit time complexity\n    is more than quadratic with the number of samples which makes it hard\n    to scale to datasets with more than a couple of 10000 samples. ",inputs:[{name:"kernel",docstring:"Specifies the kernel type to be used in the algorithm. It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or a callable. If none is given, 'rbf' will be used. If a callable is given it is used to precompute the kernel matrix.",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,is_optional:!0,default_value:"rbf",options:["linear","poly","rbf","sigmoid","precomputed"]},{name:"degree",docstring:"Degree of the polynomial kernel function ('poly'). Ignored by all other kernels.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"3",options:null},{name:"gamma",docstring:"Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.  Current default is 'auto' which uses 1 / n_features, if ``gamma='scale'`` is passed then it uses 1 / (n_features * X.var()) as value of gamma. ",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"auto",options:null},{name:"coef0",docstring:"Independent term in kernel function. It is only significant in 'poly' and 'sigmoid'.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"0.0",options:null},{name:"tol",docstring:"Tolerance for stopping criterion.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"1e-3",options:null},{name:"C",docstring:"Penalty parameter C of the error term.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"1.0",options:null},{name:"epsilon",docstring:"Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"0.1",options:null},{name:"shrinking",docstring:"Whether to use the shrinking heuristic.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"cache_size",docstring:"Specify the size of the kernel cache (in MB).",param_type:["float"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"verbose",docstring:"Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null},{name:"max_iter",docstring:"Hard limit on iterations within solver, or -1 for no limit.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"-1",options:null}],outputs:[{name:"support_",docstring:"Indices of support vectors.",param_type:["array"],returned:!1},{name:"support_vectors_",docstring:"Support vectors.",param_type:["array"],returned:!1},{name:"dual_coef_",docstring:"Coefficients of the support vector in the decision function.",param_type:["array"],returned:!1},{name:"coef_",docstring:"Weights assigned to the features (coefficients in the primal problem). This is only available in the case of a linear kernel.  `coef_` is readonly property derived from `dual_coef_` and `support_vectors_`.",param_type:["array"],returned:!1},{name:"intercept_",docstring:"Constants in decision function.",param_type:["array"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_compute_kernel",docstring:"Return the data transformed by a callable kernel",inputs:[],outputs:[]},{name:"_decision_function",docstring:"Evaluates the decision function for the samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        X : array-like, shape (n_samples, n_class * (n_class-1) / 2)\n            Returns the decision function of the sample for each class\n            in the model.\n        ",inputs:[{name:"X",docstring:"",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null}],outputs:[{name:"X",docstring:"Returns the decision function of the sample for each class in the model.",param_type:["array"],returned:!0}]},{name:"_dense_decision_function",docstring:"None",inputs:[],outputs:[]},{name:"_dense_fit",docstring:"None",inputs:[],outputs:[]},{name:"_dense_predict",docstring:"None",inputs:[],outputs:[]},{name:"_get_coef",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_decision_function",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_fit",docstring:"None",inputs:[],outputs:[]},{name:"_sparse_predict",docstring:"None",inputs:[],outputs:[]},{name:"_validate_for_predict",docstring:"None",inputs:[],outputs:[]},{name:"_validate_targets",docstring:"Validation of y and class_weight.\n\n        Default implementation for SVR and one-class; overridden in BaseSVC.\n        ",inputs:[],outputs:[]},{name:"_warn_from_fit_status",docstring:"None",inputs:[],outputs:[]},{name:"fit",docstring:"Fit the SVM model according to the given training data.",inputs:[{name:"X",docstring:'Training vectors, where n_samples is the number of samples and n_features is the number of features. For kernel="precomputed", the expected shape of X is (n_samples, n_samples).',param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Target values (class labels in classification, real numbers in regression)",param_type:["array"],expected_shape:"(n_samples,)",is_optional:!1,default_value:null,options:null},{name:"sample_weight",docstring:"Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.",param_type:["array"],expected_shape:"(n_samples,)",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"predict",docstring:"Perform regression on samples in X.\n\n        For an one-class model, +1 (inlier) or -1 (outlier) is returned.",inputs:[{name:"X",docstring:'For kernel="precomputed", the expected shape of X is (n_samples_test, n_samples_train).',param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"y_pred",docstring:"",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"score",docstring:"Returns the coefficient of determination R^2 of the prediction.\n\n        The coefficient R^2 is defined as (1 - u/v), where u is the residual\n        sum of squares ((y_true - y_pred) ** 2).sum() and v is the total\n        sum of squares ((y_true - y_true.mean()) ** 2).sum().\n        The best possible score is 1.0 and it can be negative (because the\n        model can be arbitrarily worse). A constant model that always\n        predicts the expected value of y, disregarding the input features,\n        would get a R^2 score of 0.0.",inputs:[{name:"X",docstring:"Test samples. For some estimators this may be a precomputed kernel matrix instead, shape = (n_samples, n_samples_fitted), where n_samples_fitted is the number of samples used in the fitting for the estimator.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"True values for X.",param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",is_optional:!1,default_value:null,options:null},{name:"sample_weight",docstring:"Sample weights.",param_type:["array"],expected_shape:"[n_samples], optional",is_optional:!0,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"score",docstring:"R^2 of self.predict(X) wrt. y.",param_type:["float"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[]}],library:"sklearn",module:"svm"},Dm={name:"sklearn.linear_model",outputs:[],docstring:"",inputs:[],module:"linear_model",node_functions:[{name:"enet_path",outputs:[{name:"alphas",returned:!0,param_type:["array"],docstring:"The alphas along the path where models are computed."},{name:"coefs",returned:!0,param_type:["array"],docstring:"Coefficients along the path."},{name:"dual_gaps",returned:!0,param_type:["array"],docstring:"The dual gaps at the end of the optimization for each alpha."},{name:"n_iters",returned:!0,param_type:["array"],docstring:"The number of iterations taken by the coordinate descent optimizer to reach the specified tolerance for each alpha. (Is returned when ``return_n_iter`` is set to True)."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Compute elastic net path with coordinate descent\n\n    The elastic net optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is::\n\n        1 / (2 * n_samples) * ||y - Xw||^2_2\n        + alpha * l1_ratio * ||w||_1\n        + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2\n\n    For multi-output tasks it is::\n\n        (1 / (2 * n_samples)) * ||Y - XW||^Fro_2\n        + alpha * l1_ratio * ||W||_21\n        + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2\n\n    Where::\n\n        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}\n\n    i.e. the sum of norm of each row.\n\n    Read more in the :ref:`User Guide <elastic_net>`.\n\n    Parameters\n    ----------\n    X : {array-like}, shape (n_samples, n_features)\n        Training data. Pass directly as Fortran-contiguous data to avoid\n        unnecessary memory duplication. If ``y`` is mono-output then ``X``\n        can be sparse.\n\n    y : ndarray, shape (n_samples,) or (n_samples, n_outputs)\n        Target values\n\n    l1_ratio : float, optional\n        float between 0 and 1 passed to elastic net (scaling between\n        l1 and l2 penalties). ``l1_ratio=1`` corresponds to the Lasso\n\n    eps : float\n        Length of the path. ``eps=1e-3`` means that\n        ``alpha_min / alpha_max = 1e-3``\n\n    n_alphas : int, optional\n        Number of alphas along the regularization path\n\n    alphas : ndarray, optional\n        List of alphas where to compute the models.\n        If None alphas are set automatically\n\n    precompute : True | False | 'auto' | array-like\n        Whether to use a precomputed Gram matrix to speed up\n        calculations. If set to ``'auto'`` let us decide. The Gram\n        matrix can also be passed as argument.\n\n    Xy : array-like, optional\n        Xy = np.dot(X.T, y) that can be precomputed. It is useful\n        only when the Gram matrix is precomputed.\n\n    copy_X : boolean, optional, default True\n        If ``True``, X will be copied; else, it may be overwritten.\n\n    coef_init : array, shape (n_features, ) | None\n        The initial values of the coefficients.\n\n    verbose : bool or integer\n        Amount of verbosity.\n\n    return_n_iter : bool\n        whether to return the number of iterations or not.\n\n    positive : bool, default False\n        If set to True, forces coefficients to be positive.\n        (Only allowed when ``y.ndim == 1``).\n\n    check_input : bool, default True\n        Skip input validation checks, including the Gram matrix when provided\n        assuming there are handled by the caller when check_input=False.\n\n    **params : kwargs\n        keyword arguments passed to the coordinate descent solver.\n\n    Returns\n    -------\n    alphas : array, shape (n_alphas,)\n        The alphas along the path where models are computed.\n\n    coefs : array, shape (n_features, n_alphas) or             (n_outputs, n_features, n_alphas)\n        Coefficients along the path.\n\n    dual_gaps : array, shape (n_alphas,)\n        The dual gaps at the end of the optimization for each alpha.\n\n    n_iters : array-like, shape (n_alphas,)\n        The number of iterations taken by the coordinate descent optimizer to\n        reach the specified tolerance for each alpha.\n        (Is returned when ``return_n_iter`` is set to True).\n\n    Notes\n    -----\n    For an example, see\n    :ref:`examples/linear_model/plot_lasso_coordinate_descent_path.py\n    <sphx_glr_auto_examples_linear_model_plot_lasso_coordinate_descent_path.py>`.\n\n    See also\n    --------\n    MultiTaskElasticNet\n    MultiTaskElasticNetCV\n    ElasticNet\n    ElasticNetCV\n    ",inputs:[{name:"X",default_value:null,param_type:["LIST_VALID_OPTIONS","array"],expected_shape:"(n_samples, n_features)",docstring:"Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If ``y`` is mono-output then ``X`` can be sparse.",is_optional:!1,options:["array-like}"," shape (n_samples"," n_features)"]},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples,) or (n_samples, n_outputs)",docstring:"Target values",is_optional:!1,options:null},{name:"l1_ratio",default_value:null,param_type:["float"],expected_shape:null,docstring:"float between 0 and 1 passed to elastic net (scaling between l1 and l2 penalties). ``l1_ratio=1`` corresponds to the Lasso",is_optional:!0,options:null},{name:"eps",default_value:null,param_type:["float"],expected_shape:null,docstring:"Length of the path. ``eps=1e-3`` means that ``alpha_min / alpha_max = 1e-3``",is_optional:!1,options:null},{name:"n_alphas",default_value:null,param_type:["int"],expected_shape:null,docstring:"Number of alphas along the regularization path",is_optional:!0,options:null},{name:"alphas",default_value:null,param_type:["array"],expected_shape:null,docstring:"List of alphas where to compute the models. If None alphas are set automatically",is_optional:!0,options:null},{name:"precompute",default_value:null,param_type:["LIST_VALID_OPTIONS","array"],expected_shape:null,docstring:"Whether to use a precomputed Gram matrix to speed up calculations. If set to ``'auto'`` let us decide. The Gram matrix can also be passed as argument.",is_optional:!1,options:["True "," False "," 'auto' "," array-like"]},{name:"Xy",default_value:null,param_type:["array"],expected_shape:null,docstring:"Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.",is_optional:!0,options:null},{name:"copy_X",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If ``True``, X will be copied; else, it may be overwritten.",is_optional:!0,options:null},{name:"coef_init",default_value:null,param_type:["LIST_VALID_OPTIONS","array",null],expected_shape:"(n_features, ) | None",docstring:"The initial values of the coefficients.",is_optional:!1,options:["array, shape (n_features, ) "," None"]},{name:"verbose",default_value:null,param_type:["int","bool"],expected_shape:null,docstring:"Amount of verbosity.",is_optional:!1,options:null},{name:"return_n_iter",default_value:null,param_type:["bool"],expected_shape:null,docstring:"whether to return the number of iterations or not.",is_optional:!1,options:null},{name:"positive",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"If set to True, forces coefficients to be positive. (Only allowed when ``y.ndim == 1``).",is_optional:!0,options:null},{name:"check_input",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"Skip input validation checks, including the Gram matrix when provided assuming there are handled by the caller when check_input=False.",is_optional:!0,options:null},{name:"**params",default_value:null,param_type:[null],expected_shape:null,docstring:"keyword arguments passed to the coordinate descent solver.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"lars_path",outputs:[{name:"alphas",returned:!0,param_type:["array"],docstring:"Maximum of covariances (in absolute value) at each iteration. ``n_alphas`` is either ``max_iter``, ``n_features`` or the number of nodes in the path with ``alpha >= alpha_min``, whichever is smaller."},{name:"active",returned:!0,param_type:["array"],docstring:"Indices of active variables at the end of the path."},{name:"coefs",returned:!0,param_type:["array"],docstring:"Coefficients along the path"},{name:"n_iter",returned:!0,param_type:["int"],docstring:"Number of iterations run. Returned only if return_n_iter is set to True."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Compute Least Angle Regression or Lasso path using LARS algorithm [1]\n\n    The optimization objective for the case method='lasso' is::\n\n    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1\n\n    in the case of method='lars', the objective function is only known in\n    the form of an implicit equation (see discussion in [1])\n\n    Read more in the :ref:`User Guide <least_angle_regression>`.\n\n    Parameters\n    -----------\n    X : array, shape: (n_samples, n_features)\n        Input data.\n\n    y : array, shape: (n_samples)\n        Input targets.\n\n    Xy : array-like, shape (n_samples,) or (n_samples, n_targets),             optional\n        Xy = np.dot(X.T, y) that can be precomputed. It is useful\n        only when the Gram matrix is precomputed.\n\n    Gram : None, 'auto', array, shape: (n_features, n_features), optional\n        Precomputed Gram matrix (X' * X), if ``'auto'``, the Gram\n        matrix is precomputed from the given X, if there are more samples\n        than features.\n\n    max_iter : integer, optional (default=500)\n        Maximum number of iterations to perform, set to infinity for no limit.\n\n    alpha_min : float, optional (default=0)\n        Minimum correlation along the path. It corresponds to the\n        regularization parameter alpha parameter in the Lasso.\n\n    method : {'lar', 'lasso'}, optional (default='lar')\n        Specifies the returned model. Select ``'lar'`` for Least Angle\n        Regression, ``'lasso'`` for the Lasso.\n\n    copy_X : bool, optional (default=True)\n        If ``False``, ``X`` is overwritten.\n\n    eps : float, optional (default=``np.finfo(np.float).eps``)\n        The machine-precision regularization in the computation of the\n        Cholesky diagonal factors. Increase this for very ill-conditioned\n        systems.\n\n    copy_Gram : bool, optional (default=True)\n        If ``False``, ``Gram`` is overwritten.\n\n    verbose : int (default=0)\n        Controls output verbosity.\n\n    return_path : bool, optional (default=True)\n        If ``return_path==True`` returns the entire path, else returns only the\n        last point of the path.\n\n    return_n_iter : bool, optional (default=False)\n        Whether to return the number of iterations.\n\n    positive : boolean (default=False)\n        Restrict coefficients to be >= 0.\n        This option is only allowed with method 'lasso'. Note that the model\n        coefficients will not converge to the ordinary-least-squares solution\n        for small values of alpha. Only coefficients up to the smallest alpha\n        value (``alphas_[alphas_ > 0.].min()`` when fit_path=True) reached by\n        the stepwise Lars-Lasso algorithm are typically in congruence with the\n        solution of the coordinate descent lasso_path function.\n\n    Returns\n    --------\n    alphas : array, shape: [n_alphas + 1]\n        Maximum of covariances (in absolute value) at each iteration.\n        ``n_alphas`` is either ``max_iter``, ``n_features`` or the\n        number of nodes in the path with ``alpha >= alpha_min``, whichever\n        is smaller.\n\n    active : array, shape [n_alphas]\n        Indices of active variables at the end of the path.\n\n    coefs : array, shape (n_features, n_alphas + 1)\n        Coefficients along the path\n\n    n_iter : int\n        Number of iterations run. Returned only if return_n_iter is set\n        to True.\n\n    See also\n    --------\n    lasso_path\n    LassoLars\n    Lars\n    LassoLarsCV\n    LarsCV\n    sklearn.decomposition.sparse_encode\n\n    References\n    ----------\n    .. [1] \"Least Angle Regression\", Effron et al.\n           http://statweb.stanford.edu/~tibs/ftp/lars.pdf\n\n    .. [2] `Wikipedia entry on the Least-angle regression\n           <https://en.wikipedia.org/wiki/Least-angle_regression>`_\n\n    .. [3] `Wikipedia entry on the Lasso\n           <https://en.wikipedia.org/wiki/Lasso_(statistics)>`_\n\n    ",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:": (n_samples, n_features)",docstring:"Input data.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:": (n_samples)",docstring:"Input targets.",is_optional:!1,options:null},{name:"Xy",default_value:null,param_type:["array"],expected_shape:"(n_samples,) or (n_samples, n_targets),             optional",docstring:"Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.",is_optional:!0,options:null},{name:"Gram",default_value:null,param_type:["array",null],expected_shape:": (n_features, n_features), optional",docstring:"Precomputed Gram matrix (X' * X), if ``'auto'``, the Gram matrix is precomputed from the given X, if there are more samples than features.",is_optional:!0,options:null},{name:"max_iter",default_value:"500",param_type:["int"],expected_shape:null,docstring:"Maximum number of iterations to perform, set to infinity for no limit.",is_optional:!0,options:null},{name:"alpha_min",default_value:"0",param_type:["float"],expected_shape:null,docstring:"Minimum correlation along the path. It corresponds to the regularization parameter alpha parameter in the Lasso.",is_optional:!0,options:null},{name:"method",default_value:"lar",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"Specifies the returned model. Select ``'lar'`` for Least Angle Regression, ``'lasso'`` for the Lasso.",is_optional:!0,options:["lar"," 'lasso'}"," optional (default='lar')"]},{name:"copy_X",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If ``False``, ``X`` is overwritten.",is_optional:!0,options:null},{name:"eps",default_value:"``np.finfonp.float.eps``",param_type:["float"],expected_shape:null,docstring:"The machine-precision regularization in the computation of the Cholesky diagonal factors. Increase this for very ill-conditioned systems.",is_optional:!0,options:null},{name:"copy_Gram",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If ``False``, ``Gram`` is overwritten.",is_optional:!0,options:null},{name:"verbose",default_value:"0",param_type:["int"],expected_shape:null,docstring:"Controls output verbosity.",is_optional:!0,options:null},{name:"return_path",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If ``return_path==True`` returns the entire path, else returns only the last point of the path.",is_optional:!0,options:null},{name:"return_n_iter",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"Whether to return the number of iterations.",is_optional:!0,options:null},{name:"positive",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"Restrict coefficients to be >= 0. This option is only allowed with method 'lasso'. Note that the model coefficients will not converge to the ordinary-least-squares solution for small values of alpha. Only coefficients up to the smallest alpha value (``alphas_[alphas_ > 0.].min()`` when fit_path=True) reached by the stepwise Lars-Lasso algorithm are typically in congruence with the solution of the coordinate descent lasso_path function.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"lasso_path",outputs:[{name:"alphas",returned:!0,param_type:["array"],docstring:"The alphas along the path where models are computed."},{name:"coefs",returned:!0,param_type:["array"],docstring:"Coefficients along the path."},{name:"dual_gaps",returned:!0,param_type:["array"],docstring:"The dual gaps at the end of the optimization for each alpha."},{name:"n_iters",returned:!0,param_type:["array"],docstring:"The number of iterations taken by the coordinate descent optimizer to reach the specified tolerance for each alpha."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Compute Lasso path with coordinate descent\n\n    The Lasso optimization function varies for mono and multi-outputs.\n\n    For mono-output tasks it is::\n\n        (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1\n\n    For multi-output tasks it is::\n\n        (1 / (2 * n_samples)) * ||Y - XW||^2_Fro + alpha * ||W||_21\n\n    Where::\n\n        ||W||_21 = \\sum_i \\sqrt{\\sum_j w_{ij}^2}\n\n    i.e. the sum of norm of each row.\n\n    Read more in the :ref:`User Guide <lasso>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix}, shape (n_samples, n_features)\n        Training data. Pass directly as Fortran-contiguous data to avoid\n        unnecessary memory duplication. If ``y`` is mono-output then ``X``\n        can be sparse.\n\n    y : ndarray, shape (n_samples,), or (n_samples, n_outputs)\n        Target values\n\n    eps : float, optional\n        Length of the path. ``eps=1e-3`` means that\n        ``alpha_min / alpha_max = 1e-3``\n\n    n_alphas : int, optional\n        Number of alphas along the regularization path\n\n    alphas : ndarray, optional\n        List of alphas where to compute the models.\n        If ``None`` alphas are set automatically\n\n    precompute : True | False | 'auto' | array-like\n        Whether to use a precomputed Gram matrix to speed up\n        calculations. If set to ``'auto'`` let us decide. The Gram\n        matrix can also be passed as argument.\n\n    Xy : array-like, optional\n        Xy = np.dot(X.T, y) that can be precomputed. It is useful\n        only when the Gram matrix is precomputed.\n\n    copy_X : boolean, optional, default True\n        If ``True``, X will be copied; else, it may be overwritten.\n\n    coef_init : array, shape (n_features, ) | None\n        The initial values of the coefficients.\n\n    verbose : bool or integer\n        Amount of verbosity.\n\n    return_n_iter : bool\n        whether to return the number of iterations or not.\n\n    positive : bool, default False\n        If set to True, forces coefficients to be positive.\n        (Only allowed when ``y.ndim == 1``).\n\n    **params : kwargs\n        keyword arguments passed to the coordinate descent solver.\n\n    Returns\n    -------\n    alphas : array, shape (n_alphas,)\n        The alphas along the path where models are computed.\n\n    coefs : array, shape (n_features, n_alphas) or             (n_outputs, n_features, n_alphas)\n        Coefficients along the path.\n\n    dual_gaps : array, shape (n_alphas,)\n        The dual gaps at the end of the optimization for each alpha.\n\n    n_iters : array-like, shape (n_alphas,)\n        The number of iterations taken by the coordinate descent optimizer to\n        reach the specified tolerance for each alpha.\n\n    Notes\n    -----\n    For an example, see\n    :ref:`examples/linear_model/plot_lasso_coordinate_descent_path.py\n    <sphx_glr_auto_examples_linear_model_plot_lasso_coordinate_descent_path.py>`.\n\n    To avoid unnecessary memory duplication the X argument of the fit method\n    should be directly passed as a Fortran-contiguous numpy array.\n\n    Note that in certain cases, the Lars solver may be significantly\n    faster to implement this functionality. In particular, linear\n    interpolation can be used to retrieve model coefficients between the\n    values output by lars_path\n\n    Examples\n    ---------\n\n    Comparing lasso_path and lars_path with interpolation:\n\n    >>> X = np.array([[1, 2, 3.1], [2.3, 5.4, 4.3]]).T\n    >>> y = np.array([1, 2, 3.1])\n    >>> # Use lasso_path to compute a coefficient path\n    >>> _, coef_path, _ = lasso_path(X, y, alphas=[5., 1., .5])\n    >>> print(coef_path)\n    [[0.         0.         0.46874778]\n     [0.2159048  0.4425765  0.23689075]]\n\n    >>> # Now use lars_path and 1D linear interpolation to compute the\n    >>> # same path\n    >>> from sklearn.linear_model import lars_path\n    >>> alphas, active, coef_path_lars = lars_path(X, y, method='lasso')\n    >>> from scipy import interpolate\n    >>> coef_path_continuous = interpolate.interp1d(alphas[::-1],\n    ...                                             coef_path_lars[:, ::-1])\n    >>> print(coef_path_continuous([5., 1., .5]))\n    [[0.         0.         0.46915237]\n     [0.2159048  0.4425765  0.23668876]]\n\n\n    See also\n    --------\n    lars_path\n    Lasso\n    LassoLars\n    LassoCV\n    LassoLarsCV\n    sklearn.decomposition.sparse_encode\n    ",inputs:[{name:"X",default_value:null,param_type:["LIST_VALID_OPTIONS","array"],expected_shape:"(n_samples, n_features)",docstring:"Training data. Pass directly as Fortran-contiguous data to avoid unnecessary memory duplication. If ``y`` is mono-output then ``X`` can be sparse.",is_optional:!1,options:["array-like"," sparse matrix}"," shape (n_samples"," n_features)"]},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples,), or (n_samples, n_outputs)",docstring:"Target values",is_optional:!1,options:null},{name:"eps",default_value:null,param_type:["float"],expected_shape:null,docstring:"Length of the path. ``eps=1e-3`` means that ``alpha_min / alpha_max = 1e-3``",is_optional:!0,options:null},{name:"n_alphas",default_value:null,param_type:["int"],expected_shape:null,docstring:"Number of alphas along the regularization path",is_optional:!0,options:null},{name:"alphas",default_value:null,param_type:["array"],expected_shape:null,docstring:"List of alphas where to compute the models. If ``None`` alphas are set automatically",is_optional:!0,options:null},{name:"precompute",default_value:null,param_type:["LIST_VALID_OPTIONS","array"],expected_shape:null,docstring:"Whether to use a precomputed Gram matrix to speed up calculations. If set to ``'auto'`` let us decide. The Gram matrix can also be passed as argument.",is_optional:!1,options:["True "," False "," 'auto' "," array-like"]},{name:"Xy",default_value:null,param_type:["array"],expected_shape:null,docstring:"Xy = np.dot(X.T, y) that can be precomputed. It is useful only when the Gram matrix is precomputed.",is_optional:!0,options:null},{name:"copy_X",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If ``True``, X will be copied; else, it may be overwritten.",is_optional:!0,options:null},{name:"coef_init",default_value:null,param_type:["LIST_VALID_OPTIONS","array",null],expected_shape:"(n_features, ) | None",docstring:"The initial values of the coefficients.",is_optional:!1,options:["array, shape (n_features, ) "," None"]},{name:"verbose",default_value:null,param_type:["int","bool"],expected_shape:null,docstring:"Amount of verbosity.",is_optional:!1,options:null},{name:"return_n_iter",default_value:null,param_type:["bool"],expected_shape:null,docstring:"whether to return the number of iterations or not.",is_optional:!1,options:null},{name:"positive",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"If set to True, forces coefficients to be positive. (Only allowed when ``y.ndim == 1``).",is_optional:!0,options:null},{name:"**params",default_value:null,param_type:[null],expected_shape:null,docstring:"keyword arguments passed to the coordinate descent solver.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"lasso_stability_path",outputs:[{name:"alphas_grid",returned:!0,param_type:["array"],docstring:"The grid points between 0 and 1: alpha/alpha_max  scores_path : array, shape = [n_features, n_grid]     The scores for each feature along the path."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"DEPRECATED: The function lasso_stability_path is deprecated in 0.19 and will be removed in 0.21.\n\nStability path based on randomized Lasso estimates\n\n    Parameters\n    ----------\n    X : array-like, shape = [n_samples, n_features]\n        training data.\n\n    y : array-like, shape = [n_samples]\n        target values.\n\n    scaling : float, optional, default=0.5\n        The alpha parameter in the stability selection article used to\n        randomly scale the features. Should be between 0 and 1.\n\n    random_state : int, RandomState instance or None, optional, default=None\n        The generator used to randomize the design.  If int, random_state is\n        the seed used by the random number generator; If RandomState instance,\n        random_state is the random number generator; If None, the random number\n        generator is the RandomState instance used by `np.random`.\n\n    n_resampling : int, optional, default=200\n        Number of randomized models.\n\n    n_grid : int, optional, default=100\n        Number of grid points. The path is linearly reinterpolated\n        on a grid between 0 and 1 before computing the scores.\n\n    sample_fraction : float, optional, default=0.75\n        The fraction of samples to be used in each randomized design.\n        Should be between 0 and 1. If 1, all samples are used.\n\n    eps : float, optional\n        Smallest value of alpha / alpha_max considered\n\n    n_jobs : int or None, optional (default=None)\n        Number of CPUs to use during the resampling.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    verbose : boolean or integer, optional\n        Sets the verbosity amount\n\n    Returns\n    -------\n    alphas_grid : array, shape ~ [n_grid]\n        The grid points between 0 and 1: alpha/alpha_max\n\n    scores_path : array, shape = [n_features, n_grid]\n        The scores for each feature along the path.\n    ",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"[n_samples, n_features]",docstring:"training data.  y : array-like, shape = [n_samples]     target values.  scaling : float, optional, default=0.5     The alpha parameter in the stability selection article used to     randomly scale the features. Should be between 0 and 1.  random_state : int, RandomState instance or None, optional, default=None     The generator used to randomize the design.  If int, random_state is     the seed used by the random number generator; If RandomState instance,     random_state is the random number generator; If None, the random number     generator is the RandomState instance used by `np.random`.  n_resampling : int, optional, default=200     Number of randomized models.  n_grid : int, optional, default=100     Number of grid points. The path is linearly reinterpolated     on a grid between 0 and 1 before computing the scores.  sample_fraction : float, optional, default=0.75     The fraction of samples to be used in each randomized design.     Should be between 0 and 1. If 1, all samples are used.  eps : float, optional     Smallest value of alpha / alpha_max considered  n_jobs : int or None, optional (default=None)     Number of CPUs to use during the resampling.     ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.     ``-1`` means using all processors. See :term:`Glossary <n_jobs>`     for more details.  verbose : boolean or integer, optional     Sets the verbosity amount",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"logistic_regression_path",outputs:[{name:"coefs",returned:!0,param_type:["array"],docstring:"List of coefficients for the Logistic Regression model. If fit_intercept is set to True then the second dimension will be n_features + 1, where the last item represents the intercept. For ``multiclass='multinomial'``, the shape is (n_classes, n_cs, n_features) or (n_classes, n_cs, n_features + 1)."},{name:"Cs",returned:!0,param_type:["array"],docstring:"Grid of Cs used for cross-validation."},{name:"n_iter",returned:!0,param_type:["array"],docstring:"Actual number of iteration for each Cs."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Compute a Logistic Regression model for a list of regularization\n    parameters.\n\n    This is an implementation that uses the result of the previous model\n    to speed up computations along the set of solutions, making it faster\n    than sequentially calling LogisticRegression for the different parameters.\n    Note that there will be no speedup with liblinear solver, since it does\n    not handle warm-starting.\n\n    Read more in the :ref:`User Guide <logistic_regression>`.\n\n    Parameters\n    ----------\n    X : array-like or sparse matrix, shape (n_samples, n_features)\n        Input data.\n\n    y : array-like, shape (n_samples,) or (n_samples, n_targets)\n        Input data, target values.\n\n    pos_class : int, None\n        The class with respect to which we perform a one-vs-all fit.\n        If None, then it is assumed that the given problem is binary.\n\n    Cs : int | array-like, shape (n_cs,)\n        List of values for the regularization parameter or integer specifying\n        the number of regularization parameters that should be used. In this\n        case, the parameters will be chosen in a logarithmic scale between\n        1e-4 and 1e4.\n\n    fit_intercept : bool\n        Whether to fit an intercept for the model. In this case the shape of\n        the returned array is (n_cs, n_features + 1).\n\n    max_iter : int\n        Maximum number of iterations for the solver.\n\n    tol : float\n        Stopping criterion. For the newton-cg and lbfgs solvers, the iteration\n        will stop when ``max{|g_i | i = 1, ..., n} <= tol``\n        where ``g_i`` is the i-th component of the gradient.\n\n    verbose : int\n        For the liblinear and lbfgs solvers set verbose to any positive\n        number for verbosity.\n\n    solver : {'lbfgs', 'newton-cg', 'liblinear', 'sag', 'saga'}\n        Numerical solver to use.\n\n    coef : array-like, shape (n_features,), default None\n        Initialization value for coefficients of logistic regression.\n        Useless for liblinear solver.\n\n    class_weight : dict or 'balanced', optional\n        Weights associated with classes in the form ``{class_label: weight}``.\n        If not given, all classes are supposed to have weight one.\n\n        The \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``.\n\n        Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\n    dual : bool\n        Dual or primal formulation. Dual formulation is only implemented for\n        l2 penalty with liblinear solver. Prefer dual=False when\n        n_samples > n_features.\n\n    penalty : str, 'l1' or 'l2'\n        Used to specify the norm used in the penalization. The 'newton-cg',\n        'sag' and 'lbfgs' solvers support only l2 penalties.\n\n    intercept_scaling : float, default 1.\n        Useful only when the solver 'liblinear' is used\n        and self.fit_intercept is set to True. In this case, x becomes\n        [x, self.intercept_scaling],\n        i.e. a \"synthetic\" feature with constant value equal to\n        intercept_scaling is appended to the instance vector.\n        The intercept becomes ``intercept_scaling * synthetic_feature_weight``.\n\n        Note! the synthetic feature weight is subject to l1/l2 regularization\n        as all other features.\n        To lessen the effect of regularization on synthetic feature weight\n        (and therefore on the intercept) intercept_scaling has to be increased.\n\n    multi_class : str, {'ovr', 'multinomial', 'auto'}, default: 'ovr'\n        If the option chosen is 'ovr', then a binary problem is fit for each\n        label. For 'multinomial' the loss minimised is the multinomial loss fit\n        across the entire probability distribution, *even when the data is\n        binary*. 'multinomial' is unavailable when solver='liblinear'.\n        'auto' selects 'ovr' if the data is binary, or if solver='liblinear',\n        and otherwise selects 'multinomial'.\n\n        .. versionadded:: 0.18\n           Stochastic Average Gradient descent solver for 'multinomial' case.\n        .. versionchanged:: 0.20\n            Default will change from 'ovr' to 'auto' in 0.22.\n\n    random_state : int, RandomState instance or None, optional, default None\n        The seed of the pseudo random number generator to use when shuffling\n        the data.  If int, random_state is the seed used by the random number\n        generator; If RandomState instance, random_state is the random number\n        generator; If None, the random number generator is the RandomState\n        instance used by `np.random`. Used when ``solver`` == 'sag' or\n        'liblinear'.\n\n    check_input : bool, default True\n        If False, the input arrays X and y will not be checked.\n\n    max_squared_sum : float, default None\n        Maximum squared sum of X over samples. Used only in SAG solver.\n        If None, it will be computed, going through all the samples.\n        The value should be precomputed to speed up cross validation.\n\n    sample_weight : array-like, shape(n_samples,) optional\n        Array of weights that are assigned to individual samples.\n        If not provided, then each sample is given unit weight.\n\n    Returns\n    -------\n    coefs : ndarray, shape (n_cs, n_features) or (n_cs, n_features + 1)\n        List of coefficients for the Logistic Regression model. If\n        fit_intercept is set to True then the second dimension will be\n        n_features + 1, where the last item represents the intercept. For\n        ``multiclass='multinomial'``, the shape is (n_classes, n_cs,\n        n_features) or (n_classes, n_cs, n_features + 1).\n\n    Cs : ndarray\n        Grid of Cs used for cross-validation.\n\n    n_iter : array, shape (n_cs,)\n        Actual number of iteration for each Cs.\n\n    Notes\n    -----\n    You might get slightly different results with the solver liblinear than\n    with the others since this uses LIBLINEAR which penalizes the intercept.\n\n    .. versionchanged:: 0.19\n        The \"copy\" parameter was removed.\n    ",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Input data.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples,) or (n_samples, n_targets)",docstring:"Input data, target values.",is_optional:!1,options:null},{name:"pos_class",default_value:null,param_type:["int",null],expected_shape:null,docstring:"The class with respect to which we perform a one-vs-all fit. If None, then it is assumed that the given problem is binary.",is_optional:!1,options:null},{name:"Cs",default_value:null,param_type:["LIST_VALID_OPTIONS","array","int"],expected_shape:"(n_cs,)",docstring:"List of values for the regularization parameter or integer specifying the number of regularization parameters that should be used. In this case, the parameters will be chosen in a logarithmic scale between 1e-4 and 1e4.",is_optional:!1,options:["int "," array-like, shape (n_cs,)"]},{name:"fit_intercept",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Whether to fit an intercept for the model. In this case the shape of the returned array is (n_cs, n_features + 1).",is_optional:!1,options:null},{name:"max_iter",default_value:null,param_type:["int"],expected_shape:null,docstring:"Maximum number of iterations for the solver.",is_optional:!1,options:null},{name:"tol",default_value:null,param_type:["float"],expected_shape:null,docstring:"Stopping criterion. For the newton-cg and lbfgs solvers, the iteration will stop when ``max{|g_i | i = 1, ..., n} <= tol`` where ``g_i`` is the i-th component of the gradient.",is_optional:!1,options:null},{name:"verbose",default_value:null,param_type:["int"],expected_shape:null,docstring:"For the liblinear and lbfgs solvers set verbose to any positive number for verbosity.",is_optional:!1,options:null},{name:"solver",default_value:null,param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"Numerical solver to use.",is_optional:!1,options:["lbfgs"," 'newton-cg"," 'liblinear"," 'sag"," 'saga"]},{name:"coef",default_value:"None",param_type:["array",null],expected_shape:"(n_features,), default None",docstring:"Initialization value for coefficients of logistic regression. Useless for liblinear solver.",is_optional:!0,options:null},{name:"class_weight",default_value:null,param_type:["dict"],expected_shape:null,docstring:'Weights associated with classes in the form ``{class_label: weight}``. If not given, all classes are supposed to have weight one.  The "balanced" mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as ``n_samples / (n_classes * np.bincount(y))``.  Note that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified.',is_optional:!0,options:null},{name:"dual",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Dual or primal formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=False when n_samples > n_features.",is_optional:!1,options:null},{name:"penalty",default_value:null,param_type:["str"],expected_shape:null,docstring:"Used to specify the norm used in the penalization. The 'newton-cg', 'sag' and 'lbfgs' solvers support only l2 penalties.",is_optional:!1,options:null},{name:"intercept_scaling",default_value:"1.",param_type:["float"],expected_shape:null,docstring:"Useful only when the solver 'liblinear' is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a \"synthetic\" feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes ``intercept_scaling * synthetic_feature_weight``.  Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased.",is_optional:!0,options:null},{name:"multi_class",default_value:"ovr",param_type:["LIST_VALID_OPTIONS","str"],expected_shape:null,docstring:"If the option chosen is 'ovr', then a binary problem is fit for each label. For 'multinomial' the loss minimised is the multinomial loss fit across the entire probability distribution, *even when the data is binary*. 'multinomial' is unavailable when solver='liblinear'. 'auto' selects 'ovr' if the data is binary, or if solver='liblinear', and otherwise selects 'multinomial'.  .. versionadded:: 0.18    Stochastic Average Gradient descent solver for 'multinomial' case. .. versionchanged:: 0.20     Default will change from 'ovr' to 'auto' in 0.22.",is_optional:!0,options:["str"," {'ovr"," 'multinomial"," 'auto'}"," default: 'ovr"]},{name:"random_state",default_value:"None",param_type:["int",null],expected_shape:null,docstring:"The seed of the pseudo random number generator to use when shuffling the data.  If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`. Used when ``solver`` == 'sag' or 'liblinear'.",is_optional:!0,options:null},{name:"check_input",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If False, the input arrays X and y will not be checked.",is_optional:!0,options:null},{name:"max_squared_sum",default_value:"None",param_type:["float",null],expected_shape:null,docstring:"Maximum squared sum of X over samples. Used only in SAG solver. If None, it will be computed, going through all the samples. The value should be precomputed to speed up cross validation.",is_optional:!0,options:null},{name:"sample_weight",default_value:null,param_type:["array"],expected_shape:"(n_samples,) optional",docstring:"Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"orthogonal_mp",outputs:[{name:"coef",returned:!0,param_type:["array"],docstring:"Coefficients of the OMP solution. If `return_path=True`, this contains the whole coefficient path. In this case its shape is (n_features, n_features) or (n_features, n_targets, n_features) and iterating over the last axis yields coefficients in increasing order of active features."},{name:"n_iters",returned:!0,param_type:["array","int"],docstring:"Number of active features across every target. Returned only if `return_n_iter` is set to True."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Orthogonal Matching Pursuit (OMP)\n\n    Solves n_targets Orthogonal Matching Pursuit problems.\n    An instance of the problem has the form:\n\n    When parametrized by the number of non-zero coefficients using\n    `n_nonzero_coefs`:\n    argmin ||y - X\\gamma||^2 subject to ||\\gamma||_0 <= n_{nonzero coefs}\n\n    When parametrized by error using the parameter `tol`:\n    argmin ||\\gamma||_0 subject to ||y - X\\gamma||^2 <= tol\n\n    Read more in the :ref:`User Guide <omp>`.\n\n    Parameters\n    ----------\n    X : array, shape (n_samples, n_features)\n        Input data. Columns are assumed to have unit norm.\n\n    y : array, shape (n_samples,) or (n_samples, n_targets)\n        Input targets\n\n    n_nonzero_coefs : int\n        Desired number of non-zero entries in the solution. If None (by\n        default) this value is set to 10% of n_features.\n\n    tol : float\n        Maximum norm of the residual. If not None, overrides n_nonzero_coefs.\n\n    precompute : {True, False, 'auto'},\n        Whether to perform precomputations. Improves performance when n_targets\n        or n_samples is very large.\n\n    copy_X : bool, optional\n        Whether the design matrix X must be copied by the algorithm. A false\n        value is only helpful if X is already Fortran-ordered, otherwise a\n        copy is made anyway.\n\n    return_path : bool, optional. Default: False\n        Whether to return every value of the nonzero coefficients along the\n        forward path. Useful for cross-validation.\n\n    return_n_iter : bool, optional default False\n        Whether or not to return the number of iterations.\n\n    Returns\n    -------\n    coef : array, shape (n_features,) or (n_features, n_targets)\n        Coefficients of the OMP solution. If `return_path=True`, this contains\n        the whole coefficient path. In this case its shape is\n        (n_features, n_features) or (n_features, n_targets, n_features) and\n        iterating over the last axis yields coefficients in increasing order\n        of active features.\n\n    n_iters : array-like or int\n        Number of active features across every target. Returned only if\n        `return_n_iter` is set to True.\n\n    See also\n    --------\n    OrthogonalMatchingPursuit\n    orthogonal_mp_gram\n    lars_path\n    decomposition.sparse_encode\n\n    Notes\n    -----\n    Orthogonal matching pursuit was introduced in S. Mallat, Z. Zhang,\n    Matching pursuits with time-frequency dictionaries, IEEE Transactions on\n    Signal Processing, Vol. 41, No. 12. (December 1993), pp. 3397-3415.\n    (http://blanche.polytechnique.fr/~mallat/papiers/MallatPursuit93.pdf)\n\n    This implementation is based on Rubinstein, R., Zibulevsky, M. and Elad,\n    M., Efficient Implementation of the K-SVD Algorithm using Batch Orthogonal\n    Matching Pursuit Technical Report - CS Technion, April 2008.\n    http://www.cs.technion.ac.il/~ronrubin/Publications/KSVD-OMP-v2.pdf\n\n    ",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Input data. Columns are assumed to have unit norm.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples,) or (n_samples, n_targets)",docstring:"Input targets",is_optional:!1,options:null},{name:"n_nonzero_coefs",default_value:null,param_type:["int"],expected_shape:null,docstring:"Desired number of non-zero entries in the solution. If None (by default) this value is set to 10% of n_features.",is_optional:!1,options:null},{name:"tol",default_value:null,param_type:["float"],expected_shape:null,docstring:"Maximum norm of the residual. If not None, overrides n_nonzero_coefs.",is_optional:!1,options:null},{name:"precompute",default_value:null,param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"Whether to perform precomputations. Improves performance when n_targets or n_samples is very large.",is_optional:!1,options:["True"," False"," 'auto'}",""]},{name:"copy_X",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Whether the design matrix X must be copied by the algorithm. A false value is only helpful if X is already Fortran-ordered, otherwise a copy is made anyway.",is_optional:!0,options:null},{name:"return_path",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Whether to return every value of the nonzero coefficients along the forward path. Useful for cross-validation.",is_optional:!0,options:null},{name:"return_n_iter",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"Whether or not to return the number of iterations.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"orthogonal_mp_gram",outputs:[{name:"coef",returned:!0,param_type:["array"],docstring:"Coefficients of the OMP solution. If `return_path=True`, this contains the whole coefficient path. In this case its shape is (n_features, n_features) or (n_features, n_targets, n_features) and iterating over the last axis yields coefficients in increasing order of active features."},{name:"n_iters",returned:!0,param_type:["array","int"],docstring:"Number of active features across every target. Returned only if `return_n_iter` is set to True."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Gram Orthogonal Matching Pursuit (OMP)\n\n    Solves n_targets Orthogonal Matching Pursuit problems using only\n    the Gram matrix X.T * X and the product X.T * y.\n\n    Read more in the :ref:`User Guide <omp>`.\n\n    Parameters\n    ----------\n    Gram : array, shape (n_features, n_features)\n        Gram matrix of the input data: X.T * X\n\n    Xy : array, shape (n_features,) or (n_features, n_targets)\n        Input targets multiplied by X: X.T * y\n\n    n_nonzero_coefs : int\n        Desired number of non-zero entries in the solution. If None (by\n        default) this value is set to 10% of n_features.\n\n    tol : float\n        Maximum norm of the residual. If not None, overrides n_nonzero_coefs.\n\n    norms_squared : array-like, shape (n_targets,)\n        Squared L2 norms of the lines of y. Required if tol is not None.\n\n    copy_Gram : bool, optional\n        Whether the gram matrix must be copied by the algorithm. A false\n        value is only helpful if it is already Fortran-ordered, otherwise a\n        copy is made anyway.\n\n    copy_Xy : bool, optional\n        Whether the covariance vector Xy must be copied by the algorithm.\n        If False, it may be overwritten.\n\n    return_path : bool, optional. Default: False\n        Whether to return every value of the nonzero coefficients along the\n        forward path. Useful for cross-validation.\n\n    return_n_iter : bool, optional default False\n        Whether or not to return the number of iterations.\n\n    Returns\n    -------\n    coef : array, shape (n_features,) or (n_features, n_targets)\n        Coefficients of the OMP solution. If `return_path=True`, this contains\n        the whole coefficient path. In this case its shape is\n        (n_features, n_features) or (n_features, n_targets, n_features) and\n        iterating over the last axis yields coefficients in increasing order\n        of active features.\n\n    n_iters : array-like or int\n        Number of active features across every target. Returned only if\n        `return_n_iter` is set to True.\n\n    See also\n    --------\n    OrthogonalMatchingPursuit\n    orthogonal_mp\n    lars_path\n    decomposition.sparse_encode\n\n    Notes\n    -----\n    Orthogonal matching pursuit was introduced in G. Mallat, Z. Zhang,\n    Matching pursuits with time-frequency dictionaries, IEEE Transactions on\n    Signal Processing, Vol. 41, No. 12. (December 1993), pp. 3397-3415.\n    (http://blanche.polytechnique.fr/~mallat/papiers/MallatPursuit93.pdf)\n\n    This implementation is based on Rubinstein, R., Zibulevsky, M. and Elad,\n    M., Efficient Implementation of the K-SVD Algorithm using Batch Orthogonal\n    Matching Pursuit Technical Report - CS Technion, April 2008.\n    http://www.cs.technion.ac.il/~ronrubin/Publications/KSVD-OMP-v2.pdf\n\n    ",inputs:[{name:"Gram",default_value:null,param_type:["array"],expected_shape:"(n_features, n_features)",docstring:"Gram matrix of the input data: X.T * X",is_optional:!1,options:null},{name:"Xy",default_value:null,param_type:["array"],expected_shape:"(n_features,) or (n_features, n_targets)",docstring:"Input targets multiplied by X: X.T * y",is_optional:!1,options:null},{name:"n_nonzero_coefs",default_value:null,param_type:["int"],expected_shape:null,docstring:"Desired number of non-zero entries in the solution. If None (by default) this value is set to 10% of n_features.",is_optional:!1,options:null},{name:"tol",default_value:null,param_type:["float"],expected_shape:null,docstring:"Maximum norm of the residual. If not None, overrides n_nonzero_coefs.",is_optional:!1,options:null},{name:"norms_squared",default_value:null,param_type:["array"],expected_shape:"(n_targets,)",docstring:"Squared L2 norms of the lines of y. Required if tol is not None.",is_optional:!1,options:null},{name:"copy_Gram",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Whether the gram matrix must be copied by the algorithm. A false value is only helpful if it is already Fortran-ordered, otherwise a copy is made anyway.",is_optional:!0,options:null},{name:"copy_Xy",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Whether the covariance vector Xy must be copied by the algorithm. If False, it may be overwritten.",is_optional:!0,options:null},{name:"return_path",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Whether to return every value of the nonzero coefficients along the forward path. Useful for cross-validation.",is_optional:!0,options:null},{name:"return_n_iter",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"Whether or not to return the number of iterations.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"ridge_regression",outputs:[{name:"coef",returned:!0,param_type:["array"],docstring:"Weight vector(s)."},{name:"n_iter",returned:!0,param_type:["int"],docstring:"The actual number of iteration performed by the solver. Only returned if `return_n_iter` is True."},{name:"intercept",returned:!0,param_type:["array","float"],docstring:"The intercept of the model. Only returned if `return_intercept` is True and if X is a scipy sparse array."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Solve the ridge equation by the method of normal equations.\n\n    Read more in the :ref:`User Guide <ridge_regression>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix, LinearOperator},\n        shape = [n_samples, n_features]\n        Training data\n\n    y : array-like, shape = [n_samples] or [n_samples, n_targets]\n        Target values\n\n    alpha : {float, array-like},\n        shape = [n_targets] if array-like\n        Regularization strength; must be a positive float. Regularization\n        improves the conditioning of the problem and reduces the variance of\n        the estimates. Larger values specify stronger regularization.\n        Alpha corresponds to ``C^-1`` in other linear models such as\n        LogisticRegression or LinearSVC. If an array is passed, penalties are\n        assumed to be specific to the targets. Hence they must correspond in\n        number.\n\n    sample_weight : float or numpy array of shape [n_samples]\n        Individual weights for each sample. If sample_weight is not None and\n        solver='auto', the solver will be set to 'cholesky'.\n\n        .. versionadded:: 0.17\n\n    solver : {'auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga'}\n        Solver to use in the computational routines:\n\n        - 'auto' chooses the solver automatically based on the type of data.\n\n        - 'svd' uses a Singular Value Decomposition of X to compute the Ridge\n          coefficients. More stable for singular matrices than\n          'cholesky'.\n\n        - 'cholesky' uses the standard scipy.linalg.solve function to\n          obtain a closed-form solution via a Cholesky decomposition of\n          dot(X.T, X)\n\n        - 'sparse_cg' uses the conjugate gradient solver as found in\n          scipy.sparse.linalg.cg. As an iterative algorithm, this solver is\n          more appropriate than 'cholesky' for large-scale data\n          (possibility to set `tol` and `max_iter`).\n\n        - 'lsqr' uses the dedicated regularized least-squares routine\n          scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative\n          procedure.\n\n        - 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses\n          its improved, unbiased version named SAGA. Both methods also use an\n          iterative procedure, and are often faster than other solvers when\n          both n_samples and n_features are large. Note that 'sag' and\n          'saga' fast convergence is only guaranteed on features with\n          approximately the same scale. You can preprocess the data with a\n          scaler from sklearn.preprocessing.\n\n\n        All last five solvers support both dense and sparse data. However, only\n        'sag' and 'saga' supports sparse input when`fit_intercept` is True.\n\n        .. versionadded:: 0.17\n           Stochastic Average Gradient descent solver.\n        .. versionadded:: 0.19\n           SAGA solver.\n\n    max_iter : int, optional\n        Maximum number of iterations for conjugate gradient solver.\n        For the 'sparse_cg' and 'lsqr' solvers, the default value is determined\n        by scipy.sparse.linalg. For 'sag' and saga solver, the default value is\n        1000.\n\n    tol : float\n        Precision of the solution.\n\n    verbose : int\n        Verbosity level. Setting verbose > 0 will display additional\n        information depending on the solver used.\n\n    random_state : int, RandomState instance or None, optional, default None\n        The seed of the pseudo random number generator to use when shuffling\n        the data.  If int, random_state is the seed used by the random number\n        generator; If RandomState instance, random_state is the random number\n        generator; If None, the random number generator is the RandomState\n        instance used by `np.random`. Used when ``solver`` == 'sag'.\n\n    return_n_iter : boolean, default False\n        If True, the method also returns `n_iter`, the actual number of\n        iteration performed by the solver.\n\n        .. versionadded:: 0.17\n\n    return_intercept : boolean, default False\n        If True and if X is sparse, the method also returns the intercept,\n        and the solver is automatically changed to 'sag'. This is only a\n        temporary fix for fitting the intercept with sparse data. For dense\n        data, use sklearn.linear_model._preprocess_data before your regression.\n\n        .. versionadded:: 0.17\n\n    Returns\n    -------\n    coef : array, shape = [n_features] or [n_targets, n_features]\n        Weight vector(s).\n\n    n_iter : int, optional\n        The actual number of iteration performed by the solver.\n        Only returned if `return_n_iter` is True.\n\n    intercept : float or array, shape = [n_targets]\n        The intercept of the model. Only returned if `return_intercept`\n        is True and if X is a scipy sparse array.\n\n    Notes\n    -----\n    This function won't compute the intercept.\n    ",inputs:[{name:"X",default_value:null,param_type:["LIST_VALID_OPTIONS","array"],expected_shape:null,docstring:"shape = [n_samples, n_features] Training data",is_optional:!1,options:["array-like"," sparse matrix"," LinearOperator}",""]},{name:"y",default_value:null,param_type:["array"],expected_shape:"[n_samples] or [n_samples, n_targets]",docstring:"Target values",is_optional:!1,options:null},{name:"alpha",default_value:null,param_type:["LIST_VALID_OPTIONS","array","float"],expected_shape:null,docstring:"shape = [n_targets] if array-like Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Alpha corresponds to ``C^-1`` in other linear models such as LogisticRegression or LinearSVC. If an array is passed, penalties are assumed to be specific to the targets. Hence they must correspond in number.",is_optional:!1,options:["float"," array-like}",""]},{name:"sample_weight",default_value:null,param_type:["array","float"],expected_shape:"[n_samples]",docstring:"Individual weights for each sample. If sample_weight is not None and solver='auto', the solver will be set to 'cholesky'.  .. versionadded:: 0.17",is_optional:!1,options:null},{name:"solver",default_value:null,param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"Solver to use in the computational routines:  - 'auto' chooses the solver automatically based on the type of data.  - 'svd' uses a Singular Value Decomposition of X to compute the Ridge   coefficients. More stable for singular matrices than   'cholesky'.  - 'cholesky' uses the standard scipy.linalg.solve function to   obtain a closed-form solution via a Cholesky decomposition of   dot(X.T, X)  - 'sparse_cg' uses the conjugate gradient solver as found in   scipy.sparse.linalg.cg. As an iterative algorithm, this solver is   more appropriate than 'cholesky' for large-scale data   (possibility to set `tol` and `max_iter`).  - 'lsqr' uses the dedicated regularized least-squares routine   scipy.sparse.linalg.lsqr. It is the fastest and uses an iterative   procedure.  - 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses   its improved, unbiased version named SAGA. Both methods also use an   iterative procedure, and are often faster than other solvers when   both n_samples and n_features are large. Note that 'sag' and   'saga' fast convergence is only guaranteed on features with   approximately the same scale. You can preprocess the data with a   scaler from sklearn.preprocessing.  All last five solvers support both dense and sparse data. However, only 'sag' and 'saga' supports sparse input when`fit_intercept` is True.  .. versionadded:: 0.17    Stochastic Average Gradient descent solver. .. versionadded:: 0.19    SAGA solver.",is_optional:!1,options:["auto"," 'svd"," 'cholesky"," 'lsqr"," 'sparse_cg"," 'sag"," 'saga"]},{name:"max_iter",default_value:null,param_type:["int"],expected_shape:null,docstring:"Maximum number of iterations for conjugate gradient solver. For the 'sparse_cg' and 'lsqr' solvers, the default value is determined by scipy.sparse.linalg. For 'sag' and saga solver, the default value is 1000.",is_optional:!0,options:null},{name:"tol",default_value:null,param_type:["float"],expected_shape:null,docstring:"Precision of the solution.",is_optional:!1,options:null},{name:"verbose",default_value:null,param_type:["int"],expected_shape:null,docstring:"Verbosity level. Setting verbose > 0 will display additional information depending on the solver used.",is_optional:!1,options:null},{name:"random_state",default_value:"None",param_type:["int",null],expected_shape:null,docstring:"The seed of the pseudo random number generator to use when shuffling the data.  If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`. Used when ``solver`` == 'sag'.",is_optional:!0,options:null},{name:"return_n_iter",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"If True, the method also returns `n_iter`, the actual number of iteration performed by the solver.  .. versionadded:: 0.17",is_optional:!0,options:null},{name:"return_intercept",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"If True and if X is sparse, the method also returns the intercept, and the solver is automatically changed to 'sag'. This is only a temporary fix for fitting the intercept with sparse data. For dense data, use sklearn.linear_model._preprocess_data before your regression.  .. versionadded:: 0.17",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]}],nodes:[{name:"ElasticNet",outputs:[{name:"coef_",returned:!1,param_type:["array"],docstring:"parameter vector (w in the cost function formula)"},{name:"sparse_coef_",returned:!1,param_type:["scipy.sparse.matrix"],docstring:"``sparse_coef_`` is a readonly property derived from ``coef_``"},{name:"intercept_",returned:!1,param_type:["array","float"],docstring:"independent term in decision function."},{name:"n_iter_",returned:!1,param_type:["array"],docstring:"number of iterations run by the coordinate descent solver to reach the specified tolerance."}],docstring:"Linear regression with combined L1 and L2 priors as regularizer.\n\n    Minimizes the objective function::\n\n            1 / (2 * n_samples) * ||y - Xw||^2_2\n            + alpha * l1_ratio * ||w||_1\n            + 0.5 * alpha * (1 - l1_ratio) * ||w||^2_2\n\n    If you are interested in controlling the L1 and L2 penalty\n    separately, keep in mind that this is equivalent to::\n\n            a * L1 + b * L2\n\n    where::\n\n            alpha = a + b and l1_ratio = a / (a + b)\n\n    The parameter l1_ratio corresponds to alpha in the glmnet R package while\n    alpha corresponds to the lambda parameter in glmnet. Specifically, l1_ratio\n    = 1 is the lasso penalty. Currently, l1_ratio <= 0.01 is not reliable,\n    unless you supply your own sequence of alpha.",inputs:[{name:"alpha",default_value:"1.0",param_type:["float"],expected_shape:null,docstring:"Constant that multiplies the penalty terms. Defaults to 1.0. See the notes for the exact mathematical meaning of this parameter.``alpha = 0`` is equivalent to an ordinary least square, solved by the :class:`LinearRegression` object. For numerical reasons, using ``alpha = 0`` with the ``Lasso`` object is not advised. Given this, you should use the :class:`LinearRegression` object.",is_optional:!0,options:null},{name:"l1_ratio",default_value:null,param_type:["float"],expected_shape:null,docstring:"The ElasticNet mixing parameter, with ``0 <= l1_ratio <= 1``. For ``l1_ratio = 0`` the penalty is an L2 penalty. ``For l1_ratio = 1`` it is an L1 penalty.  For ``0 < l1_ratio < 1``, the penalty is a combination of L1 and L2.",is_optional:!1,options:null},{name:"fit_intercept",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Whether the intercept should be estimated or not. If ``False``, the data is assumed to be already centered.",is_optional:!1,options:null},{name:"normalize",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"This parameter is ignored when ``fit_intercept`` is set to False. If True, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use :class:`sklearn.preprocessing.StandardScaler` before calling ``fit`` on an estimator with ``normalize=False``.",is_optional:!0,options:null},{name:"precompute",default_value:null,param_type:["bool","array"],expected_shape:null,docstring:"Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument. For sparse input this option is always ``True`` to preserve sparsity.",is_optional:!1,options:null},{name:"max_iter",default_value:null,param_type:["int"],expected_shape:null,docstring:"The maximum number of iterations",is_optional:!0,options:null},{name:"copy_X",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If ``True``, X will be copied; else, it may be overwritten.",is_optional:!0,options:null},{name:"tol",default_value:null,param_type:["float"],expected_shape:null,docstring:"The tolerance for the optimization: if the updates are smaller than ``tol``, the optimization code checks the dual gap for optimality and continues until it is smaller than ``tol``.",is_optional:!0,options:null},{name:"warm_start",default_value:!1,param_type:["bool"],expected_shape:null,docstring:"When set to ``True``, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See :term:`the Glossary <warm_start>`.",is_optional:!0,options:null},{name:"positive",default_value:!1,param_type:["bool"],expected_shape:null,docstring:"When set to ``True``, forces the coefficients to be positive.",is_optional:!0,options:null},{name:"selection",default_value:"cyclic",param_type:["str"],expected_shape:null,docstring:"If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to 'random') often leads to significantly faster convergence especially when tol is higher than 1e-4.",is_optional:!0,options:["random","cyclic"]}],node_functions:[{name:"__init__",outputs:[],docstring:"None",inputs:[]},{name:"_decision_function",outputs:[{name:"T",returned:!0,param_type:["array"],docstring:"The predicted decision function"}],docstring:"Decision function of the linear model\n\n        Parameters\n        ----------\n        X : numpy array or scipy.sparse matrix of shape (n_samples, n_features)\n\n        Returns\n        -------\n        T : array, shape (n_samples,)\n            The predicted decision function\n        ",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"",is_optional:!1,options:null}]},{name:"_get_param_names",outputs:[],docstring:"Get parameter names for the estimator",inputs:[]},{name:"_preprocess_data",outputs:[],docstring:"\n    Centers data to have mean zero along axis 0. If fit_intercept=False or if\n    the X is a sparse matrix, no centering is done, but normalization can still\n    be applied. The function returns the statistics necessary to reconstruct\n    the input data, which are X_offset, y_offset, X_scale, such that the output\n\n        X = (X - X_offset) / X_scale\n\n    X_scale is the L2 norm of X - X_offset. If sample_weight is not None,\n    then the weighted mean of X and y is zero, and not the mean itself. If\n    return_mean=True, the mean, eventually weighted, is returned, independently\n    of whether X was centered (option used for optimization with sparse data in\n    coordinate_descend).\n\n    This is here because nearly all linear models will want their data to be\n    centered. This function also systematically makes y consistent with X.dtype\n    ",inputs:[]},{name:"_set_intercept",outputs:[],docstring:"Set the intercept_\n        ",inputs:[]},{name:"fit",outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Fit model with coordinate descent.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:null,docstring:"Data",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples,) or (n_samples, n_targets)",docstring:"Target. Will be cast to X's dtype if necessary",is_optional:!1,options:null},{name:"check_input",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"Allow to bypass several input checking. Don't use this parameter unless you know what you do.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"predict",outputs:[{name:"C",returned:!0,param_type:["array"],docstring:"Returns predicted values."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Predict using the linear model",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Samples.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"score",outputs:[{name:"score",returned:!0,param_type:["float"],docstring:"R^2 of self.predict(X) wrt. y."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Returns the coefficient of determination R^2 of the prediction.\n\n        The coefficient R^2 is defined as (1 - u/v), where u is the residual\n        sum of squares ((y_true - y_pred) ** 2).sum() and v is the total\n        sum of squares ((y_true - y_true.mean()) ** 2).sum().\n        The best possible score is 1.0 and it can be negative (because the\n        model can be arbitrarily worse). A constant model that always\n        predicts the expected value of y, disregarding the input features,\n        would get a R^2 score of 0.0.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Test samples. For some estimators this may be a precomputed kernel matrix instead, shape = (n_samples, n_samples_fitted], where n_samples_fitted is the number of samples used in the fitting for the estimator.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",docstring:"True values for X.",is_optional:!1,options:null},{name:"sample_weight",default_value:null,param_type:["array"],expected_shape:"[n_samples], optional",docstring:"Sample weights.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]}],nodes:[]},{name:"Lasso",outputs:[{name:"coef_",returned:!1,param_type:["array"],docstring:"parameter vector (w in the cost function formula)"},{name:"sparse_coef_",returned:!1,param_type:["scipy.sparse.matrix"],docstring:"``sparse_coef_`` is a readonly property derived from ``coef_``"},{name:"intercept_",returned:!1,param_type:["array","float"],docstring:"independent term in decision function."},{name:"n_iter_",returned:!1,param_type:["array","int"],docstring:"number of iterations run by the coordinate descent solver to reach the specified tolerance."}],docstring:"Linear Model trained with L1 prior as regularizer (aka the Lasso)\n\n    The optimization objective for Lasso is::\n\n        (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1\n\n    Technically the Lasso model is optimizing the same objective function as\n    the Elastic Net with ``l1_ratio=1.0`` (no L2 penalty).",inputs:[{name:"alpha",default_value:"1.0",param_type:["float"],expected_shape:null,docstring:"Constant that multiplies the L1 term. Defaults to 1.0. ``alpha = 0`` is equivalent to an ordinary least square, solved by the :class:`LinearRegression` object. For numerical reasons, using ``alpha = 0`` with the ``Lasso`` object is not advised. Given this, you should use the :class:`LinearRegression` object.",is_optional:!0,options:null},{name:"fit_intercept",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"Whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (e.g. data is expected to be already centered).",is_optional:!0,options:null},{name:"normalize",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"This parameter is ignored when ``fit_intercept`` is set to False. If True, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use :class:`sklearn.preprocessing.StandardScaler` before calling ``fit`` on an estimator with ``normalize=False``.",is_optional:!0,options:null},{name:"precompute",default_value:"False",param_type:["bool","array"],expected_shape:null,docstring:"Whether to use a precomputed Gram matrix to speed up calculations. If set to ``'auto'`` let us decide. The Gram matrix can also be passed as argument. For sparse input this option is always ``True`` to preserve sparsity.",is_optional:!0,options:null},{name:"copy_X",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If ``True``, X will be copied; else, it may be overwritten.",is_optional:!0,options:null},{name:"max_iter",default_value:null,param_type:["int"],expected_shape:null,docstring:"The maximum number of iterations",is_optional:!0,options:null},{name:"tol",default_value:null,param_type:["float"],expected_shape:null,docstring:"The tolerance for the optimization: if the updates are smaller than ``tol``, the optimization code checks the dual gap for optimality and continues until it is smaller than ``tol``.",is_optional:!0,options:null},{name:"warm_start",default_value:null,param_type:["bool"],expected_shape:null,docstring:"When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. See :term:`the Glossary <warm_start>`.",is_optional:!0,options:null},{name:"positive",default_value:null,param_type:["bool"],expected_shape:null,docstring:"When set to ``True``, forces the coefficients to be positive.",is_optional:!0,options:null},{name:"selection",default_value:"cyclic",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to 'random') often leads to significantly faster convergence especially when tol is higher than 1e-4.",is_optional:!0,options:["random","cyclic"]}],node_functions:[{name:"__init__",outputs:[],docstring:"None",inputs:[]},{name:"_decision_function",outputs:[{name:"T",returned:!0,param_type:["array"],docstring:"The predicted decision function"}],docstring:"Decision function of the linear model\n\n        Parameters\n        ----------\n        X : numpy array or scipy.sparse matrix of shape (n_samples, n_features)\n\n        Returns\n        -------\n        T : array, shape (n_samples,)\n            The predicted decision function\n        ",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"",is_optional:!1,options:null}]},{name:"_get_param_names",outputs:[],docstring:"Get parameter names for the estimator",inputs:[]},{name:"_preprocess_data",outputs:[],docstring:"\n    Centers data to have mean zero along axis 0. If fit_intercept=False or if\n    the X is a sparse matrix, no centering is done, but normalization can still\n    be applied. The function returns the statistics necessary to reconstruct\n    the input data, which are X_offset, y_offset, X_scale, such that the output\n\n        X = (X - X_offset) / X_scale\n\n    X_scale is the L2 norm of X - X_offset. If sample_weight is not None,\n    then the weighted mean of X and y is zero, and not the mean itself. If\n    return_mean=True, the mean, eventually weighted, is returned, independently\n    of whether X was centered (option used for optimization with sparse data in\n    coordinate_descend).\n\n    This is here because nearly all linear models will want their data to be\n    centered. This function also systematically makes y consistent with X.dtype\n    ",inputs:[]},{name:"_set_intercept",outputs:[],docstring:"Set the intercept_\n        ",inputs:[]},{name:"fit",outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Fit model with coordinate descent.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Data",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples,) or (n_samples, n_targets)",docstring:"Target. Will be cast to X's dtype if necessary",is_optional:!1,options:null},{name:"check_input",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"Allow to bypass several input checking. Don't use this parameter unless you know what you do.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"predict",outputs:[{name:"C",returned:!0,param_type:["array"],docstring:"Returns predicted values."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Predict using the linear model\n\n        Parameters\n        ----------\n        X : array_like or sparse matrix, shape (n_samples, n_features)\n            Samples.\n\n        Returns\n        -------\n        C : array, shape (n_samples,)\n            Returns predicted values.\n        ",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Samples.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"score",outputs:[{name:"score",returned:!0,param_type:["float"],docstring:"R^2 of self.predict(X) wrt. y."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Returns the coefficient of determination R^2 of the prediction.\n\n        The coefficient R^2 is defined as (1 - u/v), where u is the residual\n        sum of squares ((y_true - y_pred) ** 2).sum() and v is the total\n        sum of squares ((y_true - y_true.mean()) ** 2).sum().\n        The best possible score is 1.0 and it can be negative (because the\n        model can be arbitrarily worse). A constant model that always\n        predicts the expected value of y, disregarding the input features,\n        would get a R^2 score of 0.0.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Test samples.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",docstring:"True values for X.",is_optional:!1,options:null},{name:"sample_weight",default_value:null,param_type:["array"],expected_shape:"[n_samples], optional",docstring:"Sample weights.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]}],nodes:[]},{name:"LinearRegression",outputs:[{name:"coef_",returned:!1,param_type:["array"],docstring:"Estimated coefficients for the linear regression problem. If multiple targets are passed during the fit (y 2D), this is a 2D array of shape (n_targets, n_features), while if only one target is passed, this is a 1D array of length n_features."},{name:"intercept_",returned:!1,param_type:["array"],docstring:"Independent term in the linear model."}],docstring:"Ordinary least squares Linear Regression.",inputs:[{name:"fit_intercept",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"whether to calculate the intercept for this model. If set to False, no intercept will be used in calculations (e.g. data is expected to be already centered).",is_optional:!0,options:null},{name:"normalize",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"This parameter is ignored when ``fit_intercept`` is set to False. If True, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use :class:`sklearn.preprocessing.StandardScaler` before calling ``fit`` on an estimator with ``normalize=False``.",is_optional:!0,options:null},{name:"copy_X",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If True, X will be copied; else, it may be overwritten.",is_optional:!0,options:null},{name:"n_jobs",default_value:"None",param_type:["int",null],expected_shape:null,docstring:"The number of jobs to use for the computation. This will only provide speedup for n_targets > 1 and sufficient large problems. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.",is_optional:!0,options:null}],node_functions:[{name:"__init__",outputs:[],docstring:"None",inputs:[]},{name:"_decision_function",outputs:[],docstring:"None",inputs:[]},{name:"_get_param_names",outputs:[],docstring:"Get parameter names for the estimator",inputs:[]},{name:"_preprocess_data",outputs:[],docstring:"\n    Centers data to have mean zero along axis 0. If fit_intercept=False or if\n    the X is a sparse matrix, no centering is done, but normalization can still\n    be applied. The function returns the statistics necessary to reconstruct\n    the input data, which are X_offset, y_offset, X_scale, such that the output\n\n        X = (X - X_offset) / X_scale\n\n    X_scale is the L2 norm of X - X_offset. If sample_weight is not None,\n    then the weighted mean of X and y is zero, and not the mean itself. If\n    return_mean=True, the mean, eventually weighted, is returned, independently\n    of whether X was centered (option used for optimization with sparse data in\n    coordinate_descend).\n\n    This is here because nearly all linear models will want their data to be\n    centered. This function also systematically makes y consistent with X.dtype\n    ",inputs:[]},{name:"_set_intercept",outputs:[],docstring:"Set the intercept_\n        ",inputs:[]},{name:"fit",outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Fit linear model",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Training data",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_targets)",docstring:"Target values. Will be cast to X's dtype if necessary",is_optional:!1,options:null},{name:"sample_weight",default_value:null,param_type:["array"],expected_shape:"[n_samples]",docstring:"Individual weights for each sample  .. versionadded:: 0.17    parameter *sample_weight* support to LinearRegression.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"predict",outputs:[{name:"C",returned:!0,param_type:["array"],docstring:"Returns predicted values."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Predict using the linear model",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Samples.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"score",outputs:[{name:"score",returned:!0,param_type:["float"],docstring:"R^2 of self.predict(X) wrt. y."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Returns the coefficient of determination R^2 of the prediction.\n\n        The coefficient R^2 is defined as (1 - u/v), where u is the residual\n        sum of squares ((y_true - y_pred) ** 2).sum() and v is the total\n        sum of squares ((y_true - y_true.mean()) ** 2).sum().\n        The best possible score is 1.0 and it can be negative (because the\n        model can be arbitrarily worse). A constant model that always\n        predicts the expected value of y, disregarding the input features,\n        would get a R^2 score of 0.0.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Test samples. For some estimators this may be a precomputed kernel matrix instead, shape = (n_samples, n_samples_fitted], where n_samples_fitted is the number of samples used in the fitting for the estimator.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",docstring:"True values for X.",is_optional:!1,options:null},{name:"sample_weight",default_value:null,param_type:["array"],expected_shape:"[n_samples], optional",docstring:"Sample weights.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]}],nodes:[]},{name:"LogisticRegression",outputs:[{name:"classes_",returned:!1,param_type:["array"],docstring:"A list of class labels known to the classifier."},{name:"coef_",returned:!1,param_type:["array"],docstring:"Coefficient of the features in the decision function.  `coef_` is of shape (1, n_features) when the given problem is binary. In particular, when `multi_class='multinomial'`, `coef_` corresponds to outcome 1 (True) and `-coef_` corresponds to outcome 0 (False)."},{name:"intercept_",returned:!1,param_type:["array"],docstring:"Intercept (a.k.a. bias) added to the decision function.  If `fit_intercept` is set to False, the intercept is set to zero. `intercept_` is of shape (1,) when the given problem is binary. In particular, when `multi_class='multinomial'`, `intercept_` corresponds to outcome 1 (True) and `-intercept_` corresponds to outcome 0 (False)."},{name:"n_iter_",returned:!1,param_type:["array"],docstring:"Actual number of iterations for all classes. If binary or multinomial, it returns only 1 element. For liblinear solver, only the maximum number of iteration across all classes is given.  .. versionchanged:: 0.20      In SciPy <= 1.0.0 the number of lbfgs iterations may exceed     ``max_iter``. ``n_iter_`` will now report at most ``max_iter``."}],docstring:"Logistic Regression (aka logit, MaxEnt) classifier.\n\n    In the multiclass case, the training algorithm uses the one-vs-rest (OvR)\n    scheme if the 'multi_class' option is set to 'ovr', and uses the cross-\n    entropy loss if the 'multi_class' option is set to 'multinomial'.\n    (Currently the 'multinomial' option is supported only by the 'lbfgs',\n    'sag' and 'newton-cg' solvers.)\n\n    This class implements regularized logistic regression using the\n    'liblinear' library, 'newton-cg', 'sag' and 'lbfgs' solvers. It can handle\n    both dense and sparse input. Use C-ordered arrays or CSR matrices\n    containing 64-bit floats for optimal performance; any other input format\n    will be converted (and copied).\n\n    The 'newton-cg', 'sag', and 'lbfgs' solvers support only L2 regularization\n    with primal formulation. The 'liblinear' solver supports both L1 and L2\n    regularization, with a dual formulation only for the L2 penalty.",inputs:[{name:"penalty",default_value:"l2",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"Used to specify the norm used in the penalization. The 'newton-cg', 'sag' and 'lbfgs' solvers support only l2 penalties.  .. versionadded:: 0.19    l1 penalty with SAGA solver (allowing 'multinomial' + L1)",is_optional:!0,options:["l1","l2","elasticnet","none"]},{name:"dual",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"Dual or primal formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=False when n_samples > n_features.",is_optional:!0,options:null},{name:"tol",default_value:"1e-4",param_type:["float"],expected_shape:null,docstring:"Tolerance for stopping criteria.",is_optional:!0,options:null},{name:"C",default_value:"1.0",param_type:["float"],expected_shape:null,docstring:"Inverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.",is_optional:!0,options:null},{name:"fit_intercept",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"Specifies if a constant (a.k.a. bias or intercept) should be added to the decision function.",is_optional:!0,options:null},{name:"intercept_scaling",default_value:"1.",param_type:["float"],expected_shape:null,docstring:"Useful only when the solver 'liblinear' is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a \"synthetic\" feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes ``intercept_scaling * synthetic_feature_weight``.  Note! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased.",is_optional:!0,options:null},{name:"class_weight",default_value:"None",param_type:["dict","str",null],expected_shape:null,docstring:'Weights associated with classes in the form ``{class_label: weight}``. If not given, all classes are supposed to have weight one.  The "balanced" mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as ``n_samples / (n_classes * np.bincount(y))``.  Note that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified.',is_optional:!0,options:null},{name:"solver",default_value:"liblinear.",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"Algorithm to use in the optimization problem.  - For small datasets, 'liblinear' is a good choice, whereas 'sag' and   'saga' are faster for large ones. - For multiclass problems, only 'newton-cg', 'sag', 'saga' and 'lbfgs'   handle multinomial loss; 'liblinear' is limited to one-versus-rest   schemes. - 'newton-cg', 'lbfgs' and 'sag' only handle L2 penalty, whereas   'liblinear' and 'saga' handle L1 penalty.  Note that 'sag' and 'saga' fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from sklearn.preprocessing.",is_optional:!0,options:["newton-cg","lbfgs","liblinear","sag","saga'}"]},{name:"max_iter",default_value:"100",param_type:["int"],expected_shape:null,docstring:"Useful only for the newton-cg, sag and lbfgs solvers. Maximum number of iterations taken for the solvers to converge.",is_optional:!0,options:null},{name:"multi_class",default_value:"ovr",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"If the option chosen is 'ovr', then a binary problem is fit for each label. For 'multinomial' the loss minimised is the multinomial loss fit across the entire probability distribution, *even when the data is binary*. 'multinomial' is unavailable when solver='liblinear'. 'auto' selects 'ovr' if the data is binary, or if solver='liblinear', and otherwise selects 'multinomial'.",is_optional:!0,options:["ovr","multinomial","auto"]},{name:"verbose",default_value:"0",param_type:["int"],expected_shape:null,docstring:"For the liblinear and lbfgs solvers set verbose to any positive number for verbosity.",is_optional:!0,options:null},{name:"warm_start",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"When set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. Useless for liblinear solver.",is_optional:!0,options:null},{name:"n_jobs",default_value:"None",param_type:["int",null],expected_shape:null,docstring:"Number of CPU cores used when parallelizing over classes if multi_class='ovr'\". This parameter is ignored when the ``solver`` is set to 'liblinear' regardless of whether 'multi_class' is specified or not. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.",is_optional:!0,options:null}],node_functions:[{name:"__init__",outputs:[],docstring:"None",inputs:[]},{name:"_get_param_names",outputs:[],docstring:"Get parameter names for the estimator",inputs:[]},{name:"_predict_proba_lr",outputs:[],docstring:"Probability estimation for OvR logistic regression.\n\n        Positive class probabilities are computed as\n        1. / (1. + np.exp(-self.decision_function(X)));\n        multiclass is handled by normalizing that over all classes.\n        ",inputs:[]},{name:"decision_function",outputs:[{name:"array, shape=(n_samples,) if n_classes == 2 else (n_samples, n_classes)",returned:!0,param_type:[null],docstring:"Confidence scores per (sample, class) combination. In the binary case, confidence score for self.classes_[1] where >0 means this class would be predicted."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Predict confidence scores for samples.\n\n        The confidence score for a sample is the signed distance of that\n        sample to the hyperplane.\n\n        Parameters\n        ----------\n        X : array_like or sparse matrix, shape (n_samples, n_features)\n            Samples.\n\n        Returns\n        -------\n        array, shape=(n_samples,) if n_classes == 2 else (n_samples, n_classes)\n            Confidence scores per (sample, class) combination. In the binary\n            case, confidence score for self.classes_[1] where >0 means this\n            class would be predicted.\n        ",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Samples.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"fit",outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Fit the model according to the given training data.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Training vector, where n_samples is the number of samples and n_features is the number of features.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples,)",docstring:"Target vector relative to X.",is_optional:!1,options:null},{name:"sample_weight",default_value:null,param_type:["array"],expected_shape:"(n_samples,) optional",docstring:"Array of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"predict",outputs:[{name:"C",returned:!0,param_type:["array"],docstring:"Predicted class label per sample."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Predict class labels for samples in X.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Samples.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"predict_log_proba",outputs:[{name:"T",returned:!0,param_type:["array"],docstring:"Returns the log-probability of the sample for each class in the model, where classes are ordered as they are in ``classes_``."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Log of probability estimates.\n\n        The returned estimates for all classes are ordered by the\n        label of classes.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"[n_samples, n_features]",docstring:"",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"predict_proba",outputs:[{name:"T",returned:!0,param_type:["array"],docstring:"Returns the probability of the sample for each class in the model, where classes are ordered as they are in ``classes_``."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:'Probability estimates.\n\n        The returned estimates for all classes are ordered by the\n        label of classes.\n\n        For a multi_class problem, if multi_class is set to be "multinomial"\n        the softmax function is used to find the predicted probability of\n        each class.\n        Else use a one-vs-rest approach, i.e calculate the probability\n        of each class assuming it to be positive using the logistic function.\n        and normalize these values across all the classes.',inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"[n_samples, n_features]",docstring:"",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"score",outputs:[{name:"score",returned:!0,param_type:["float"],docstring:"Mean accuracy of self.predict(X) wrt. y."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Returns the mean accuracy on the given test data and labels.\n\n        In multi-label classification, this is the subset accuracy\n        which is a harsh metric since you require for each sample that\n        each label set be correctly predicted.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Test samples.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",docstring:"True labels for X.",is_optional:!1,options:null},{name:"sample_weight",default_value:null,param_type:["array"],expected_shape:"[n_samples]",docstring:"Sample weights.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]}],nodes:[]},{name:"Ridge",outputs:[{name:"coef_",returned:!1,param_type:["array"],docstring:"Weight vector(s)."},{name:"intercept_",returned:!1,param_type:["LIST_VALID_OPTIONS","array","float"],docstring:"Independent term in decision function. Set to 0.0 if ``fit_intercept = False``."},{name:"n_iter_",returned:!1,param_type:["array",null],docstring:"Actual number of iterations for each target. Available only for sag and lsqr solvers. Other solvers will return None.  .. versionadded:: 0.17"}],docstring:"Linear least squares with l2 regularization.\n\n    Minimizes the objective function::\n\n    ||y - Xw||^2_2 + alpha * ||w||^2_2\n\n    This model solves a regression model where the loss function is\n    the linear least squares function and regularization is given by\n    the l2-norm. Also known as Ridge Regression or Tikhonov regularization.\n    This estimator has built-in support for multi-variate regression\n    (i.e., when y is a 2d-array of shape [n_samples, n_targets]).",inputs:[{name:"alpha",default_value:null,param_type:["array","float"],expected_shape:"(n_targets)",docstring:"Regularization strength; must be a positive float. Regularization improves the conditioning of the problem and reduces the variance of the estimates. Larger values specify stronger regularization. Alpha corresponds to ``C^-1`` in other linear models such as LogisticRegression or LinearSVC. If an array is passed, penalties are assumed to be specific to the targets. Hence they must correspond in number.",is_optional:!1,options:null},{name:"fit_intercept",default_value:null,param_type:["bool"],expected_shape:null,docstring:"Whether to calculate the intercept for this model. If set to false, no intercept will be used in calculations (e.g. data is expected to be already centered).",is_optional:!1,options:null},{name:"normalize",default_value:"False",param_type:["bool"],expected_shape:null,docstring:"This parameter is ignored when ``fit_intercept`` is set to False. If True, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use :class:`sklearn.preprocessing.StandardScaler` before calling ``fit`` on an estimator with ``normalize=False``.",is_optional:!0,options:null},{name:"copy_X",default_value:"True",param_type:["bool"],expected_shape:null,docstring:"If True, X will be copied; else, it may be overwritten.",is_optional:!0,options:null},{name:"max_iter",default_value:null,param_type:["int"],expected_shape:null,docstring:"Maximum number of iterations for conjugate gradient solver. For 'sparse_cg' and 'lsqr' solvers, the default value is determined by scipy.sparse.linalg. For 'sag' solver, the default value is 1000.",is_optional:!0,options:null},{name:"tol",default_value:null,param_type:["float"],expected_shape:null,docstring:"Precision of the solution.",is_optional:!1,options:null},{name:"solver",default_value:null,param_type:["LIST_VALID_OPTIONS"],expected_shape:null,docstring:"Solver to use in the computational routines:  - 'auto' chooses the solver automatically based on the type of data.  - 'svd' uses a Singular Value Decomposition of X to compute the Ridge   coefficients. More stable for singular matrices than   'cholesky'.  - 'cholesky' uses the standard scipy.linalg.solve function to   obtain a closed-form solution.  - 'sparse_cg' uses a conjugate gradient solver. As an iterative algorithm, this solver is   more appropriate than 'cholesky' for large-scale data   (possibility to set `tol` and `max_iter`).  - 'lsqr' uses a dedicated regularized least-squares routine. It is the fastest and uses an iterative   procedure.  - 'sag' uses a Stochastic Average Gradient descent, and 'saga' uses   its improved, unbiased version named SAGA. Both methods also use an   iterative procedure, and are often faster than other solvers when   both n_samples and n_features are large. Note that 'sag' and   'saga' fast convergence is only guaranteed on features with   approximately the same scale. You can preprocess the data with a   scaler from sklearn.preprocessing.",is_optional:!1,options:["auto","svd","cholesky","lsqr","sparse_cg","sag","saga"]}],node_functions:[{name:"__init__",outputs:[],docstring:"None",inputs:[]},{name:"_decision_function",outputs:[],docstring:"None",inputs:[]},{name:"_get_param_names",outputs:[],docstring:"Get parameter names for the estimator",inputs:[]},{name:"_preprocess_data",outputs:[],docstring:"\n    Centers data to have mean zero along axis 0. If fit_intercept=False or if\n    the X is a sparse matrix, no centering is done, but normalization can still\n    be applied. The function returns the statistics necessary to reconstruct\n    the input data, which are X_offset, y_offset, X_scale, such that the output\n\n        X = (X - X_offset) / X_scale\n\n    X_scale is the L2 norm of X - X_offset. If sample_weight is not None,\n    then the weighted mean of X and y is zero, and not the mean itself. If\n    return_mean=True, the mean, eventually weighted, is returned, independently\n    of whether X was centered (option used for optimization with sparse data in\n    coordinate_descend).\n\n    This is here because nearly all linear models will want their data to be\n    centered. This function also systematically makes y consistent with X.dtype\n    ",inputs:[]},{name:"_set_intercept",outputs:[],docstring:"Set the intercept_\n        ",inputs:[]},{name:"fit",outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Fit Ridge regression model",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"[n_samples, n_features]",docstring:"Training data",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"[n_samples] or [n_samples, n_targets]",docstring:"Target values",is_optional:!1,options:null},{name:"sample_weight",default_value:null,param_type:["array","float"],expected_shape:"[n_samples]",docstring:"Individual weights for each sample",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"predict",outputs:[{name:"C",returned:!0,param_type:["array"],docstring:"Returns predicted values."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Predict using the linear model",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Samples.",is_optional:!1,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]},{name:"score",outputs:[{name:"score",returned:!0,param_type:["float"],docstring:"R^2 of self.predict(X) wrt. y."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],docstring:"Returns the coefficient of determination R^2 of the prediction.\n\n        The coefficient R^2 is defined as (1 - u/v), where u is the residual\n        sum of squares ((y_true - y_pred) ** 2).sum() and v is the total\n        sum of squares ((y_true - y_true.mean()) ** 2).sum().\n        The best possible score is 1.0 and it can be negative (because the\n        model can be arbitrarily worse). A constant model that always\n        predicts the expected value of y, disregarding the input features,\n        would get a R^2 score of 0.0.",inputs:[{name:"X",default_value:null,param_type:["array"],expected_shape:"(n_samples, n_features)",docstring:"Test samples.",is_optional:!1,options:null},{name:"y",default_value:null,param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",docstring:"True values for X.",is_optional:!1,options:null},{name:"sample_weight",default_value:null,param_type:["array"],expected_shape:"[n_samples], optional",docstring:"Sample weights.",is_optional:!0,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}]}],nodes:[]}],library:"sklearn"},Am={name:"chemml.models",docstring:"",inputs:[],outputs:[],node_functions:[],nodes:[{name:"MLP",docstring:"\n    Class associated with Multi-Layer Perceptron (Neural Network)",inputs:[{name:"nhidden",docstring:"The number of hidden layers in the neural network (excluding input and output)",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"1",options:null},{name:"nneurons",docstring:"The number of nodes in each hidden layer. Must be of same length as nhidden. default: [100] * nhidden",param_type:["list"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"activations",docstring:"The activation type for each hidden layer. Must be of same length as nhidden. Refer https://keras.io/activations/ for list of valid activations. default: ['sigmoid'] * nhidden",param_type:["list"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"nepochs",docstring:"Number of training epochs.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"100",options:null},{name:"batch_size",docstring:"Number of training samples in mini-batch",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"100",options:null},{name:"loss",docstring:"Type of loss used to train the neural network. Refer https://keras.io/losses/ for list of valid losses",param_type:["str"],expected_shape:null,is_optional:!1,default_value:"mean_squared_error",options:["mean_squared_error","mean_absolute_error","squared_hinge","hinge","categorical_hinge","categorical_crossentropy","binary_crossentropy","kullback_liebler_divergence"]},{name:"regression",docstring:"Decides whether we are training for regression or classification task",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"nclasses",docstring:"Number of classes labels needs to be specified if regression is False",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"None",options:null}],outputs:[],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"fit",docstring:"\n        Train the MLP for training data X and targets y",inputs:[{name:"X",docstring:"Training data",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Training targets",param_type:["array"],expected_shape:"[n_samples,]",is_optional:!1,default_value:null,options:null}],outputs:[]},{name:"predict",docstring:"\n        Return prediction for test data X",inputs:[{name:"X",docstring:"Testing data",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null}],outputs:[{name:"",docstring:"Predicted value from model",param_type:["float"],returned:!0}]},{name:"score",docstring:"\n        Predict results for test data X and compare with true targets y. Returns root mean square error if regression,\n        accuracy if classification\n\n        Parameters\n        ----------\n        X: array_like, shape=[n_samples, n_features]\n            Test data\n\n        y: array_like, shape=[n_samples,]\n            True targets\n\n        Returns\n        -------\n        float\n            root mean square error if regression, accuracy if classification\n        ",inputs:[{name:"X",docstring:"Test data",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"True targets",param_type:["array"],expected_shape:"[n_samples,]",is_optional:!1,default_value:null,options:null}],outputs:[{name:"score",docstring:"root mean square error if regression, accuracy if classification",param_type:["float"],returned:!0}]}],nodes:[]},{name:"OrganicLorentzLorenz",docstring:"\n    A machine learning model for Lorentz-Lorenz (LL) estimates of refractive index.\n    The model predicts refractive index, polarizability, and density of an organic molecule using its\n    SMILES representation.\n\n    The model is trained on 100K small organic molecules with their polarizabilities from DFT calculations, densities from\n    molecular dynamics simulations, and refractive index by feeding calculated polarizabilities and densities into the\n    LL model.\n\n    The model is a fully connected artificial neural network with 3 hidden layers. The number of neurons per layers from\n    input layer to the output layer are as follow: 1024 --\x3e 128 --\x3e 64 --\x3e 32 --\x3e [1, 1, 1].\n    ",inputs:[],outputs:[],node_functions:[{name:"_OrganicLorentzLorenz__represent",docstring:"None",inputs:[],outputs:[]},{name:"get_hidden_layer",docstring:"\n        This functions return the first hidden layer of the model.",inputs:[{name:"X",docstring:"If 2D array, must be with 1024 dimension and numerical type. It is recommended to be Morgan fingerprint representation of the molecules. If 1D array, must be an array of `str` type, each element represents a molecule in the SMILES format.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"id",docstring:"This is the id of hidden layers. It can be any of 1, 2, or 3 for the first, second, or third hidden layer, respectively.",param_type:["int"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"layer_output",docstring:"The array of shape (length_of_X, 128) as the outputs of the first hidden layer (id=1). The array of shape (length_of_X, 64) as the outputs of the first hidden layer (id=2). The array of shape (length_of_X, 32) as the outputs of the first hidden layer (id=3).",param_type:["array"],returned:!0}]},{name:"load",docstring:"This function loads the Keras model. The model consists of 3 hidden layers and more than 140K parameters.",inputs:[],outputs:[]},{name:"predict",docstring:"After loading the model, this function predicts refractive index, polarizability, and density of the entery.",inputs:[{name:"smiles",docstring:"The SMILES representaion of a molecule.",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"pprint",docstring:"If True, a short description of the predicted properties will be printed out.",param_type:["bool"],expected_shape:null,is_optional:!1,default_value:"True",options:null}],outputs:[{name:"predictions",docstring:"includes estimates of refractive index, polarizability, and density, respectively.",param_type:["tuple"],returned:!0}]},{name:"train",docstring:"\n        This function allows the user to retrain the model on a given data set for some further steps.\n        Thus, all the parameters you are able to pass to a keras model's compile or fit methods can be passed to this\n        function as well.",inputs:[{name:"X",docstring:"If 2D array, must be with 1024 dimension and numerical type. It is recommended to be Morgan fingerprint representation of the molecules. If 1D array, must be an array of `str` type, each element represents a molecule in the SMILES format. If dataframe, it can be a 2D frame with one columnd of SMILES or 1024 columns of features.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"Y",docstring:"a list of three numpy arrays for refractive index, polarizability, and density, respectively. The length of arrays must be same as the length of X. If dataframe, it must be a 2D frame with 3 columns, each for one of the properties.",param_type:["array","list"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"scale: bool, optional (default: True)",docstring:"If True the X and Y will be scaled in the same fashion as the original traning process (recommended).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[]}],nodes:[]}],library:"chemml",module:"models"},Em={inputs:[],module:"decomposition",library:"sklearn",name:"sklearn.decomposition",nodes:[{inputs:[{is_optional:!1,param_type:["int",null],name:"n_components",docstring:"Dimensionality of latent space, the number of components of ``X`` that are obtained after ``transform``. If None, n_components is set to the number of features.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["float"],name:"tol",docstring:"Stopping tolerance for EM algorithm.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["bool"],name:"copy",docstring:"Whether to make a copy of X. If ``False``, the input X gets overwritten during fitting.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["int"],name:"max_iter",docstring:"Maximum number of iterations.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["LIST_VALID_OPTIONS","array",null],name:"noise_variance_init",docstring:"The initial guess of the noise variance for each feature. If None, it defaults to np.ones(n_features)",options:["None "," array, shape=(n_features,)"],default_value:null,expected_shape:"(n_features,)"},{is_optional:!1,param_type:["LIST_VALID_OPTIONS"],name:"svd_method",docstring:"Which SVD method to use. If 'lapack' use standard SVD from scipy.linalg, if 'randomized' use fast ``randomized_svd`` function. Defaults to 'randomized'. For most applications 'randomized' will be sufficiently precise while providing significant speed gains. Accuracy can also be improved by setting higher values for `iterated_power`. If this is not sufficient, for maximum precision you should choose 'lapack'.",options:["lapack","randomized"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["int"],name:"iterated_power",docstring:"Number of iterations for the power method. 3 by default. Only used if ``svd_method`` equals 'randomized'",options:null,default_value:"3",expected_shape:null}],name:"FactorAnalysis",nodes:[],node_functions:[{inputs:[],outputs:[],name:"__init__",docstring:"None"},{inputs:[],outputs:[],name:"_get_param_names",docstring:"Get parameter names for the estimator"},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Training data.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!1,param_type:[null],name:"y",docstring:"",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"fit",docstring:"Fit the FactorAnalysis model to X using EM\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Training data.\n\n        y : Ignored\n\n        Returns\n        -------\n        self\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Training set.",options:null,default_value:null,expected_shape:"[n_samples, n_features]"},{is_optional:!1,param_type:["array"],name:"y",docstring:"Target values.",options:null,default_value:null,expected_shape:"[n_samples]"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"X_new",docstring:"Transformed array."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"fit_transform",docstring:"Fit to data, then transform it.\n\n        Fits transformer to X and y with optional parameters fit_params\n        and returns a transformed version of X.\n\n        Parameters\n        ----------\n        X : numpy array of shape [n_samples, n_features]\n            Training set.\n\n        y : numpy array of shape [n_samples]\n            Target values.\n\n        Returns\n        -------\n        X_new : numpy array of shape [n_samples, n_features_new]\n            Transformed array.\n\n        "},{inputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"cov",docstring:"Estimated covariance of data."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"get_covariance",docstring:"Compute data covariance with the FactorAnalysis model.\n\n        ``cov = components_.T * components_ + diag(noise_variance)``\n\n        Returns\n        -------\n        cov : array, shape (n_features, n_features)\n            Estimated covariance of data.\n        "},{inputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"precision",docstring:"Estimated precision of data."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"get_precision",docstring:"Compute data precision matrix with the FactorAnalysis model.\n\n        Returns\n        -------\n        precision : array, shape (n_features, n_features)\n            Estimated precision of data.\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"The data",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!0,param_type:[null],name:"y",docstring:"",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["float"],name:"ll",docstring:"Average log-likelihood of the samples under the current model"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"score",docstring:"Compute the average log-likelihood of the samples\n\n        Parameters\n        ----------\n        X : array, shape (n_samples, n_features)\n            The data\n\n        y : Ignored\n\n        Returns\n        -------\n        ll : float\n            Average log-likelihood of the samples under the current model\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"The data",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"ll",docstring:"Log-likelihood of each sample under the current model"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"score_samples",docstring:"Compute the log-likelihood of each sample\n\n        Parameters\n        ----------\n        X : array, shape (n_samples, n_features)\n            The data\n\n        Returns\n        -------\n        ll : array, shape (n_samples,)\n            Log-likelihood of each sample under the current model\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Training data.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"X_new",docstring:"The latent variables of X."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"transform",docstring:"Apply dimensionality reduction to X using the model.\n\n        Compute the expected mean of the latent variables.\n        See Barber, 21.2.33 (or Bishop, 12.66).\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Training data.\n\n        Returns\n        -------\n        X_new : array-like, shape (n_samples, n_components)\n            The latent variables of X.\n        "}],docstring:"Factor Analysis (FA)\n\n    A simple linear generative model with Gaussian latent variables.\n\n    The observations are assumed to be caused by a linear transformation of\n    lower dimensional latent factors and added Gaussian noise.\n    Without loss of generality the factors are distributed according to a\n    Gaussian with zero mean and unit covariance. The noise is also zero mean\n    and has an arbitrary diagonal covariance matrix.\n\n    If we would restrict the model further, by assuming that the Gaussian\n    noise is even isotropic (all diagonal entries are the same) we would obtain\n    :class:`PPCA`.\n\n    FactorAnalysis performs a maximum likelihood estimate of the so-called\n    `loading` matrix, the transformation of the latent variables to the\n    observed ones, using expectation-maximization (EM).\n\n    Read more in the :ref:`User Guide <FA>`.\n\n    Parameters\n    ----------\n    n_components : int | None\n        Dimensionality of latent space, the number of components\n        of ``X`` that are obtained after ``transform``.\n        If None, n_components is set to the number of features.\n\n    tol : float\n        Stopping tolerance for EM algorithm.\n\n    copy : bool\n        Whether to make a copy of X. If ``False``, the input X gets overwritten\n        during fitting.\n\n    max_iter : int\n        Maximum number of iterations.\n\n    noise_variance_init : None | array, shape=(n_features,)\n        The initial guess of the noise variance for each feature.\n        If None, it defaults to np.ones(n_features)\n\n    svd_method : {'lapack', 'randomized'}\n        Which SVD method to use. If 'lapack' use standard SVD from\n        scipy.linalg, if 'randomized' use fast ``randomized_svd`` function.\n        Defaults to 'randomized'. For most applications 'randomized' will\n        be sufficiently precise while providing significant speed gains.\n        Accuracy can also be improved by setting higher values for\n        `iterated_power`. If this is not sufficient, for maximum precision\n        you should choose 'lapack'.\n\n    iterated_power : int, optional\n        Number of iterations for the power method. 3 by default. Only used\n        if ``svd_method`` equals 'randomized'\n\n    random_state : int, RandomState instance or None, optional (default=0)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`. Only used when ``svd_method`` equals 'randomized'.\n\n    Attributes\n    ----------\n    components_ : array, [n_components, n_features]\n        Components with maximum variance.\n\n    loglike_ : list, [n_iterations]\n        The log likelihood at each iteration.\n\n    noise_variance_ : array, shape=(n_features,)\n        The estimated noise variance for each feature.\n\n    n_iter_ : int\n        Number of iterations run.\n\n    Examples\n    --------\n    >>> from sklearn.datasets import load_digits\n    >>> from sklearn.decomposition import FactorAnalysis\n    >>> X, _ = load_digits(return_X_y=True)\n    >>> transformer = FactorAnalysis(n_components=7, random_state=0)\n    >>> X_transformed = transformer.fit_transform(X)\n    >>> X_transformed.shape\n    (1797, 7)\n\n    References\n    ----------\n    .. David Barber, Bayesian Reasoning and Machine Learning,\n        Algorithm 21.1\n\n    .. Christopher M. Bishop: Pattern Recognition and Machine Learning,\n        Chapter 12.2.4\n\n    See also\n    --------\n    PCA: Principal component analysis is also a latent linear variable model\n        which however assumes equal noise variance for each feature.\n        This extra assumption makes probabilistic PCA faster as it can be\n        computed in closed form.\n    FastICA: Independent component analysis, a latent variable model with\n        non-Gaussian latent variables.\n    ",outputs:[{returned:!1,param_type:["array"],name:"components_",docstring:"Components with maximum variance."},{returned:!1,param_type:["list"],name:"loglike_",docstring:"The log likelihood at each iteration."},{returned:!1,param_type:["array"],name:"noise_variance_",docstring:"The estimated noise variance for each feature."},{returned:!1,param_type:["int"],name:"n_iter_",docstring:"Number of iterations run."}]},{inputs:[{is_optional:!1,param_type:["int","float","str",null],name:"n_components",docstring:"Number of components to keep. if n_components is not set all components are kept::      n_components == min(n_samples, n_features)  If ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's MLE is used to guess the dimension. Use of ``n_components == 'mle'`` will interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.  If ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the number of components such that the amount of variance that needs to be explained is greater than the percentage specified by n_components.  If ``svd_solver == 'arpack'``, the number of components must be strictly less than the minimum of n_features and n_samples.  Hence, the None case results in::      n_components == min(n_samples, n_features) - 1",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["bool"],name:"copy",docstring:"If False, data passed to fit are overwritten and running fit(X).transform(X) will not yield the expected results, use fit_transform(X) instead.",options:null,default_value:"True",expected_shape:null},{is_optional:!0,param_type:["bool"],name:"whiten",docstring:"When True (False by default) the `components_` vectors are multiplied by the square root of n_samples and then divided by the singular values to ensure uncorrelated outputs with unit component-wise variances.  Whitening will remove some information from the transformed signal (the relative variance scales of the components) but can sometime improve the predictive accuracy of the downstream estimators by making their data respect some hard-wired assumptions.",options:null,default_value:"False",expected_shape:null},{is_optional:!1,param_type:["LIST_VALID_OPTIONS"],name:"svd_solver",docstring:"auto :     the solver is selected by a default policy based on `X.shape` and     `n_components`: if the input data is larger than 500x500 and the     number of components to extract is lower than 80% of the smallest     dimension of the data, then the more efficient 'randomized'     method is enabled. Otherwise the exact full SVD is computed and     optionally truncated afterwards. full :     run exact full SVD calling the standard LAPACK solver via     `scipy.linalg.svd` and select the components by postprocessing arpack :     run SVD truncated to n_components calling ARPACK solver via     `scipy.sparse.linalg.svds`. It requires strictly     0 < n_components < min(X.shape) randomized :     run randomized SVD by the method of Halko et al.  .. versionadded:: 0.18.0",options:["auto","full","arpack","randomized"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["float"],name:"tol",docstring:"Tolerance for singular values computed by svd_solver == 'arpack'.  .. versionadded:: 0.18.0",options:null,default_value:".0",expected_shape:null},{is_optional:!0,param_type:["int"],name:"iterated_power",docstring:"Number of iterations for the power method computed by svd_solver == 'randomized'.  .. versionadded:: 0.18.0",options:null,default_value:"auto",expected_shape:null}],name:"PCA",nodes:[],node_functions:[{inputs:[],outputs:[],name:"__init__",docstring:"None"},{inputs:[],outputs:[],name:"_fit",docstring:"Dispatch to the right submethod depending on the chosen solver."},{inputs:[],outputs:[],name:"_fit_full",docstring:"Fit the model by computing full SVD on X"},{inputs:[],outputs:[],name:"_fit_truncated",docstring:"Fit the model by computing truncated SVD (by ARPACK or randomized)\n        on X\n        "},{inputs:[],outputs:[],name:"_get_param_names",docstring:"Get parameter names for the estimator"},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Training data, where n_samples is the number of samples and n_features is the number of features.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!0,param_type:[null],name:"y",docstring:"Ignored",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"fit",docstring:"Fit the model with X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Training data, where n_samples is the number of samples\n            and n_features is the number of features.\n\n        y : Ignored\n\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Training data, where n_samples is the number of samples and n_features is the number of features.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!0,param_type:[null],name:"y",docstring:"Ignored",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"X_new",docstring:""},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"fit_transform",docstring:"Fit the model with X and apply the dimensionality reduction on X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            Training data, where n_samples is the number of samples\n            and n_features is the number of features.\n\n        y : Ignored\n\n        Returns\n        -------\n        X_new : array-like, shape (n_samples, n_components)\n\n        "},{inputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"cov",docstring:"Estimated covariance of data."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"get_covariance",docstring:"Compute data covariance with the generative model.\n\n        ``cov = components_.T * S**2 * components_ + sigma2 * eye(n_features)``\n        where  S**2 contains the explained variances, and sigma2 contains the\n        noise variances.\n\n        Returns\n        -------\n        cov : array, shape=(n_features, n_features)\n            Estimated covariance of data.\n        "},{inputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"precision",docstring:"Estimated precision of data."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"get_precision",docstring:"Compute data precision matrix with the generative model.\n\n        Equals the inverse of the covariance but computed with\n        the matrix inversion lemma for efficiency.\n\n        Returns\n        -------\n        precision : array, shape=(n_features, n_features)\n            Estimated precision of data.\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"New data, where n_samples is the number of samples and n_components is the number of components.",options:null,default_value:null,expected_shape:"(n_samples, n_components)"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:[null],name:"X_original array-like, shape (n_samples, n_features)",docstring:""},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"inverse_transform",docstring:"Transform data back to its original space.\n\n        In other words, return an input X_original whose transform would be X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_components)\n            New data, where n_samples is the number of samples\n            and n_components is the number of components.\n\n        Returns\n        -------\n        X_original array-like, shape (n_samples, n_features)\n\n        Notes\n        -----\n        If whitening is enabled, inverse_transform will compute the\n        exact inverse operation, which includes reversing whitening.\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"The data.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!0,param_type:[null],name:"y",docstring:"Ignored",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["float"],name:"ll",docstring:"Average log-likelihood of the samples under the current model"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"score",docstring:'Return the average log-likelihood of all samples.\n\n        See. "Pattern Recognition and Machine Learning"\n        by C. Bishop, 12.2.1 p. 574\n        or http://www.miketipping.com/papers/met-mppca.pdf\n\n        Parameters\n        ----------\n        X : array, shape(n_samples, n_features)\n            The data.\n\n        y : Ignored\n\n        Returns\n        -------\n        ll : float\n            Average log-likelihood of the samples under the current model\n        '},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"The data.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"ll",docstring:"Log-likelihood of each sample under the current model"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"score_samples",docstring:'Return the log-likelihood of each sample.\n\n        See. "Pattern Recognition and Machine Learning"\n        by C. Bishop, 12.2.1 p. 574\n        or http://www.miketipping.com/papers/met-mppca.pdf\n\n        Parameters\n        ----------\n        X : array, shape(n_samples, n_features)\n            The data.\n\n        Returns\n        -------\n        ll : array, shape (n_samples,)\n            Log-likelihood of each sample under the current model\n        '},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"New data, where n_samples is the number of samples and n_features is the number of features.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"X_new",docstring:""},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"transform",docstring:"Apply dimensionality reduction to X.\n\n        X is projected on the first principal components previously extracted\n        from a training set.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            New data, where n_samples is the number of samples\n            and n_features is the number of features.\n\n        Returns\n        -------\n        X_new : array-like, shape (n_samples, n_components)\n\n        Examples\n        --------\n\n        >>> import numpy as np\n        >>> from sklearn.decomposition import IncrementalPCA\n        >>> X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])\n        >>> ipca = IncrementalPCA(n_components=2, batch_size=3)\n        >>> ipca.fit(X)\n        IncrementalPCA(batch_size=3, copy=True, n_components=2, whiten=False)\n        >>> ipca.transform(X) # doctest: +SKIP\n        "}],docstring:"Principal component analysis (PCA)\n\n    Linear dimensionality reduction using Singular Value Decomposition of the\n    data to project it to a lower dimensional space.\n\n    It uses the LAPACK implementation of the full SVD or a randomized truncated\n    SVD by the method of Halko et al. 2009, depending on the shape of the input\n    data and the number of components to extract.\n\n    It can also use the scipy.sparse.linalg ARPACK implementation of the\n    truncated SVD.\n\n    Notice that this class does not support sparse input. See\n    :class:`TruncatedSVD` for an alternative with sparse data.\n\n    Read more in the :ref:`User Guide <PCA>`.\n\n    Parameters\n    ----------\n    n_components : int, float, None or string\n        Number of components to keep.\n        if n_components is not set all components are kept::\n\n            n_components == min(n_samples, n_features)\n\n        If ``n_components == 'mle'`` and ``svd_solver == 'full'``, Minka's\n        MLE is used to guess the dimension. Use of ``n_components == 'mle'``\n        will interpret ``svd_solver == 'auto'`` as ``svd_solver == 'full'``.\n\n        If ``0 < n_components < 1`` and ``svd_solver == 'full'``, select the\n        number of components such that the amount of variance that needs to be\n        explained is greater than the percentage specified by n_components.\n\n        If ``svd_solver == 'arpack'``, the number of components must be\n        strictly less than the minimum of n_features and n_samples.\n\n        Hence, the None case results in::\n\n            n_components == min(n_samples, n_features) - 1\n\n    copy : bool (default True)\n        If False, data passed to fit are overwritten and running\n        fit(X).transform(X) will not yield the expected results,\n        use fit_transform(X) instead.\n\n    whiten : bool, optional (default False)\n        When True (False by default) the `components_` vectors are multiplied\n        by the square root of n_samples and then divided by the singular values\n        to ensure uncorrelated outputs with unit component-wise variances.\n\n        Whitening will remove some information from the transformed signal\n        (the relative variance scales of the components) but can sometime\n        improve the predictive accuracy of the downstream estimators by\n        making their data respect some hard-wired assumptions.\n\n    svd_solver : string {'auto', 'full', 'arpack', 'randomized'}\n        auto :\n            the solver is selected by a default policy based on `X.shape` and\n            `n_components`: if the input data is larger than 500x500 and the\n            number of components to extract is lower than 80% of the smallest\n            dimension of the data, then the more efficient 'randomized'\n            method is enabled. Otherwise the exact full SVD is computed and\n            optionally truncated afterwards.\n        full :\n            run exact full SVD calling the standard LAPACK solver via\n            `scipy.linalg.svd` and select the components by postprocessing\n        arpack :\n            run SVD truncated to n_components calling ARPACK solver via\n            `scipy.sparse.linalg.svds`. It requires strictly\n            0 < n_components < min(X.shape)\n        randomized :\n            run randomized SVD by the method of Halko et al.\n\n        .. versionadded:: 0.18.0\n\n    tol : float >= 0, optional (default .0)\n        Tolerance for singular values computed by svd_solver == 'arpack'.\n\n        .. versionadded:: 0.18.0\n\n    iterated_power : int >= 0, or 'auto', (default 'auto')\n        Number of iterations for the power method computed by\n        svd_solver == 'randomized'.\n\n        .. versionadded:: 0.18.0\n\n    random_state : int, RandomState instance or None, optional (default None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`. Used when ``svd_solver`` == 'arpack' or 'randomized'.\n\n        .. versionadded:: 0.18.0\n\n    Attributes\n    ----------\n    components_ : array, shape (n_components, n_features)\n        Principal axes in feature space, representing the directions of\n        maximum variance in the data. The components are sorted by\n        ``explained_variance_``.\n\n    explained_variance_ : array, shape (n_components,)\n        The amount of variance explained by each of the selected components.\n\n        Equal to n_components largest eigenvalues\n        of the covariance matrix of X.\n\n        .. versionadded:: 0.18\n\n    explained_variance_ratio_ : array, shape (n_components,)\n        Percentage of variance explained by each of the selected components.\n\n        If ``n_components`` is not set then all components are stored and the\n        sum of the ratios is equal to 1.0.\n\n    singular_values_ : array, shape (n_components,)\n        The singular values corresponding to each of the selected components.\n        The singular values are equal to the 2-norms of the ``n_components``\n        variables in the lower-dimensional space.\n\n    mean_ : array, shape (n_features,)\n        Per-feature empirical mean, estimated from the training set.\n\n        Equal to `X.mean(axis=0)`.\n\n    n_components_ : int\n        The estimated number of components. When n_components is set\n        to 'mle' or a number between 0 and 1 (with svd_solver == 'full') this\n        number is estimated from input data. Otherwise it equals the parameter\n        n_components, or the lesser value of n_features and n_samples\n        if n_components is None.\n\n    noise_variance_ : float\n        The estimated noise covariance following the Probabilistic PCA model\n        from Tipping and Bishop 1999. See \"Pattern Recognition and\n        Machine Learning\" by C. Bishop, 12.2.1 p. 574 or\n        http://www.miketipping.com/papers/met-mppca.pdf. It is required to\n        compute the estimated data covariance and score samples.\n\n        Equal to the average of (min(n_features, n_samples) - n_components)\n        smallest eigenvalues of the covariance matrix of X.\n\n    References\n    ----------\n    For n_components == 'mle', this class uses the method of `Minka, T. P.\n    \"Automatic choice of dimensionality for PCA\". In NIPS, pp. 598-604`\n\n    Implements the probabilistic PCA model from:\n    `Tipping, M. E., and Bishop, C. M. (1999). \"Probabilistic principal\n    component analysis\". Journal of the Royal Statistical Society:\n    Series B (Statistical Methodology), 61(3), 611-622.\n    via the score and score_samples methods.\n    See http://www.miketipping.com/papers/met-mppca.pdf\n\n    For svd_solver == 'arpack', refer to `scipy.sparse.linalg.svds`.\n\n    For svd_solver == 'randomized', see:\n    `Halko, N., Martinsson, P. G., and Tropp, J. A. (2011).\n    \"Finding structure with randomness: Probabilistic algorithms for\n    constructing approximate matrix decompositions\".\n    SIAM review, 53(2), 217-288.` and also\n    `Martinsson, P. G., Rokhlin, V., and Tygert, M. (2011).\n    \"A randomized algorithm for the decomposition of matrices\".\n    Applied and Computational Harmonic Analysis, 30(1), 47-68.`\n\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.decomposition import PCA\n    >>> X = np.array([[-1, -1], [-2, -1], [-3, -2], [1, 1], [2, 1], [3, 2]])\n    >>> pca = PCA(n_components=2)\n    >>> pca.fit(X)\n    PCA(copy=True, iterated_power='auto', n_components=2, random_state=None,\n      svd_solver='auto', tol=0.0, whiten=False)\n    >>> print(pca.explained_variance_ratio_)  # doctest: +ELLIPSIS\n    [0.9924... 0.0075...]\n    >>> print(pca.singular_values_)  # doctest: +ELLIPSIS\n    [6.30061... 0.54980...]\n\n    >>> pca = PCA(n_components=2, svd_solver='full')\n    >>> pca.fit(X)                 # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    PCA(copy=True, iterated_power='auto', n_components=2, random_state=None,\n      svd_solver='full', tol=0.0, whiten=False)\n    >>> print(pca.explained_variance_ratio_)  # doctest: +ELLIPSIS\n    [0.9924... 0.00755...]\n    >>> print(pca.singular_values_)  # doctest: +ELLIPSIS\n    [6.30061... 0.54980...]\n\n    >>> pca = PCA(n_components=1, svd_solver='arpack')\n    >>> pca.fit(X)\n    PCA(copy=True, iterated_power='auto', n_components=1, random_state=None,\n      svd_solver='arpack', tol=0.0, whiten=False)\n    >>> print(pca.explained_variance_ratio_)  # doctest: +ELLIPSIS\n    [0.99244...]\n    >>> print(pca.singular_values_)  # doctest: +ELLIPSIS\n    [6.30061...]\n\n    See also\n    --------\n    KernelPCA\n    SparsePCA\n    TruncatedSVD\n    IncrementalPCA\n    ",outputs:[{returned:!1,param_type:["array"],name:"components_",docstring:"Principal axes in feature space, representing the directions of maximum variance in the data. The components are sorted by ``explained_variance_``."},{returned:!1,param_type:["array"],name:"explained_variance_",docstring:"The amount of variance explained by each of the selected components.  Equal to n_components largest eigenvalues of the covariance matrix of X.  .. versionadded:: 0.18"},{returned:!1,param_type:["array"],name:"explained_variance_ratio_",docstring:"Percentage of variance explained by each of the selected components.  If ``n_components`` is not set then all components are stored and the sum of the ratios is equal to 1.0."},{returned:!1,param_type:["array"],name:"singular_values_",docstring:"The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the ``n_components`` variables in the lower-dimensional space."},{returned:!1,param_type:["array"],name:"mean_",docstring:"Per-feature empirical mean, estimated from the training set.  Equal to `X.mean(axis=0)`."},{returned:!1,param_type:["int"],name:"n_components_",docstring:"The estimated number of components. When n_components is set to 'mle' or a number between 0 and 1 (with svd_solver == 'full') this number is estimated from input data. Otherwise it equals the parameter n_components, or the lesser value of n_features and n_samples if n_components is None."},{returned:!1,param_type:["float"],name:"noise_variance_",docstring:'The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See "Pattern Recognition and Machine Learning" by C. Bishop, 12.2.1 p. 574 or http://www.miketipping.com/papers/met-mppca.pdf. It is required to compute the estimated data covariance and score samples.  Equal to the average of (min(n_features, n_samples) - n_components) smallest eigenvalues of the covariance matrix of X.'}]},{inputs:[{is_optional:!0,param_type:["int"],name:"n_components",docstring:"Desired dimensionality of output data. Must be strictly less than the number of features. The default value is useful for visualisation. For LSA, a value of 100 is recommended.",options:null,default_value:"2",expected_shape:null},{is_optional:!0,param_type:["str"],name:"algorithm",docstring:'SVD solver to use. Either "arpack" for the ARPACK wrapper in SciPy (scipy.sparse.linalg.svds), or "randomized" for the randomized algorithm due to Halko (2009).',options:null,default_value:'"randomized"',expected_shape:null},{is_optional:!0,param_type:["int"],name:"n_iter",docstring:"Number of iterations for randomized SVD solver. Not used by ARPACK. The default is larger than the default in `randomized_svd` to handle sparse matrices that may have large slowly decaying spectrum.",options:null,default_value:"5",expected_shape:null},{is_optional:!0,param_type:["float"],name:"tol",docstring:"Tolerance for ARPACK. 0 means machine precision. Ignored by randomized SVD solver.",options:null,default_value:null,expected_shape:null}],name:"TruncatedSVD",nodes:[],node_functions:[{inputs:[],outputs:[],name:"__init__",docstring:"None"},{inputs:[],outputs:[],name:"_get_param_names",docstring:"Get parameter names for the estimator"},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Training data.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!0,param_type:[null],name:"y",docstring:"Ignored",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"fit",docstring:"Fit LSI model on training data X.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Training data.\n\n        y : Ignored\n\n        Returns\n        -------\n        self : object\n            Returns the transformer object.\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Training data.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!0,param_type:[null],name:"y",docstring:"Ignored",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"X_new",docstring:"Reduced version of X. This will always be a dense array."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"fit_transform",docstring:"Fit LSI model to X and perform dimensionality reduction on X.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Training data.\n\n        y : Ignored\n\n        Returns\n        -------\n        X_new : array, shape (n_samples, n_components)\n            Reduced version of X. This will always be a dense array.\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"New data.",options:null,default_value:null,expected_shape:"(n_samples, n_components)"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"X_original",docstring:"Note that this is always a dense array."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"inverse_transform",docstring:"Transform X back to its original space.\n\n        Returns an array X_original whose transform would be X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_components)\n            New data.\n\n        Returns\n        -------\n        X_original : array, shape (n_samples, n_features)\n            Note that this is always a dense array.\n        "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"New data.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"X_new",docstring:"Reduced version of X. This will always be a dense array."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"transform",docstring:"Perform dimensionality reduction on X.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            New data.\n\n        Returns\n        -------\n        X_new : array, shape (n_samples, n_components)\n            Reduced version of X. This will always be a dense array.\n        "}],docstring:'Dimensionality reduction using truncated SVD (aka LSA).\n\n    This transformer performs linear dimensionality reduction by means of\n    truncated singular value decomposition (SVD). Contrary to PCA, this\n    estimator does not center the data before computing the singular value\n    decomposition. This means it can work with scipy.sparse matrices\n    efficiently.\n\n    In particular, truncated SVD works on term count/tf-idf matrices as\n    returned by the vectorizers in sklearn.feature_extraction.text. In that\n    context, it is known as latent semantic analysis (LSA).\n\n    This estimator supports two algorithms: a fast randomized SVD solver, and\n    a "naive" algorithm that uses ARPACK as an eigensolver on (X * X.T) or\n    (X.T * X), whichever is more efficient.\n\n    Read more in the :ref:`User Guide <LSA>`.\n\n    Parameters\n    ----------\n    n_components : int, default = 2\n        Desired dimensionality of output data.\n        Must be strictly less than the number of features.\n        The default value is useful for visualisation. For LSA, a value of\n        100 is recommended.\n\n    algorithm : string, default = "randomized"\n        SVD solver to use. Either "arpack" for the ARPACK wrapper in SciPy\n        (scipy.sparse.linalg.svds), or "randomized" for the randomized\n        algorithm due to Halko (2009).\n\n    n_iter : int, optional (default 5)\n        Number of iterations for randomized SVD solver. Not used by ARPACK.\n        The default is larger than the default in `randomized_svd` to handle\n        sparse matrices that may have large slowly decaying spectrum.\n\n    random_state : int, RandomState instance or None, optional, default = None\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    tol : float, optional\n        Tolerance for ARPACK. 0 means machine precision. Ignored by randomized\n        SVD solver.\n\n    Attributes\n    ----------\n    components_ : array, shape (n_components, n_features)\n\n    explained_variance_ : array, shape (n_components,)\n        The variance of the training samples transformed by a projection to\n        each component.\n\n    explained_variance_ratio_ : array, shape (n_components,)\n        Percentage of variance explained by each of the selected components.\n\n    singular_values_ : array, shape (n_components,)\n        The singular values corresponding to each of the selected components.\n        The singular values are equal to the 2-norms of the ``n_components``\n        variables in the lower-dimensional space.\n\n    Examples\n    --------\n    >>> from sklearn.decomposition import TruncatedSVD\n    >>> from sklearn.random_projection import sparse_random_matrix\n    >>> X = sparse_random_matrix(100, 100, density=0.01, random_state=42)\n    >>> svd = TruncatedSVD(n_components=5, n_iter=7, random_state=42)\n    >>> svd.fit(X)  # doctest: +NORMALIZE_WHITESPACE\n    TruncatedSVD(algorithm=\'randomized\', n_components=5, n_iter=7,\n            random_state=42, tol=0.0)\n    >>> print(svd.explained_variance_ratio_)  # doctest: +ELLIPSIS\n    [0.0606... 0.0584... 0.0497... 0.0434... 0.0372...]\n    >>> print(svd.explained_variance_ratio_.sum())  # doctest: +ELLIPSIS\n    0.249...\n    >>> print(svd.singular_values_)  # doctest: +ELLIPSIS\n    [2.5841... 2.5245... 2.3201... 2.1753... 2.0443...]\n\n    See also\n    --------\n    PCA\n\n    References\n    ----------\n    Finding structure with randomness: Stochastic algorithms for constructing\n    approximate matrix decompositions\n    Halko, et al., 2009 (arXiv:909) https://arxiv.org/pdf/0909.4061.pdf\n\n    Notes\n    -----\n    SVD suffers from a problem called "sign indeterminacy", which means the\n    sign of the ``components_`` and the output from transform depend on the\n    algorithm and random state. To work around this, fit instances of this\n    class to data once, then keep the instance around to do transformations.\n\n    ',outputs:[{returned:!1,param_type:["array"],name:"components_",docstring:""},{returned:!1,param_type:["array"],name:"explained_variance_",docstring:"The variance of the training samples transformed by a projection to each component."},{returned:!1,param_type:["array"],name:"explained_variance_ratio_",docstring:"Percentage of variance explained by each of the selected components."},{returned:!1,param_type:["array"],name:"singular_values_",docstring:"The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the ``n_components`` variables in the lower-dimensional space."}]}],node_functions:[{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Data matrix.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!1,param_type:["int"],name:"n_components",docstring:"Number of dictionary atoms to extract.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["int"],name:"alpha",docstring:"Sparsity controlling parameter.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["int"],name:"max_iter",docstring:"Maximum number of iterations to perform.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["float"],name:"tol",docstring:"Tolerance for the stopping condition.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["LIST_VALID_OPTIONS"],name:"method",docstring:"lars: uses the least angle regression method to solve the lasso problem (linear_model.lars_path) cd: uses the coordinate descent method to compute the Lasso solution (linear_model.Lasso). Lars will be faster if the estimated components are sparse.",options:["lars","cd"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["int",null],name:"n_jobs",docstring:"Number of parallel jobs to run. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.",options:null,default_value:"None",expected_shape:null},{is_optional:!1,param_type:["array"],name:"dict_init",docstring:"Initial value for the dictionary for warm restart scenarios.",options:null,default_value:null,expected_shape:"(n_components, n_features),"},{is_optional:!1,param_type:["array"],name:"code_init",docstring:"Initial value for the sparse code for warm restart scenarios.",options:null,default_value:null,expected_shape:"(n_samples, n_components),"},{is_optional:!0,param_type:["callable",null],name:"callback",docstring:"Callable that gets invoked every five iterations",options:null,default_value:"None",expected_shape:null},{is_optional:!0,param_type:["bool"],name:"verbose",docstring:"To control the verbosity of the procedure.",options:null,default_value:"False",expected_shape:null},{is_optional:!0,param_type:["int",null],name:"random_state",docstring:"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`.",options:null,default_value:"None",expected_shape:null},{is_optional:!1,param_type:["bool"],name:"return_n_iter",docstring:"Whether or not to return the number of iterations.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["bool"],name:"positive_dict",docstring:"Whether to enforce positivity when finding the dictionary.  .. versionadded:: 0.20",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["bool"],name:"positive_code",docstring:"Whether to enforce positivity when finding the code.  .. versionadded:: 0.20",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"code",docstring:"The sparse code factor in the matrix factorization."},{returned:!0,param_type:["array"],name:"dictionary",docstring:"The dictionary factor in the matrix factorization."},{returned:!0,param_type:["array"],name:"errors",docstring:"Vector of errors at each iteration."},{returned:!0,param_type:["int"],name:"n_iter",docstring:"Number of iterations run. Returned only if `return_n_iter` is set to True."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"dict_learning",docstring:"Solves a dictionary learning matrix factorization problem.\n\n    Finds the best dictionary and the corresponding sparse code for\n    approximating the data matrix X by solving::\n\n        (U^*, V^*) = argmin 0.5 || X - U V ||_2^2 + alpha * || U ||_1\n                     (U,V)\n                    with || V_k ||_2 = 1 for all  0 <= k < n_components\n\n    where V is the dictionary and U is the sparse code.\n\n    Read more in the :ref:`User Guide <DictionaryLearning>`.\n\n    Parameters\n    ----------\n    X : array of shape (n_samples, n_features)\n        Data matrix.\n\n    n_components : int,\n        Number of dictionary atoms to extract.\n\n    alpha : int,\n        Sparsity controlling parameter.\n\n    max_iter : int,\n        Maximum number of iterations to perform.\n\n    tol : float,\n        Tolerance for the stopping condition.\n\n    method : {'lars', 'cd'}\n        lars: uses the least angle regression method to solve the lasso problem\n        (linear_model.lars_path)\n        cd: uses the coordinate descent method to compute the\n        Lasso solution (linear_model.Lasso). Lars will be faster if\n        the estimated components are sparse.\n\n    n_jobs : int or None, optional (default=None)\n        Number of parallel jobs to run.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    dict_init : array of shape (n_components, n_features),\n        Initial value for the dictionary for warm restart scenarios.\n\n    code_init : array of shape (n_samples, n_components),\n        Initial value for the sparse code for warm restart scenarios.\n\n    callback : callable or None, optional (default: None)\n        Callable that gets invoked every five iterations\n\n    verbose : bool, optional (default: False)\n        To control the verbosity of the procedure.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    return_n_iter : bool\n        Whether or not to return the number of iterations.\n\n    positive_dict : bool\n        Whether to enforce positivity when finding the dictionary.\n\n        .. versionadded:: 0.20\n\n    positive_code : bool\n        Whether to enforce positivity when finding the code.\n\n        .. versionadded:: 0.20\n\n    Returns\n    -------\n    code : array of shape (n_samples, n_components)\n        The sparse code factor in the matrix factorization.\n\n    dictionary : array of shape (n_components, n_features),\n        The dictionary factor in the matrix factorization.\n\n    errors : array\n        Vector of errors at each iteration.\n\n    n_iter : int\n        Number of iterations run. Returned only if `return_n_iter` is\n        set to True.\n\n    See also\n    --------\n    dict_learning_online\n    DictionaryLearning\n    MiniBatchDictionaryLearning\n    SparsePCA\n    MiniBatchSparsePCA\n    "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Data matrix.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!1,param_type:["int"],name:"n_components",docstring:"Number of dictionary atoms to extract.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["float"],name:"alpha",docstring:"Sparsity controlling parameter.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["int"],name:"n_iter",docstring:"Number of iterations to perform.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["bool"],name:"return_code",docstring:"Whether to also return the code U or just the dictionary V.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["array"],name:"dict_init",docstring:"Initial value for the dictionary for warm restart scenarios.",options:null,default_value:null,expected_shape:"(n_components, n_features),"},{is_optional:!0,param_type:["callable",null],name:"callback",docstring:"callable that gets invoked every five iterations",options:null,default_value:"None",expected_shape:null},{is_optional:!1,param_type:["int"],name:"batch_size",docstring:"The number of samples to take in each batch.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["bool"],name:"verbose",docstring:"To control the verbosity of the procedure.",options:null,default_value:"False",expected_shape:null},{is_optional:!1,param_type:["bool"],name:"shuffle",docstring:"Whether to shuffle the data before splitting it in batches.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["int",null],name:"n_jobs",docstring:"Number of parallel jobs to run. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.",options:null,default_value:"None",expected_shape:null},{is_optional:!1,param_type:["LIST_VALID_OPTIONS"],name:"method",docstring:"lars: uses the least angle regression method to solve the lasso problem (linear_model.lars_path) cd: uses the coordinate descent method to compute the Lasso solution (linear_model.Lasso). Lars will be faster if the estimated components are sparse.",options:["lars","cd"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["int"],name:"iter_offset",docstring:"Number of previous iterations completed on the dictionary used for initialization.",options:null,default_value:"0",expected_shape:null},{is_optional:!0,param_type:["int",null],name:"random_state",docstring:"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`.",options:null,default_value:"None",expected_shape:null},{is_optional:!0,param_type:["bool"],name:"return_inner_stats",docstring:"Return the inner statistics A (dictionary covariance) and B (data approximation). Useful to restart the algorithm in an online setting. If return_inner_stats is True, return_code is ignored",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["array","tuple"],name:"inner_stats",docstring:"Inner sufficient statistics that are kept by the algorithm. Passing them at initialization is useful in online settings, to avoid loosing the history of the evolution. A (n_components, n_components) is the dictionary covariance matrix. B (n_features, n_components) is the data approximation matrix",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["bool"],name:"return_n_iter",docstring:"Whether or not to return the number of iterations.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["bool"],name:"positive_dict",docstring:"Whether to enforce positivity when finding the dictionary.  .. versionadded:: 0.20",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["bool"],name:"positive_code",docstring:"Whether to enforce positivity when finding the code.  .. versionadded:: 0.20",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"code",docstring:"the sparse code (only returned if `return_code=True`)"},{returned:!0,param_type:["array"],name:"dictionary",docstring:"the solutions to the dictionary learning problem"},{returned:!0,param_type:["int"],name:"n_iter",docstring:"Number of iterations run. Returned only if `return_n_iter` is set to `True`."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"dict_learning_online",docstring:"Solves a dictionary learning matrix factorization problem online.\n\n    Finds the best dictionary and the corresponding sparse code for\n    approximating the data matrix X by solving::\n\n        (U^*, V^*) = argmin 0.5 || X - U V ||_2^2 + alpha * || U ||_1\n                     (U,V)\n                     with || V_k ||_2 = 1 for all  0 <= k < n_components\n\n    where V is the dictionary and U is the sparse code. This is\n    accomplished by repeatedly iterating over mini-batches by slicing\n    the input data.\n\n    Read more in the :ref:`User Guide <DictionaryLearning>`.\n\n    Parameters\n    ----------\n    X : array of shape (n_samples, n_features)\n        Data matrix.\n\n    n_components : int,\n        Number of dictionary atoms to extract.\n\n    alpha : float,\n        Sparsity controlling parameter.\n\n    n_iter : int,\n        Number of iterations to perform.\n\n    return_code : boolean,\n        Whether to also return the code U or just the dictionary V.\n\n    dict_init : array of shape (n_components, n_features),\n        Initial value for the dictionary for warm restart scenarios.\n\n    callback : callable or None, optional (default: None)\n        callable that gets invoked every five iterations\n\n    batch_size : int,\n        The number of samples to take in each batch.\n\n    verbose : bool, optional (default: False)\n        To control the verbosity of the procedure.\n\n    shuffle : boolean,\n        Whether to shuffle the data before splitting it in batches.\n\n    n_jobs : int or None, optional (default=None)\n        Number of parallel jobs to run.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    method : {'lars', 'cd'}\n        lars: uses the least angle regression method to solve the lasso problem\n        (linear_model.lars_path)\n        cd: uses the coordinate descent method to compute the\n        Lasso solution (linear_model.Lasso). Lars will be faster if\n        the estimated components are sparse.\n\n    iter_offset : int, default 0\n        Number of previous iterations completed on the dictionary used for\n        initialization.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    return_inner_stats : boolean, optional\n        Return the inner statistics A (dictionary covariance) and B\n        (data approximation). Useful to restart the algorithm in an\n        online setting. If return_inner_stats is True, return_code is\n        ignored\n\n    inner_stats : tuple of (A, B) ndarrays\n        Inner sufficient statistics that are kept by the algorithm.\n        Passing them at initialization is useful in online settings, to\n        avoid loosing the history of the evolution.\n        A (n_components, n_components) is the dictionary covariance matrix.\n        B (n_features, n_components) is the data approximation matrix\n\n    return_n_iter : bool\n        Whether or not to return the number of iterations.\n\n    positive_dict : bool\n        Whether to enforce positivity when finding the dictionary.\n\n        .. versionadded:: 0.20\n\n    positive_code : bool\n        Whether to enforce positivity when finding the code.\n\n        .. versionadded:: 0.20\n\n    Returns\n    -------\n    code : array of shape (n_samples, n_components),\n        the sparse code (only returned if `return_code=True`)\n\n    dictionary : array of shape (n_components, n_features),\n        the solutions to the dictionary learning problem\n\n    n_iter : int\n        Number of iterations run. Returned only if `return_n_iter` is\n        set to `True`.\n\n    See also\n    --------\n    dict_learning\n    DictionaryLearning\n    MiniBatchDictionaryLearning\n    SparsePCA\n    MiniBatchSparsePCA\n\n    "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Training vector, where n_samples is the number of samples and n_features is the number of features.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!0,param_type:["int"],name:"n_components",docstring:"Number of components to extract. If None no dimension reduction is performed.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["LIST_VALID_OPTIONS"],name:"algorithm",docstring:"Apply a parallel or deflational FASTICA algorithm.",options:["parallel","deflation","optional"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["bool"],name:"whiten",docstring:"If True perform an initial whitening of the data. If False, the data is assumed to have already been preprocessed: it should be centered, normed and white. Otherwise you will get incorrect results. In this case the parameter n_components will be ignored.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["str"],name:"fun",docstring:"The functional form of the G function used in the approximation to neg-entropy. Could be either 'logcosh', 'exp', or 'cube'. You can also provide your own function. It should return a tuple containing the value of the function, and of its derivative, in the point. The derivative should be averaged along its last dimension. Example:  def my_g(x):     return x ** 3, np.mean(3 * x ** 2, axis=-1)",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["dict"],name:"fun_args",docstring:"Arguments to send to the functional form. If empty or None and if fun='logcosh', fun_args will take value {'alpha' : 1.0}",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["int"],name:"max_iter",docstring:"Maximum number of iterations to perform.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["float"],name:"tol",docstring:"A positive scalar giving the tolerance at which the un-mixing matrix is considered to have converged.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["array"],name:"w_init",docstring:"Initial un-mixing array of dimension (n.comp,n.comp). If None (default) then an array of normal r.v.'s is used.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["int",null],name:"random_state",docstring:"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`.",options:null,default_value:"None",expected_shape:null},{is_optional:!0,param_type:["bool"],name:"return_X_mean",docstring:"If True, X_mean is returned too.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["bool"],name:"compute_sources",docstring:"If False, sources are not computed, but only the rotation matrix. This can save memory when working with big data. Defaults to True.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["bool"],name:"return_n_iter",docstring:"Whether or not to return the number of iterations.",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["LIST_VALID_OPTIONS","array",null],name:"K",docstring:"If whiten is 'True', K is the pre-whitening matrix that projects data onto the first n_components principal components. If whiten is 'False', K is 'None'."},{returned:!0,param_type:["array"],name:"W",docstring:"Estimated un-mixing matrix. The mixing matrix can be obtained by::      w = np.dot(W, K.T)     A = w.T * (w * w.T).I"},{returned:!0,param_type:["LIST_VALID_OPTIONS","array",null],name:"S",docstring:"Estimated source matrix"},{returned:!0,param_type:["array"],name:"X_mean",docstring:"The mean over features. Returned only if return_X_mean is True."},{returned:!0,param_type:["int"],name:"n_iter",docstring:'If the algorithm is "deflation", n_iter is the maximum number of iterations run across all components. Else they are just the number of iterations taken to converge. This is returned only when return_n_iter is set to `True`.'},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"fastica",docstring:"Perform Fast Independent Component Analysis.\n\n    Read more in the :ref:`User Guide <ICA>`.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        Training vector, where n_samples is the number of samples and\n        n_features is the number of features.\n\n    n_components : int, optional\n        Number of components to extract. If None no dimension reduction\n        is performed.\n\n    algorithm : {'parallel', 'deflation'}, optional\n        Apply a parallel or deflational FASTICA algorithm.\n\n    whiten : boolean, optional\n        If True perform an initial whitening of the data.\n        If False, the data is assumed to have already been\n        preprocessed: it should be centered, normed and white.\n        Otherwise you will get incorrect results.\n        In this case the parameter n_components will be ignored.\n\n    fun : string or function, optional. Default: 'logcosh'\n        The functional form of the G function used in the\n        approximation to neg-entropy. Could be either 'logcosh', 'exp',\n        or 'cube'.\n        You can also provide your own function. It should return a tuple\n        containing the value of the function, and of its derivative, in the\n        point. The derivative should be averaged along its last dimension.\n        Example:\n\n        def my_g(x):\n            return x ** 3, np.mean(3 * x ** 2, axis=-1)\n\n    fun_args : dictionary, optional\n        Arguments to send to the functional form.\n        If empty or None and if fun='logcosh', fun_args will take value\n        {'alpha' : 1.0}\n\n    max_iter : int, optional\n        Maximum number of iterations to perform.\n\n    tol : float, optional\n        A positive scalar giving the tolerance at which the\n        un-mixing matrix is considered to have converged.\n\n    w_init : (n_components, n_components) array, optional\n        Initial un-mixing array of dimension (n.comp,n.comp).\n        If None (default) then an array of normal r.v.'s is used.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    return_X_mean : bool, optional\n        If True, X_mean is returned too.\n\n    compute_sources : bool, optional\n        If False, sources are not computed, but only the rotation matrix.\n        This can save memory when working with big data. Defaults to True.\n\n    return_n_iter : bool, optional\n        Whether or not to return the number of iterations.\n\n    Returns\n    -------\n    K : array, shape (n_components, n_features) | None.\n        If whiten is 'True', K is the pre-whitening matrix that projects data\n        onto the first n_components principal components. If whiten is 'False',\n        K is 'None'.\n\n    W : array, shape (n_components, n_components)\n        Estimated un-mixing matrix.\n        The mixing matrix can be obtained by::\n\n            w = np.dot(W, K.T)\n            A = w.T * (w * w.T).I\n\n    S : array, shape (n_samples, n_components) | None\n        Estimated source matrix\n\n    X_mean : array, shape (n_features, )\n        The mean over features. Returned only if return_X_mean is True.\n\n    n_iter : int\n        If the algorithm is \"deflation\", n_iter is the\n        maximum number of iterations run across all components. Else\n        they are just the number of iterations taken to converge. This is\n        returned only when return_n_iter is set to `True`.\n\n    Notes\n    -----\n\n    The data matrix X is considered to be a linear combination of\n    non-Gaussian (independent) components i.e. X = AS where columns of S\n    contain the independent components and A is a linear mixing\n    matrix. In short ICA attempts to `un-mix' the data by estimating an\n    un-mixing matrix W where ``S = W K X.``\n\n    This implementation was originally made for data of shape\n    [n_features, n_samples]. Now the input is transposed\n    before the algorithm is applied. This makes it slightly\n    faster for Fortran-ordered input.\n\n    Implemented using FastICA:\n    `A. Hyvarinen and E. Oja, Independent Component Analysis:\n    Algorithms and Applications, Neural Networks, 13(4-5), 2000,\n    pp. 411-430`\n\n    "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Constant matrix.",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!1,param_type:["array"],name:"W",docstring:"If init='custom', it is used as initial guess for the solution.",options:null,default_value:null,expected_shape:"(n_samples, n_components)"},{is_optional:!1,param_type:["array"],name:"H",docstring:"If init='custom', it is used as initial guess for the solution. If update_H=False, it is used as a constant, to solve for W only.",options:null,default_value:null,expected_shape:"(n_components, n_features)"},{is_optional:!1,param_type:["int"],name:"n_components",docstring:"Number of components, if n_components is not set all features are kept.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["LIST_VALID_OPTIONS",null],name:"init",docstring:"Method used to initialize the procedure. Default: 'random'. Valid options:  - 'random': non-negative random matrices, scaled with:     sqrt(X.mean() / n_components)  - 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)     initialization (better for sparseness)  - 'nndsvda': NNDSVD with zeros filled with the average of X     (better when sparsity is not desired)  - 'nndsvdar': NNDSVD with zeros filled with small random values     (generally faster, less accurate alternative to NNDSVDa     for when sparsity is not desired)  - 'custom': use custom matrices W and H",options:[" None "," 'random' "," 'nndsvd' "," 'nndsvda' "," 'nndsvdar' "," 'custom"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["bool"],name:"update_H",docstring:"Set to True, both W and H will be estimated from initial guesses. Set to False, only W will be estimated.",options:null,default_value:"True",expected_shape:null},{is_optional:!1,param_type:["LIST_VALID_OPTIONS"],name:"solver",docstring:"Numerical solver to use: 'cd' is a Coordinate Descent solver that uses Fast Hierarchical     Alternating Least Squares (Fast HALS). 'mu' is a Multiplicative Update solver.  .. versionadded:: 0.17    Coordinate Descent solver.  .. versionadded:: 0.19    Multiplicative Update solver.",options:["cd' "," 'mu"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["float","str"],name:"beta_loss",docstring:"String must be in {'frobenius', 'kullback-leibler', 'itakura-saito'}. Beta divergence to be minimized, measuring the distance between X and the dot product WH. Note that values different from 'frobenius' (or 2) and 'kullback-leibler' (or 1) lead to significantly slower fits. Note that for beta_loss <= 0 (or 'itakura-saito'), the input matrix X cannot contain zeros. Used only in 'mu' solver.  .. versionadded:: 0.19",options:null,default_value:"frobenius",expected_shape:null},{is_optional:!0,param_type:["float"],name:"tol",docstring:"Tolerance of the stopping condition.",options:null,default_value:"1e-4",expected_shape:null},{is_optional:!0,param_type:["int"],name:"max_iter",docstring:"Maximum number of iterations before timing out.",options:null,default_value:"200",expected_shape:null},{is_optional:!0,param_type:["float"],name:"alpha",docstring:"Constant that multiplies the regularization terms.",options:null,default_value:"0.",expected_shape:null},{is_optional:!0,param_type:["float"],name:"l1_ratio",docstring:"The regularization mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an elementwise L2 penalty (aka Frobenius Norm). For l1_ratio = 1 it is an elementwise L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.",options:null,default_value:"0.",expected_shape:null},{is_optional:!1,param_type:["LIST_VALID_OPTIONS",null],name:"regularization",docstring:"Select whether the regularization affects the components (H), the transformation (W), both or none of them.",options:["both' "," 'components' "," 'transformation' "," None"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["int",null],name:"random_state",docstring:"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`.",options:null,default_value:"None",expected_shape:null},{is_optional:!0,param_type:["int"],name:"verbose",docstring:"The verbosity level.",options:null,default_value:"0",expected_shape:null},{is_optional:!0,param_type:["bool"],name:"shuffle",docstring:"If true, randomize the order of coordinates in the CD solver.",options:null,default_value:"False",expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"W",docstring:"Solution to the non-negative least squares problem."},{returned:!0,param_type:["array"],name:"H",docstring:"Solution to the non-negative least squares problem."},{returned:!0,param_type:["int"],name:"n_iter",docstring:"Actual number of iterations."},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"non_negative_factorization",docstring:"Compute Non-negative Matrix Factorization (NMF)\n\n    Find two non-negative matrices (W, H) whose product approximates the non-\n    negative matrix X. This factorization can be used for example for\n    dimensionality reduction, source separation or topic extraction.\n\n    The objective function is::\n\n        0.5 * ||X - WH||_Fro^2\n        + alpha * l1_ratio * ||vec(W)||_1\n        + alpha * l1_ratio * ||vec(H)||_1\n        + 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2\n        + 0.5 * alpha * (1 - l1_ratio) * ||H||_Fro^2\n\n    Where::\n\n        ||A||_Fro^2 = \\sum_{i,j} A_{ij}^2 (Frobenius norm)\n        ||vec(A)||_1 = \\sum_{i,j} abs(A_{ij}) (Elementwise L1 norm)\n\n    For multiplicative-update ('mu') solver, the Frobenius norm\n    (0.5 * ||X - WH||_Fro^2) can be changed into another beta-divergence loss,\n    by changing the beta_loss parameter.\n\n    The objective function is minimized with an alternating minimization of W\n    and H. If H is given and update_H=False, it solves for W only.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        Constant matrix.\n\n    W : array-like, shape (n_samples, n_components)\n        If init='custom', it is used as initial guess for the solution.\n\n    H : array-like, shape (n_components, n_features)\n        If init='custom', it is used as initial guess for the solution.\n        If update_H=False, it is used as a constant, to solve for W only.\n\n    n_components : integer\n        Number of components, if n_components is not set all features\n        are kept.\n\n    init :  None | 'random' | 'nndsvd' | 'nndsvda' | 'nndsvdar' | 'custom'\n        Method used to initialize the procedure.\n        Default: 'random'.\n        Valid options:\n\n        - 'random': non-negative random matrices, scaled with:\n            sqrt(X.mean() / n_components)\n\n        - 'nndsvd': Nonnegative Double Singular Value Decomposition (NNDSVD)\n            initialization (better for sparseness)\n\n        - 'nndsvda': NNDSVD with zeros filled with the average of X\n            (better when sparsity is not desired)\n\n        - 'nndsvdar': NNDSVD with zeros filled with small random values\n            (generally faster, less accurate alternative to NNDSVDa\n            for when sparsity is not desired)\n\n        - 'custom': use custom matrices W and H\n\n    update_H : boolean, default: True\n        Set to True, both W and H will be estimated from initial guesses.\n        Set to False, only W will be estimated.\n\n    solver : 'cd' | 'mu'\n        Numerical solver to use:\n        'cd' is a Coordinate Descent solver that uses Fast Hierarchical\n            Alternating Least Squares (Fast HALS).\n        'mu' is a Multiplicative Update solver.\n\n        .. versionadded:: 0.17\n           Coordinate Descent solver.\n\n        .. versionadded:: 0.19\n           Multiplicative Update solver.\n\n    beta_loss : float or string, default 'frobenius'\n        String must be in {'frobenius', 'kullback-leibler', 'itakura-saito'}.\n        Beta divergence to be minimized, measuring the distance between X\n        and the dot product WH. Note that values different from 'frobenius'\n        (or 2) and 'kullback-leibler' (or 1) lead to significantly slower\n        fits. Note that for beta_loss <= 0 (or 'itakura-saito'), the input\n        matrix X cannot contain zeros. Used only in 'mu' solver.\n\n        .. versionadded:: 0.19\n\n    tol : float, default: 1e-4\n        Tolerance of the stopping condition.\n\n    max_iter : integer, default: 200\n        Maximum number of iterations before timing out.\n\n    alpha : double, default: 0.\n        Constant that multiplies the regularization terms.\n\n    l1_ratio : double, default: 0.\n        The regularization mixing parameter, with 0 <= l1_ratio <= 1.\n        For l1_ratio = 0 the penalty is an elementwise L2 penalty\n        (aka Frobenius Norm).\n        For l1_ratio = 1 it is an elementwise L1 penalty.\n        For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.\n\n    regularization : 'both' | 'components' | 'transformation' | None\n        Select whether the regularization affects the components (H), the\n        transformation (W), both or none of them.\n\n    random_state : int, RandomState instance or None, optional, default: None\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    verbose : integer, default: 0\n        The verbosity level.\n\n    shuffle : boolean, default: False\n        If true, randomize the order of coordinates in the CD solver.\n\n    Returns\n    -------\n    W : array-like, shape (n_samples, n_components)\n        Solution to the non-negative least squares problem.\n\n    H : array-like, shape (n_components, n_features)\n        Solution to the non-negative least squares problem.\n\n    n_iter : int\n        Actual number of iterations.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> X = np.array([[1,1], [2, 1], [3, 1.2], [4, 1], [5, 0.8], [6, 1]])\n    >>> from sklearn.decomposition import non_negative_factorization\n    >>> W, H, n_iter = non_negative_factorization(X, n_components=2,\n    ... init='random', random_state=0)\n\n    References\n    ----------\n    Cichocki, Andrzej, and P. H. A. N. Anh-Huy. \"Fast local algorithms for\n    large scale nonnegative matrix and tensor factorizations.\"\n    IEICE transactions on fundamentals of electronics, communications and\n    computer sciences 92.3: 708-721, 2009.\n\n    Fevotte, C., & Idier, J. (2011). Algorithms for nonnegative matrix\n    factorization with the beta-divergence. Neural Computation, 23(9).\n    "},{inputs:[{is_optional:!1,param_type:["array"],name:"M",docstring:"Matrix to decompose",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["int"],name:"n_components",docstring:"Number of singular values and vectors to extract.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["int"],name:"n_oversamples",docstring:"Additional number of random vectors to sample the range of M so as to ensure proper conditioning. The total number of random vectors used to find the range of M is n_components + n_oversamples. Smaller number can improve speed but can negatively impact the quality of approximation of singular vectors and singular values.",options:null,default_value:"10",expected_shape:null},{is_optional:!0,param_type:["int"],name:"n_iter",docstring:"Number of power iterations. It can be used to deal with very noisy problems. When 'auto', it is set to 4, unless `n_components` is small (< .1 * min(X.shape)) `n_iter` in which case is set to 7. This improves precision with few components.  .. versionchanged:: 0.18",options:null,default_value:"auto",expected_shape:null},{is_optional:!0,param_type:[null],name:"power_iteration_normalizer",docstring:"Whether the power iterations are normalized with step-by-step QR factorization (the slowest but most accurate), 'none' (the fastest but numerically unstable when `n_iter` is large, e.g. typically 5 or larger), or 'LU' factorization (numerically stable but can lose slightly in accuracy). The 'auto' mode applies no normalization if `n_iter` <= 2 and switches to LU otherwise.  .. versionadded:: 0.18",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:[null],name:"transpose",docstring:"Whether the algorithm should be applied to M.T instead of M. The result should approximately be the same. The 'auto' mode will trigger the transposition if M.shape[1] > M.shape[0] since this implementation of randomized SVD tend to be a little faster in that case.  .. versionchanged:: 0.18",options:null,default_value:"",expected_shape:null},{is_optional:!0,param_type:["bool"],name:"flip_sign",docstring:"The output of a singular value decomposition is only unique up to a permutation of the signs of the singular vectors. If `flip_sign` is set to `True`, the sign ambiguity is resolved by making the largest loadings for each component in the left singular vectors positive.",options:null,default_value:"",expected_shape:null},{is_optional:!0,param_type:["int",null],name:"random_state",docstring:"The seed of the pseudo random number generator to use when shuffling the data.  If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`.",options:null,default_value:"None",expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"randomized_svd",docstring:"Computes a truncated randomized SVD\n\n    Parameters\n    ----------\n    M : ndarray or sparse matrix\n        Matrix to decompose\n\n    n_components : int\n        Number of singular values and vectors to extract.\n\n    n_oversamples : int (default is 10)\n        Additional number of random vectors to sample the range of M so as\n        to ensure proper conditioning. The total number of random vectors\n        used to find the range of M is n_components + n_oversamples. Smaller\n        number can improve speed but can negatively impact the quality of\n        approximation of singular vectors and singular values.\n\n    n_iter : int or 'auto' (default is 'auto')\n        Number of power iterations. It can be used to deal with very noisy\n        problems. When 'auto', it is set to 4, unless `n_components` is small\n        (< .1 * min(X.shape)) `n_iter` in which case is set to 7.\n        This improves precision with few components.\n\n        .. versionchanged:: 0.18\n\n    power_iteration_normalizer : 'auto' (default), 'QR', 'LU', 'none'\n        Whether the power iterations are normalized with step-by-step\n        QR factorization (the slowest but most accurate), 'none'\n        (the fastest but numerically unstable when `n_iter` is large, e.g.\n        typically 5 or larger), or 'LU' factorization (numerically stable\n        but can lose slightly in accuracy). The 'auto' mode applies no\n        normalization if `n_iter` <= 2 and switches to LU otherwise.\n\n        .. versionadded:: 0.18\n\n    transpose : True, False or 'auto' (default)\n        Whether the algorithm should be applied to M.T instead of M. The\n        result should approximately be the same. The 'auto' mode will\n        trigger the transposition if M.shape[1] > M.shape[0] since this\n        implementation of randomized SVD tend to be a little faster in that\n        case.\n\n        .. versionchanged:: 0.18\n\n    flip_sign : boolean, (True by default)\n        The output of a singular value decomposition is only unique up to a\n        permutation of the signs of the singular vectors. If `flip_sign` is\n        set to `True`, the sign ambiguity is resolved by making the largest\n        loadings for each component in the left singular vectors positive.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        The seed of the pseudo random number generator to use when shuffling\n        the data.  If int, random_state is the seed used by the random number\n        generator; If RandomState instance, random_state is the random number\n        generator; If None, the random number generator is the RandomState\n        instance used by `np.random`.\n\n    Notes\n    -----\n    This algorithm finds a (usually very good) approximate truncated\n    singular value decomposition using randomization to speed up the\n    computations. It is particularly fast on large matrices on which\n    you wish to extract only a small number of components. In order to\n    obtain further speed up, `n_iter` can be set <=2 (at the cost of\n    loss of precision).\n\n    References\n    ----------\n    * Finding structure with randomness: Stochastic algorithms for constructing\n      approximate matrix decompositions\n      Halko, et al., 2009 https://arxiv.org/abs/0909.4061\n\n    * A randomized algorithm for the decomposition of matrices\n      Per-Gunnar Martinsson, Vladimir Rokhlin and Mark Tygert\n\n    * An implementation of a randomized algorithm for principal component\n      analysis\n      A. Szlam et al. 2014\n    "},{inputs:[{is_optional:!1,param_type:["array"],name:"X",docstring:"Data matrix",options:null,default_value:null,expected_shape:"(n_samples, n_features)"},{is_optional:!1,param_type:["array"],name:"dictionary",docstring:"The dictionary matrix against which to solve the sparse coding of the data. Some of the algorithms assume normalized rows for meaningful output.",options:null,default_value:null,expected_shape:"(n_components, n_features)"},{is_optional:!1,param_type:["array"],name:"gram",docstring:"Precomputed Gram matrix, dictionary * dictionary'",options:null,default_value:null,expected_shape:"(n_components, n_components)"},{is_optional:!1,param_type:["array"],name:"cov",docstring:"Precomputed covariance, dictionary' * X",options:null,default_value:null,expected_shape:"(n_components, n_samples)"},{is_optional:!1,param_type:["LIST_VALID_OPTIONS"],name:"algorithm",docstring:"lars: uses the least angle regression method (linear_model.lars_path) lasso_lars: uses Lars to compute the Lasso solution lasso_cd: uses the coordinate descent method to compute the Lasso solution (linear_model.Lasso). lasso_lars will be faster if the estimated components are sparse. omp: uses orthogonal matching pursuit to estimate the sparse solution threshold: squashes to zero all coefficients less than alpha from the projection dictionary * X'",options:["lasso_lars","lasso_cd","lars","omp","threshold"],default_value:null,expected_shape:null},{is_optional:!0,param_type:["int"],name:"n_nonzero_coefs",docstring:"Number of nonzero coefficients to target in each column of the solution. This is only used by `algorithm='lars'` and `algorithm='omp'` and is overridden by `alpha` in the `omp` case.",options:null,default_value:"",expected_shape:null},{is_optional:!0,param_type:["float"],name:"alpha",docstring:"If `algorithm='lasso_lars'` or `algorithm='lasso_cd'`, `alpha` is the penalty applied to the L1 norm. If `algorithm='threshold'`, `alpha` is the absolute value of the threshold below which coefficients will be squashed to zero. If `algorithm='omp'`, `alpha` is the tolerance parameter: the value of the reconstruction error targeted. In this case, it overrides `n_nonzero_coefs`.",options:null,default_value:"",expected_shape:null},{is_optional:!0,param_type:["bool"],name:"copy_cov",docstring:"Whether to copy the precomputed covariance matrix; if False, it may be overwritten.",options:null,default_value:null,expected_shape:null},{is_optional:!1,param_type:["array"],name:"init",docstring:"Initialization value of the sparse codes. Only used if `algorithm='lasso_cd'`.",options:null,default_value:null,expected_shape:"(n_samples, n_components)"},{is_optional:!0,param_type:["int"],name:"max_iter",docstring:"Maximum number of iterations to perform if `algorithm='lasso_cd'`.",options:null,default_value:"",expected_shape:null},{is_optional:!0,param_type:["int",null],name:"n_jobs",docstring:"Number of parallel jobs to run. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.",options:null,default_value:"None",expected_shape:null},{is_optional:!0,param_type:["bool"],name:"check_input",docstring:"If False, the input arrays X and dictionary will not be checked.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["int"],name:"verbose",docstring:"Controls the verbosity; the higher, the more messages. Defaults to 0.",options:null,default_value:null,expected_shape:null},{is_optional:!0,param_type:["bool"],name:"positive",docstring:"Whether to enforce positivity when finding the encoding.  .. versionadded:: 0.20",options:null,default_value:null,expected_shape:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{returned:!0,param_type:["array"],name:"code",docstring:"The sparse codes"},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}],name:"sparse_encode",docstring:"Sparse coding\n\n    Each row of the result is the solution to a sparse coding problem.\n    The goal is to find a sparse array `code` such that::\n\n        X ~= code * dictionary\n\n    Read more in the :ref:`User Guide <SparseCoder>`.\n\n    Parameters\n    ----------\n    X : array of shape (n_samples, n_features)\n        Data matrix\n\n    dictionary : array of shape (n_components, n_features)\n        The dictionary matrix against which to solve the sparse coding of\n        the data. Some of the algorithms assume normalized rows for meaningful\n        output.\n\n    gram : array, shape=(n_components, n_components)\n        Precomputed Gram matrix, dictionary * dictionary'\n\n    cov : array, shape=(n_components, n_samples)\n        Precomputed covariance, dictionary' * X\n\n    algorithm : {'lasso_lars', 'lasso_cd', 'lars', 'omp', 'threshold'}\n        lars: uses the least angle regression method (linear_model.lars_path)\n        lasso_lars: uses Lars to compute the Lasso solution\n        lasso_cd: uses the coordinate descent method to compute the\n        Lasso solution (linear_model.Lasso). lasso_lars will be faster if\n        the estimated components are sparse.\n        omp: uses orthogonal matching pursuit to estimate the sparse solution\n        threshold: squashes to zero all coefficients less than alpha from\n        the projection dictionary * X'\n\n    n_nonzero_coefs : int, 0.1 * n_features by default\n        Number of nonzero coefficients to target in each column of the\n        solution. This is only used by `algorithm='lars'` and `algorithm='omp'`\n        and is overridden by `alpha` in the `omp` case.\n\n    alpha : float, 1. by default\n        If `algorithm='lasso_lars'` or `algorithm='lasso_cd'`, `alpha` is the\n        penalty applied to the L1 norm.\n        If `algorithm='threshold'`, `alpha` is the absolute value of the\n        threshold below which coefficients will be squashed to zero.\n        If `algorithm='omp'`, `alpha` is the tolerance parameter: the value of\n        the reconstruction error targeted. In this case, it overrides\n        `n_nonzero_coefs`.\n\n    copy_cov : boolean, optional\n        Whether to copy the precomputed covariance matrix; if False, it may be\n        overwritten.\n\n    init : array of shape (n_samples, n_components)\n        Initialization value of the sparse codes. Only used if\n        `algorithm='lasso_cd'`.\n\n    max_iter : int, 1000 by default\n        Maximum number of iterations to perform if `algorithm='lasso_cd'`.\n\n    n_jobs : int or None, optional (default=None)\n        Number of parallel jobs to run.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    check_input : boolean, optional\n        If False, the input arrays X and dictionary will not be checked.\n\n    verbose : int, optional\n        Controls the verbosity; the higher, the more messages. Defaults to 0.\n\n    positive : boolean, optional\n        Whether to enforce positivity when finding the encoding.\n\n        .. versionadded:: 0.20\n\n    Returns\n    -------\n    code : array of shape (n_samples, n_components)\n        The sparse codes\n\n    See also\n    --------\n    sklearn.linear_model.lars_path\n    sklearn.linear_model.orthogonal_mp\n    sklearn.linear_model.Lasso\n    SparseCoder\n    "}],docstring:"",outputs:[]},Rm={name:"chemml.chem",docstring:"",inputs:[],outputs:[],node_functions:[{name:"atom_features",docstring:"This function encodes the RDKit atom to a binary vector.\n\n    Parameters\n    ----------\n    bond : rdkit.Chem.rdchem.Bond\n        The bond must be an RDKit Bond object.\n\n    Returns\n    -------\n    features : array\n        A binary array with length 6 that specifies the type of bond, if it is\n        a single/double/triple/aromatic bond, a conjugated bond or belongs to a molecular ring.\n\n    ",inputs:[{name:"bond",docstring:"The bond must be an RDKit Bond object.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"features",docstring:"A binary array with length 6 that specifies the type of bond, if it is a single/double/triple/aromatic bond, a conjugated bond or belongs to a molecular ring.",param_type:["array"],returned:!0}]},{name:"bond_features",docstring:"This function encodes the RDKit bond to a binary vector.\n\n    Parameters\n    ----------\n    bond : rdkit.Chem.rdchem.Bond\n        The bond must be an RDKit Bond object.\n\n    Returns\n    -------\n    features : array\n        A binary array with length 6 that specifies the type of bond, if it is\n        a single/double/triple/aromatic bond, a conjugated bond or belongs to a molecular ring.\n\n    ",inputs:[{name:"bond",docstring:"The bond must be an RDKit Bond object.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"features",docstring:"A binary array with length 6 that specifies the type of bond, if it is a single/double/triple/aromatic bond, a conjugated bond or belongs to a molecular ring.",param_type:["array"],returned:!0}]},{name:"num_atom_features",docstring:"This function returns the number of atomic features that are available by this module.\n\n    Returns\n    -------\n    n_features : int\n        length of atomic feature vector.\n    ",inputs:[],outputs:[{name:"n_features",docstring:"length of atomic feature vector.",param_type:["int"],returned:!0}]},{name:"num_bond_features",docstring:"This function returns the number of bond features that are available by this module.\n\n    Returns\n    -------\n    n_features : int\n        length of bond feature vector.\n    ",inputs:[],outputs:[{name:"n_features",docstring:"length of bond feature vector.",param_type:["int"],returned:!0}]},{name:"tensorise_molecules",docstring:"Takes a list of molecules and provides tensor representation of atom and bond features.\n    This representation is based on the \"convolutional networks on graphs for learning molecular fingerprints\" by\n    David Duvenaud et al., NIPS 2015.\n\n    Parameters\n    ----------\n    molecules : chemml.chem.Molecule object or array\n        If list, it must be a list of chemml.chem.Molecule objects, otherwise we raise a ValueError.\n        In addition, all the molecule objects must provide the SMILES representation.\n        We try to create the SMILES representation if it's not available.\n\n    max_degree : int, optional (default=5)\n        The maximum number of neighbour per atom that each molecule can have\n        (to which all molecules will be padded), use 'None' for auto\n\n    max_atoms : int, optional (default=None)\n        The maximum number of atoms per molecule (to which all\n        molecules will be padded), use 'None' for auto\n\n    n_jobs : int, optional(default=-1)\n        The number of parallel processes. If -1, uses all the available processes.\n\n    batch_size : int, optional(default=3000)\n        The number of molecules per process, bigger chunksize is preffered as each process will preallocate np.arrays\n\n    verbose : bool, optional(default=True)\n        The verbosity of messages.\n\n    Notes\n    -----\n        It is not recommended to set max_degree to `None`/auto when\n        using `NeuralGraph` layers. Max_degree determines the number of\n        trainable parameters and is essentially a hyperparameter.\n        While models can be rebuilt using different `max_atoms`, they cannot\n        be rebuild for different values of `max_degree`, as the architecture\n        will be different.\n\n        For organic molecules `max_degree=5` is a good value (Duvenaud et. al, 2015)\n\n\n    Returns\n    -------\n        atoms : array\n            An atom feature array of shape (molecules, max_atoms, atom_features)\n        bonds : array\n            A bonds array of shape (molecules, max_atoms, max_degree)\n        edges : array\n        A connectivity array of shape (molecules, max_atoms, max_degree, bond_features)\n    ",inputs:[{name:"molecules",docstring:"If list, it must be a list of chemml.chem.Molecule objects, otherwise we raise a ValueError. In addition, all the molecule objects must provide the SMILES representation. We try to create the SMILES representation if it's not available.",param_type:["array","object"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"max_degree",docstring:"The maximum number of neighbour per atom that each molecule can have (to which all molecules will be padded), use 'None' for auto",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"5",options:null},{name:"max_atoms",docstring:"The maximum number of atoms per molecule (to which all molecules will be padded), use 'None' for auto",param_type:["int",null],expected_shape:null,is_optional:!0,default_value:"None",options:null},{name:"n_jobs",docstring:"The number of parallel processes. If -1, uses all the available processes.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"-1",options:null},{name:"batch_size",docstring:"The number of molecules per process, bigger chunksize is preffered as each process will preallocate np.arrays",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"3000",options:null},{name:"verbose",docstring:"The verbosity of messages.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[{name:"atoms",docstring:"An atom feature array of shape (molecules, max_atoms, atom_features)",param_type:["array"],returned:!0},{name:"bonds",docstring:"A bonds array of shape (molecules, max_atoms, max_degree)",param_type:["array"],returned:!0},{name:"edges",docstring:"edges : array A connectivity array of shape (molecules, max_atoms, max_degree, bond_features)",param_type:["array"],returned:!0}]}],nodes:[{name:"BagofBonds",docstring:"\n    The implementation of bag of bonds version of coulomb matrix by katja Hansen et. al. 2015, JPCL.",inputs:[{name:"const",docstring:"The constant value for coordinates unit conversion to atomic unit if const=1.0, returns atomic unit if const=0.529, returns Angstrom  const/|Ri-Rj|, which denominator is the euclidean distance between two atoms",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"1.0",options:null},{name:"n_jobs",docstring:"The number of parallel processes. If -1, uses all the available processes.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"-1",options:null},{name:"verbose",docstring:"The verbosity of messages.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[{name:"header_",docstring:"contains one nuclear charge (represents single atom) or a tuple of two nuclear charges (represents a bond)",param_type:["list"],returned:!1}],node_functions:[{name:"represent",docstring:"\n        provides bag of bonds representation for input molecules.",inputs:[{name:"molecules",docstring:"If list, it must be a list of chemml.chem.Molecule objects, otherwise we raise a ValueError. In addition, all the molecule objects must provide the XYZ information. Please make sure the XYZ geometry has been stored or optimized in advance.",param_type:["array","object"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"features",docstring:"The bag of bond features.",param_type:[null],returned:!0}]}],nodes:[]},{name:"CoulombMatrix",docstring:"\n    The implementation of coulomb matrix descriptors by Matthias Rupp et. al. 2012, PRL (All 3 different variations).",inputs:[{name:"cm_type",docstring:"The coulomb matrix type, one of the following types:     * 'Unsorted_Matrix' or 'UM'     * 'Unsorted_Triangular' or 'UT'     * 'Eigenspectrum' or 'E'      * 'Sorted_Coulomb' or 'SC'     * 'Random_Coulomb' or 'RC'",param_type:["str"],expected_shape:null,is_optional:!0,default_value:"SC",options:["UM","UT","E","SC","RC"]},{name:"max_n_atoms",docstring:"Set the maximum number of atoms per molecule (to which all representations will be padded). If 'auto', we find it based on all input molecules.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"auto",options:null},{name:"nPerm",docstring:"Number of permutation of coulomb matrix per molecule for Random_Coulomb (RC)  type of representation.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"3",options:null},{name:"const",docstring:"The constant value for coordinates unit conversion to atomic unit example: atomic unit -> const=1, Angstrom -> const=0.529 const/|Ri-Rj|, which denominator is the euclidean distance between atoms i and j",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"1",options:null},{name:"n_jobs",docstring:"The number of parallel processes. If -1, uses all the available processes.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"-1",options:null},{name:"verbose",docstring:"The verbosity of messages.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[{name:"n_molecules_",docstring:"Total number of molecules.",param_type:["int"],returned:!1},{name:"max_n_atoms_",docstring:"Maximum number of atoms in all molecules.",param_type:["int"],returned:!1}],node_functions:[{name:"represent",docstring:"\n        provides coulomb matrix representation for input molecules.",inputs:[{name:"molecules",docstring:"If list, it must be a list of chemml.chem.Molecule objects, otherwise we raise a ValueError. In addition, all the molecule objects must provide the XYZ information. Please make sure the XYZ geometry has been stored or optimized in advance.",param_type:["array","object"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"features",docstring:"A data frame with same number of rows as number of molecules will be returned. The exact shape of the dataframe depends on the type of CM as follows:     - shape of Unsorted_Matrix (UM): (n_molecules, max_n_atoms**2)     - shape of Unsorted_Triangular (UT): (n_molecules, max_n_atoms*(max_n_atoms+1)/2)     - shape of eigenspectrums (E): (n_molecules, max_n_atoms)     - shape of Sorted_Coulomb (SC): (n_molecules, max_n_atoms*(max_n_atoms+1)/2)     - shape of Random_Coulomb (RC): (n_molecules, nPerm * max_n_atoms * (max_n_atoms+1)/2)",param_type:["dataframe"],returned:!0}]}],nodes:[]},{name:"Dragon",docstring:"\n    An interface to Dragon 6 and 7 chemoinformatics software. Dragon is a commercial software and\n    you should provide API Key",inputs:[{name:"version",docstring:"The version of available Dragon on the user's system. (available versions: 6 or 7)",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"7",options:null},{name:"Weights",docstring:"A list of weights to be used",param_type:["list"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"blocks",docstring:"A list of integers as descriptor blocks' id. There are totally 29 and 30 blocks available in version 6 and 7, respectively. This module is not atimed to cherry pick descriptors in each block. For doing so, please use Script Wizard in Drgon GUI.",param_type:["list"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"external",docstring:"If True, include external variables at the end of each saved file.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null}],outputs:[],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_save_script",docstring:"None",inputs:[],outputs:[]},{name:"convert_to_csv",docstring:"\n        This function converts the tab-delimited txt file from Dragon to pandas dataframe.\n        Note that this process might require large memory based on the number of data points and features.",inputs:[{name:"remove",docstring:"if True, the original descriptors file (Dragon_descriptors.txt) will be removed.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[{name:"features",docstring:"The 2D dataframe of the descriptors. Note that the first two columns are 'No.' and 'NAME'.",param_type:["dataframe"],returned:!0}]},{name:"printout",docstring:"None",inputs:[],outputs:[]},{name:"run",docstring:"None",inputs:[],outputs:[]},{name:"script_wizard",docstring:"\n        The script_wizard is designed to build a Dragon script file. The name and\n        the functionality of this function is the same as available Script wizard\n        in the Dragon Graphic User Interface.\n        Note: All reported nodes are mandatory, except the <EXTERNAL> tag\n        Note: Script for version 7 doesn't support fingerprints block",inputs:[{name:"script",docstring:'If "new" start creating a new script from scratch. If you want to load an existing script, pass the filename with drs format.',param_type:["str"],expected_shape:null,is_optional:!0,default_value:'"new"',options:null},{name:"output_directory",docstring:"the path to the working directory to store output files.",param_type:["str"],expected_shape:null,is_optional:!0,default_value:"./",options:null},{name:"dragon",docstring:"Dragon script in  xml format.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"drs",docstring:"Dragon script file name",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"data_path",docstring:"The path+name of saved data file in any format. If saveType is 'block' or 'subblock' data_path is just the path to the directory that all data files have been saved.",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[]}],nodes:[]},{name:"Molecule",docstring:"The central class to construct a molecule from different chemical input formats.\n    This module is built on top of RDKit and OpenBabel python API.\n    We join the forces and strength of these two cheminformatic libraris for a consistent user experience.\n\n    Almost all the molecular descriptors and molecule-based ML models require the chemical informatin as a Molecule object.\n    Several methods are available in this module to facilitate the manipulation of chemical data.",inputs:[{name:"input",docstring:"The representation string or path to a file.",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"input_type",docstring:"The input type. The available types are enlisted here:     - smiles: The input must be SMILES representation of a molecule.     - smarts: The input must be SMARTS representation of a molecule.     - inchi: The input must be InChi representation of a molecule.     - xyz:  The input must be the path to an xyz file.",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:["smiles","smarts","inchi","xyz"]},{name:"kwargs",docstring:"The corresponding RDKit arguments for each of the input types:     - smiles: http://rdkit.org/docs/source/rdkit.Chem.rdmolfiles.html#rdkit.Chem.rdmolfiles.MolFromSmiles     - smarts: http://rdkit.org/docs/source/rdkit.Chem.rdmolfiles.html#rdkit.Chem.rdmolfiles.MolFromSmarts     - inchi: http://rdkit.org/docs/source/rdkit.Chem.inchi.html?highlight=inchi#rdkit.Chem.inchi.MolFromInchi",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"rdkit_molecule",docstring:"The `rdkit.Chem.rdchem.Mol` object",param_type:["object"],returned:!1},{name:"smiles",docstring:"The SMILES string that you get by running the `to_smiles` method.",param_type:["str"],returned:!1},{name:"smarts",docstring:"The SMARTS string that you get by running the `to_smarts` method.",param_type:["str"],returned:!1},{name:"inchi",docstring:"The InChi string that you get by running the `to_inchi` method.",param_type:["str"],returned:!1},{name:"xyz",docstring:"The class object that stores the 3D info. The available attributes in the class are 'geometry', 'atomic_numbers', and 'atomic_symbols'.",param_type:[null],returned:!1}],node_functions:[{name:"hydrogens",docstring:"\n        This function adds/removes hydrogens to/from a prebuilt molecule object.\n\n        Parameters\n        ----------\n        action : str\n            Either 'add' or 'remove', to add hydrogns or remove them from the rdkit molecule.\n\n        kwargs :\n            The arguments that can be passed to the rdkit functions:\n            - `Chem.AddHs`: documentation at http://rdkit.org/docs/source/rdkit.Chem.rdmolops.html?highlight=addhs#rdkit.Chem.rdmolops.AddHs\n            - `Chem.RemoveHs`: documentation at http://rdkit.org/docs/source/rdkit.Chem.rdmolops.html?highlight=addhs#rdkit.Chem.rdmolops.RemoveHs\n\n        Notes\n        -----\n            - The rdkit or pybel molecule object must be created in advance.\n            - Only rdkit or pybel molecule object will be modified in place.\n            - If you remove hydrogens from molecules, the atomic 3D coordinates might not be accurate for the conversion to xyz representation.\n\n        ",inputs:[{name:"action",docstring:"Either 'add' or 'remove', to add hydrogns or remove them from the rdkit molecule.",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"kwargs :",docstring:"The arguments that can be passed to the rdkit functions: - `Chem.AddHs`: documentation at http://rdkit.org/docs/source/rdkit.Chem.rdmolops.html?highlight=addhs#rdkit.Chem.rdmolops.AddHs - `Chem.RemoveHs`: documentation at http://rdkit.org/docs/source/rdkit.Chem.rdmolops.html?highlight=addhs#rdkit.Chem.rdmolops.RemoveHs",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[]},{name:"to_inchi",docstring:"\n        This function creates and stores the InChi string for a pre-built molecule.\n\n        Parameters\n        ----------\n        kwargs :\n            The arguments that can be passed to the rdkit.Chem.MolToInchi function (will be used only if rdkit molecule is available).\n            The documentation is available at: http://rdkit.org/docs/source/rdkit.Chem.inchi.html?highlight=inchi#rdkit.Chem.inchi.MolToInchi\n\n        Notes\n        -----\n            - The rdkit or pybel molecule object must be created in advance.\n            - The molecule will be modified in place.\n\n        ",inputs:[{name:"kwargs :",docstring:"The arguments that can be passed to the rdkit.Chem.MolToInchi function (will be used only if rdkit molecule is available). The documentation is available at: http://rdkit.org/docs/source/rdkit.Chem.inchi.html?highlight=inchi#rdkit.Chem.inchi.MolToInchi",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[]},{name:"to_smarts",docstring:"\n        This function creates and stores the SMARTS string for a pre-built molecule.\n\n        Parameters\n        ----------\n        kwargs :\n            All the arguments that can be passed to the rdkit.Chem.MolToSmarts function.\n            The documentation is available at: http://rdkit.org/docs/source/rdkit.Chem.rdmolfiles.html#rdkit.Chem.rdmolfiles.MolToSmarts\n\n        Notes\n        -----\n            - The rdkit or pybel molecule object must be created in advance.\n            - If only pybel molecule is available, we create an rdkit molecule using its SMILES representation, and then create the SMARTS string using rdkit arguments.\n            - The molecule will be modified in place.\n\n        ",inputs:[{name:"kwargs :",docstring:"All the arguments that can be passed to the rdkit.Chem.MolToSmarts function. The documentation is available at: http://rdkit.org/docs/source/rdkit.Chem.rdmolfiles.html#rdkit.Chem.rdmolfiles.MolToSmarts",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[]},{name:"to_smiles",docstring:"\n        This function creates and stores the SMILES string for a pre-built molecule.\n\n        Parameters\n        ----------\n        kwargs :\n            The arguments for the rdkit.Chem.MolToSmiles function.\n            The documentation is available at: http://rdkit.org/docs/source/rdkit.Chem.rdmolfiles.html#rdkit.Chem.rdmolfiles.MolToSmiles\n\n        Notes\n        -----\n            - The rdkit or pybel molecule object must be created in advance.\n            - If only pybel molecule is available, we create an rdkit molecule using its SMILES representation, and then recreate the SMILES string using rdkit arguments.\n            - The molecule will be modified in place.\n            - For rdkit molecule the SMILES string is canocical by default, unless when one requests kekuleSmiles.\n\n        ",inputs:[{name:"kwargs :",docstring:"The arguments for the rdkit.Chem.MolToSmiles function. The documentation is available at: http://rdkit.org/docs/source/rdkit.Chem.rdmolfiles.html#rdkit.Chem.rdmolfiles.MolToSmiles",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[]},{name:"to_xyz",docstring:"\n        This function creates and stores the xyz coordinates for a pre-built molecule object.\n\n        Parameters\n        ----------\n        optimizer : None or str, optional (default: None)\n            If None, the geometries will be extracted from the available source of 3D structure (if any).\n            Otherwise, any of the 'UFF' or 'MMFF' force fileds should be passed to embed and optimize geometries using 'rdkit.Chem.AllChem.UFFOptimizeMolecule' or\n            'rdkit.Chem.AllChem.MMFFOptimizeMolecule' methods, respectively.\n\n        kwargs :\n            The arguments that can be passed to the corresponding forcefileds.\n            The documentation is available at:\n                - UFFOptimizeMolecule: http://rdkit.org/docs/source/rdkit.Chem.rdForceFieldHelpers.html?highlight=mmff#rdkit.Chem.rdForceFieldHelpers.UFFOptimizeMolecule\n                - MMFFOptimizeMolecule: http://rdkit.org/docs/source/rdkit.Chem.rdForceFieldHelpers.html?highlight=mmff#rdkit.Chem.rdForceFieldHelpers.MMFFOptimizeMolecule\n\n        Notes\n        -----\n            - The geometry will be stored in the `xyz` attribute.\n            - The molecule object must be created in advance.\n            - The hydrogens won't be added to the molecule automatically. You should add it manually using `hydrogens` method.\n            - If the molecule object has been built using 2D representations (e.g., SMILES or InChi), the conformer\n            doesn't exist and you nedd to set the optimizer parameter to any of the force fields.\n            - If the 3D info exist but you still need to run optimization, the 3D structure will be embedded from scratch (i.e., the current atom coordinates will be removed.)\n\n\n        ",inputs:[{name:"optimizer",docstring:"If None, the geometries will be extracted from the available source of 3D structure (if any). Otherwise, any of the 'UFF' or 'MMFF' force fileds should be passed to embed and optimize geometries using 'rdkit.Chem.AllChem.UFFOptimizeMolecule' or 'rdkit.Chem.AllChem.MMFFOptimizeMolecule' methods, respectively.",param_type:["str",null],expected_shape:null,is_optional:!0,default_value:"None",options:null},{name:"kwargs :",docstring:"The arguments that can be passed to the corresponding forcefileds. The documentation is available at:     - UFFOptimizeMolecule: http://rdkit.org/docs/source/rdkit.Chem.rdForceFieldHelpers.html?highlight=mmff#rdkit.Chem.rdForceFieldHelpers.UFFOptimizeMolecule     - MMFFOptimizeMolecule: http://rdkit.org/docs/source/rdkit.Chem.rdForceFieldHelpers.html?highlight=mmff#rdkit.Chem.rdForceFieldHelpers.MMFFOptimizeMolecule",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[]},{name:"visualize",docstring:"\n        This function visualizes the molecule. If both rdkit and pybel objects are avaialble, the rdkit object\n        will be used for visualization.\n\n        Parameters\n        ----------\n        filename: str, optional (default = None)\n            This is the path to the file that you want write the image in it.\n            Tkinter and Python Imaging Library are required for writing the image.\n\n        kwargs:\n            any extra parameter that you want to pass to the rdkit or pybel draw tool.\n            Additional information at:\n                - https://www.rdkit.org/docs/source/rdkit.Chem.Draw.html\n                - http://openbabel.org/docs/dev/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.draw\n\n        Returns\n        -------\n        fig : object\n            You will be able to display this object, e.g., inside the Jupyter Notebook.\n\n        ",inputs:[{name:"filename: str, optional (default = None)",docstring:"This is the path to the file that you want write the image in it. Tkinter and Python Imaging Library are required for writing the image.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"kwargs:",docstring:"any extra parameter that you want to pass to the rdkit or pybel draw tool. Additional information at:     - https://www.rdkit.org/docs/source/rdkit.Chem.Draw.html     - http://openbabel.org/docs/dev/UseTheLibrary/Python_PybelAPI.html#pybel.Molecule.draw",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"fig",docstring:"You will be able to display this object, e.g., inside the Jupyter Notebook.",param_type:["object"],returned:!0}]}],nodes:[]},{name:"RDKitFingerprint",docstring:"\n    This is an interface to the available molecular fingerprints in the RDKit package.",inputs:[{name:"fingerprint_type",docstring:"The type of fingerprint. Available fingerprint types:     - 'hashed_atom_pair' or 'hap'     - 'MACCS' or 'maccs'     - 'morgan'     - 'hashed_topological_torsion' or 'htt'     - 'topological_torsion' or 'tt'",param_type:["str"],expected_shape:null,is_optional:!0,default_value:"Morgan",options:["hashed_atom_pair","MACCS","morgan","hashed_topological_torsion","topological_torsion"]},{name:"vector",docstring:"Available options for vector:     - 'int' : represent counts for each fragment instead of bits             It is not available for 'MACCS'.     - 'bit' : only zeros and ones             It is not available for 'Topological_torsion'.",param_type:["str"],expected_shape:null,is_optional:!0,default_value:"bit",options:["int","bit"]},{name:"n_bits",docstring:"It sets number of elements/bits in the 'bit' type of fingerprint vectors. Not available for:     - 'MACCS' - (MACCS keys have a fixed length of 167 bits)     - 'Topological_torsion' - doesn't return a bit vector at all.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"1024",options:null},{name:"radius",docstring:"only applicable if calculating 'Morgan' fingerprint.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"2",options:null},{name:"kwargs :",docstring:"Any additional argument that should be passed to the rdkit fingerprint function.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"n_molecules_",docstring:"The number of molecules that are received.",param_type:["int"],returned:!1},{name:"fps_",docstring:"The list of rdkit fingerprint objects.",param_type:["list"],returned:!1}],node_functions:[{name:"represent",docstring:"\n        The main function to provide fingerprint representation of input molecule(s).",inputs:[{name:"molecules",docstring:"It must be an instance of chemml.chem.Molecule object or a list of those objects, otherwise a ValueError will be raised. If smiles representation of the molecule (or rdkit molecule object) is not available, we convert the molecule to smiles automatically. However, the automatic conversion may ignore your manual settings, for example removed hydrogens, kekulized, or canonical smiles.",param_type:["object","list"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"features",docstring:"A 2-dimensional pandas dataframe of fingerprint features with same number of rows as number of molecules.",param_type:["dataframe"],returned:!0}]},{name:"store_sparse",docstring:"\n        This function helps you to store higly sparse fingerprint feature sets using `.npz` format for memory efficiency and\n        less store/load time.\n        Another method of this class, `load_sparse`, enables you to load your `.npz` files and convert it back to pandas dataframe.\n\n        Parameters\n        ----------\n        file : str\n            Must be a path to the file with .npz format.\n\n        features : pandas DataFrame\n            Must be the pandas dataframe as you receive it from `represent` method.\n\n        ",inputs:[{name:"file",docstring:"Must be a path to the file with .npz format.",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"features",docstring:"Must be the pandas dataframe as you receive it from `represent` method.",param_type:["dataframe"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[]}],nodes:[]},{name:"XYZ",docstring:"\n    This class stores the information that is typically carried by standard XYZ files.",inputs:[{name:"geometry",docstring:"The numpy array of shape (number_of_atoms, 3). It stores the xyz coordinates for each atom of the molecule.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"atomic_numbers",docstring:"The numpy array of shape (number_of_atoms, 1). It stores the atomic numbers of each atom in the molecule (in the same order as geometry).",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"atomic_symbols",docstring:"The numpy array of shape (number_of_atoms, 1). It stores the atomic symbols of each atom in the molecule (in the same order as geometry).",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[],node_functions:[],nodes:[]}],library:"chemml",module:"chem"},Nm={name:"sklearn.preprocessing",docstring:"",inputs:[],outputs:[],node_functions:[{name:"add_dummy_feature",docstring:"Augment dataset with an additional dummy feature.\n\n    This is useful for fitting an intercept term with implementations which\n    cannot otherwise fit it directly.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix}, shape [n_samples, n_features]\n        Data.\n\n    value : float\n        Value to use for the dummy feature.\n\n    Returns\n    -------\n\n    X : {array, sparse matrix}, shape [n_samples, n_features + 1]\n        Same data with dummy feature added as first column.\n\n    Examples\n    --------\n\n    >>> from sklearn.preprocessing import add_dummy_feature\n    >>> add_dummy_feature([[0, 1], [1, 0]])\n    array([[1., 0., 1.],\n           [1., 1., 0.]])\n    ",inputs:[{name:"X",docstring:"Data.",param_type:["LIST_VALID_OPTIONS","array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:["array-like","sparse matrix","shape [n_samples","n_features]"]},{name:"value",docstring:"Value to use for the dummy feature.",param_type:["float"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X",docstring:"Same data with dummy feature added as first column.",param_type:["LIST_VALID_OPTIONS","array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"binarize",docstring:"Boolean thresholding of array-like or scipy.sparse matrix\n\n    Read more in the :ref:`User Guide <preprocessing_binarization>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix}, shape [n_samples, n_features]\n        The data to binarize, element by element.\n        scipy.sparse matrices should be in CSR or CSC format to avoid an\n        un-necessary copy.\n\n    threshold : float, optional (0.0 by default)\n        Feature values below or equal to this are replaced by 0, above it by 1.\n        Threshold may not be less than 0 for operations on sparse matrices.\n\n    copy : boolean, optional, default True\n        set to False to perform inplace binarization and avoid a copy\n        (if the input is already a numpy array or a scipy.sparse CSR / CSC\n        matrix and if axis is 1).\n\n    See also\n    --------\n    Binarizer: Performs binarization using the ``Transformer`` API\n        (e.g. as part of a preprocessing :class:`sklearn.pipeline.Pipeline`).\n    ",inputs:[{name:"X",docstring:"The data to binarize, element by element. scipy.sparse matrices should be in CSR or CSC format to avoid an un-necessary copy.",param_type:["LIST_VALID_OPTIONS","array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:["array-like","sparse matrix","shape [n_samples","n_features]"]},{name:"threshold",docstring:"Feature values below or equal to this are replaced by 0, above it by 1. Threshold may not be less than 0 for operations on sparse matrices.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"copy",docstring:"set to False to perform inplace binarization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR / CSC matrix and if axis is 1).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"label_binarize",docstring:"Binarize labels in a one-vs-all fashion\n\n    Several regression and binary classification algorithms are\n    available in scikit-learn. A simple way to extend these algorithms\n    to the multi-class classification case is to use the so-called\n    one-vs-all scheme.\n\n    This function makes it possible to compute this transformation for a\n    fixed set of class labels known ahead of time.\n\n    Parameters\n    ----------\n    y : array-like\n        Sequence of integer labels or multilabel data to encode.\n\n    classes : array-like of shape [n_classes]\n        Uniquely holds the label for each class.\n\n    neg_label : int (default: 0)\n        Value with which negative labels must be encoded.\n\n    pos_label : int (default: 1)\n        Value with which positive labels must be encoded.\n\n    sparse_output : boolean (default: False),\n        Set to true if output binary array is desired in CSR sparse format\n\n    Returns\n    -------\n    Y : numpy array or CSR matrix of shape [n_samples, n_classes]\n        Shape will be [n_samples, 1] for binary problems.\n\n    Examples\n    --------\n    >>> from sklearn.preprocessing import label_binarize\n    >>> label_binarize([1, 6], classes=[1, 2, 4, 6])\n    array([[1, 0, 0, 0],\n           [0, 0, 0, 1]])\n\n    The class ordering is preserved:\n\n    >>> label_binarize([1, 6], classes=[1, 6, 4, 2])\n    array([[1, 0, 0, 0],\n           [0, 1, 0, 0]])\n\n    Binary targets transform to a column vector\n\n    >>> label_binarize(['yes', 'no', 'no', 'yes'], classes=['no', 'yes'])\n    array([[1],\n           [0],\n           [0],\n           [1]])\n\n    See also\n    --------\n    LabelBinarizer : class used to wrap the functionality of label_binarize and\n        allow for fitting to classes independently of the transform operation\n    ",inputs:[{name:"y",docstring:"Sequence of integer labels or multilabel data to encode.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"classes",docstring:"Uniquely holds the label for each class.",param_type:["array"],expected_shape:"[n_classes]",is_optional:!1,default_value:null,options:null},{name:"neg_label",docstring:"Value with which negative labels must be encoded.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"0",options:null},{name:"pos_label",docstring:"Value with which positive labels must be encoded.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"1",options:null},{name:"sparse_output",docstring:"Set to true if output binary array is desired in CSR sparse format",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"Y",docstring:"Shape will be [n_samples, 1] for binary problems.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"maxabs_scale",docstring:"Scale each feature to the [-1, 1] range without breaking the sparsity.\n\n    This estimator scales each feature individually such\n    that the maximal absolute value of each feature in the\n    training set will be 1.0.\n\n    This scaler can also be applied to sparse CSR or CSC matrices.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        The data.\n\n    axis : int (0 by default)\n        axis used to scale along. If 0, independently scale each feature,\n        otherwise (if 1) scale each sample.\n\n    copy : boolean, optional, default is True\n        Set to False to perform inplace scaling and avoid a copy (if the input\n        is already a numpy array).\n\n    See also\n    --------\n    MaxAbsScaler: Performs scaling to the [-1, 1] range using the``Transformer`` API\n        (e.g. as part of a preprocessing :class:`sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see :ref:`examples/preprocessing/plot_all_scaling.py\n    <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.\n    ",inputs:[{name:"X",docstring:"The data.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"axis",docstring:"axis used to scale along. If 0, independently scale each feature, otherwise (if 1) scale each sample.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"copy",docstring:"Set to False to perform inplace scaling and avoid a copy (if the input is already a numpy array).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"minmax_scale",docstring:"Transforms features by scaling each feature to a given range.\n\n    This estimator scales and translates each feature individually such\n    that it is in the given range on the training set, i.e. between\n    zero and one.\n\n    The transformation is given by (when ``axis=0``)::\n\n        X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))\n        X_scaled = X_std * (max - min) + min\n\n    where min, max = feature_range.\n\n    The transformation is calculated as (when ``axis=0``)::\n\n       X_scaled = scale * X + min - X.min(axis=0) * scale\n       where scale = (max - min) / (X.max(axis=0) - X.min(axis=0))\n\n    This transformation is often used as an alternative to zero mean,\n    unit variance scaling.\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    .. versionadded:: 0.17\n       *minmax_scale* function interface\n       to :class:`sklearn.preprocessing.MinMaxScaler`.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        The data.\n\n    feature_range : tuple (min, max), default=(0, 1)\n        Desired range of transformed data.\n\n    axis : int (0 by default)\n        axis used to scale along. If 0, independently scale each feature,\n        otherwise (if 1) scale each sample.\n\n    copy : boolean, optional, default is True\n        Set to False to perform inplace scaling and avoid a copy (if the input\n        is already a numpy array).\n\n    See also\n    --------\n    MinMaxScaler: Performs scaling to a given range using the``Transformer`` API\n        (e.g. as part of a preprocessing :class:`sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see :ref:`examples/preprocessing/plot_all_scaling.py\n    <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.\n    ",inputs:[{name:"X",docstring:"The data.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"feature_range",docstring:"Desired range of transformed data.",param_type:["tuple"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"axis",docstring:"axis used to scale along. If 0, independently scale each feature, otherwise (if 1) scale each sample.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"copy",docstring:"Set to False to perform inplace scaling and avoid a copy (if the input is already a numpy array).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"normalize",docstring:"Scale input vectors individually to unit norm (vector length).\n\n    Read more in the :ref:`User Guide <preprocessing_normalization>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix}, shape [n_samples, n_features]\n        The data to normalize, element by element.\n        scipy.sparse matrices should be in CSR format to avoid an\n        un-necessary copy.\n\n    norm : 'l1', 'l2', or 'max', optional ('l2' by default)\n        The norm to use to normalize each non zero sample (or each non-zero\n        feature if axis is 0).\n\n    axis : 0 or 1, optional (1 by default)\n        axis used to normalize the data along. If 1, independently normalize\n        each sample, otherwise (if 0) normalize each feature.\n\n    copy : boolean, optional, default True\n        set to False to perform inplace row normalization and avoid a\n        copy (if the input is already a numpy array or a scipy.sparse\n        CSR matrix and if axis is 1).\n\n    return_norm : boolean, default False\n        whether to return the computed norms\n\n    Returns\n    -------\n    X : {array-like, sparse matrix}, shape [n_samples, n_features]\n        Normalized input X.\n\n    norms : array, shape [n_samples] if axis=1 else [n_features]\n        An array of norms along given axis for X.\n        When X is sparse, a NotImplementedError will be raised\n        for norm 'l1' or 'l2'.\n\n    See also\n    --------\n    Normalizer: Performs normalization using the ``Transformer`` API\n        (e.g. as part of a preprocessing :class:`sklearn.pipeline.Pipeline`).\n\n    Notes\n    -----\n    For a comparison of the different scalers, transformers, and normalizers,\n    see :ref:`examples/preprocessing/plot_all_scaling.py\n    <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.\n\n    ",inputs:[{name:"X",docstring:"The data to normalize, element by element. scipy.sparse matrices should be in CSR format to avoid an un-necessary copy.",param_type:["LIST_VALID_OPTIONS","array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:["array-like","sparse matrix","shape [n_samples","n_features]"]},{name:"norm",docstring:"The norm to use to normalize each non zero sample (or each non-zero feature if axis is 0).",param_type:[null],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"axis",docstring:"axis used to normalize the data along. If 1, independently normalize each sample, otherwise (if 0) normalize each feature.",param_type:[null],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"copy",docstring:"set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR matrix and if axis is 1).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"return_norm",docstring:"whether to return the computed norms",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X",docstring:"Normalized input X.",param_type:["LIST_VALID_OPTIONS","array"],returned:!0},{name:"norms",docstring:"An array of norms along given axis for X. When X is sparse, a NotImplementedError will be raised for norm 'l1' or 'l2'.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"power_transform",docstring:"\n    Power transforms are a family of parametric, monotonic transformations\n    that are applied to make data more Gaussian-like. This is useful for\n    modeling issues related to heteroscedasticity (non-constant variance),\n    or other situations where normality is desired.\n\n    Currently, power_transform supports the Box-Cox transform and the\n    Yeo-Johnson transform. The optimal parameter for stabilizing variance and\n    minimizing skewness is estimated through maximum likelihood.\n\n    Box-Cox requires input data to be strictly positive, while Yeo-Johnson\n    supports both positive or negative data.\n\n    By default, zero-mean, unit-variance normalization is applied to the\n    transformed data.\n\n    Read more in the :ref:`User Guide <preprocessing_transformer>`.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        The data to be transformed using a power transformation.\n\n    method : str\n        The power transform method. Available methods are:\n\n        - 'yeo-johnson' [1]_, works with positive and negative values\n        - 'box-cox' [2]_, only works with strictly positive values\n\n        The default method will be changed from 'box-cox' to 'yeo-johnson'\n        in version 0.23. To suppress the FutureWarning, explicitly set the\n        parameter.\n\n    standardize : boolean, default=True\n        Set to True to apply zero-mean, unit-variance normalization to the\n        transformed output.\n\n    copy : boolean, optional, default=True\n        Set to False to perform inplace computation during transformation.\n\n    Returns\n    -------\n    X_trans : array-like, shape (n_samples, n_features)\n        The transformed data.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import power_transform\n    >>> data = [[1, 2], [3, 2], [4, 5]]\n    >>> print(power_transform(data, method='box-cox'))  # doctest: +ELLIPSIS\n    [[-1.332... -0.707...]\n     [ 0.256... -0.707...]\n     [ 1.076...  1.414...]]\n\n    See also\n    --------\n    PowerTransformer : Equivalent transformation with the\n        ``Transformer`` API (e.g. as part of a preprocessing\n        :class:`sklearn.pipeline.Pipeline`).\n\n    quantile_transform : Maps data to a standard normal distribution with\n        the parameter `output_distribution='normal'`.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in ``fit``, and maintained\n    in ``transform``.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see :ref:`examples/preprocessing/plot_all_scaling.py\n    <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.\n\n    References\n    ----------\n\n    .. [1] I.K. Yeo and R.A. Johnson, \"A new family of power transformations to\n           improve normality or symmetry.\" Biometrika, 87(4), pp.954-959,\n           (2000).\n\n    .. [2] G.E.P. Box and D.R. Cox, \"An Analysis of Transformations\", Journal\n           of the Royal Statistical Society B, 26, 211-252 (1964).\n    ",inputs:[{name:"X",docstring:"The data to be transformed using a power transformation.",param_type:["array"],expected_shape:"(n_samples, n_features)",is_optional:!1,default_value:null,options:null},{name:"method",docstring:"The power transform method. Available methods are:  - 'yeo-johnson' [1]_, works with positive and negative values - 'box-cox' [2]_, only works with strictly positive values  The default method will be changed from 'box-cox' to 'yeo-johnson' in version 0.23. To suppress the FutureWarning, explicitly set the parameter.",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"standardize",docstring:"Set to True to apply zero-mean, unit-variance normalization to the transformed output.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"copy",docstring:"Set to False to perform inplace computation during transformation.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_trans",docstring:"The transformed data.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"quantile_transform",docstring:"Transform features using quantiles information.\n\n    This method transforms the features to follow a uniform or a normal\n    distribution. Therefore, for a given feature, this transformation tends\n    to spread out the most frequent values. It also reduces the impact of\n    (marginal) outliers: this is therefore a robust preprocessing scheme.\n\n    The transformation is applied on each feature independently. First an\n    estimate of the cumulative distribution function of a feature is\n    used to map the original values to a uniform distribution. The obtained\n    values are then mapped to the desired output distribution using the\n    associated quantile function. Features values of new/unseen data that fall\n    below or above the fitted range will be mapped to the bounds of the output\n    distribution. Note that this transform is non-linear. It may distort linear\n    correlations between variables measured at the same scale but renders\n    variables measured at different scales more directly comparable.\n\n    Read more in the :ref:`User Guide <preprocessing_transformer>`.\n\n    Parameters\n    ----------\n    X : array-like, sparse matrix\n        The data to transform.\n\n    axis : int, (default=0)\n        Axis used to compute the means and standard deviations along. If 0,\n        transform each feature, otherwise (if 1) transform each sample.\n\n    n_quantiles : int, optional (default=1000 or n_samples)\n        Number of quantiles to be computed. It corresponds to the number\n        of landmarks used to discretize the cumulative distribution function.\n        If n_quantiles is larger than the number of samples, n_quantiles is set\n        to the number of samples as a larger number of quantiles does not give\n        a better approximation of the cumulative distribution function\n        estimator.\n\n    output_distribution : str, optional (default='uniform')\n        Marginal distribution for the transformed data. The choices are\n        'uniform' (default) or 'normal'.\n\n    ignore_implicit_zeros : bool, optional (default=False)\n        Only applies to sparse matrices. If True, the sparse entries of the\n        matrix are discarded to compute the quantile statistics. If False,\n        these entries are treated as zeros.\n\n    subsample : int, optional (default=1e5)\n        Maximum number of samples used to estimate the quantiles for\n        computational efficiency. Note that the subsampling procedure may\n        differ for value-identical sparse and dense matrices.\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by np.random. Note that this is used by subsampling and smoothing\n        noise.\n\n    copy : boolean, optional, (default=\"warn\")\n        Set to False to perform inplace transformation and avoid a copy (if the\n        input is already a numpy array). If True, a copy of `X` is transformed,\n        leaving the original `X` unchanged\n\n        .. deprecated:: 0.21\n            The default value of parameter `copy` will be changed from False\n            to True in 0.23. The current default of False is being changed to\n            make it more consistent with the default `copy` values of other\n            functions in :mod:`sklearn.preprocessing.data`. Furthermore, the\n            current default of False may have unexpected side effects by\n            modifying the value of `X` inplace\n\n    Returns\n    -------\n    Xt : ndarray or sparse matrix, shape (n_samples, n_features)\n        The transformed data.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.preprocessing import quantile_transform\n    >>> rng = np.random.RandomState(0)\n    >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)\n    >>> quantile_transform(X, n_quantiles=10, random_state=0, copy=True)\n    ... # doctest: +ELLIPSIS\n    array([...])\n\n    See also\n    --------\n    QuantileTransformer : Performs quantile-based scaling using the\n        ``Transformer`` API (e.g. as part of a preprocessing\n        :class:`sklearn.pipeline.Pipeline`).\n    power_transform : Maps data to a normal distribution using a\n        power transformation.\n    scale : Performs standardization that is faster, but less robust\n        to outliers.\n    robust_scale : Performs robust standardization that removes the influence\n        of outliers but does not put outliers and inliers on the same scale.\n\n    Notes\n    -----\n    NaNs are treated as missing values: disregarded in fit, and maintained in\n    transform.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see :ref:`examples/preprocessing/plot_all_scaling.py\n    <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.\n    ",inputs:[{name:"X",docstring:"The data to transform.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"axis",docstring:"Axis used to compute the means and standard deviations along. If 0, transform each feature, otherwise (if 1) transform each sample.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"0",options:null},{name:"n_quantiles",docstring:"Number of quantiles to be computed. It corresponds to the number of landmarks used to discretize the cumulative distribution function. If n_quantiles is larger than the number of samples, n_quantiles is set to the number of samples as a larger number of quantiles does not give a better approximation of the cumulative distribution function estimator.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"1000 or n_samples",options:null},{name:"output_distribution",docstring:"Marginal distribution for the transformed data. The choices are 'uniform' (default) or 'normal'.",param_type:["str"],expected_shape:null,is_optional:!0,default_value:"uniform",options:null},{name:"ignore_implicit_zeros",docstring:"Only applies to sparse matrices. If True, the sparse entries of the matrix are discarded to compute the quantile statistics. If False, these entries are treated as zeros.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null},{name:"subsample",docstring:"Maximum number of samples used to estimate the quantiles for computational efficiency. Note that the subsampling procedure may differ for value-identical sparse and dense matrices.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"1e5",options:null},{name:"random_state",docstring:"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random. Note that this is used by subsampling and smoothing noise.",param_type:["int",null],expected_shape:null,is_optional:!0,default_value:"None",options:null},{name:"copy",docstring:"Set to False to perform inplace transformation and avoid a copy (if the input is already a numpy array). If True, a copy of `X` is transformed, leaving the original `X` unchanged  .. deprecated:: 0.21     The default value of parameter `copy` will be changed from False     to True in 0.23. The current default of False is being changed to     make it more consistent with the default `copy` values of other     functions in :mod:`sklearn.preprocessing.data`. Furthermore, the     current default of False may have unexpected side effects by     modifying the value of `X` inplace",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:'"warn"',options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"Xt",docstring:"The transformed data.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"robust_scale",docstring:"Standardize a dataset along any axis\n\n    Center to the median and component wise scale\n    according to the interquartile range.\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    Parameters\n    ----------\n    X : array-like\n        The data to center and scale.\n\n    axis : int (0 by default)\n        axis used to compute the medians and IQR along. If 0,\n        independently scale each feature, otherwise (if 1) scale\n        each sample.\n\n    with_centering : boolean, True by default\n        If True, center the data before scaling.\n\n    with_scaling : boolean, True by default\n        If True, scale the data to unit variance (or equivalently,\n        unit standard deviation).\n\n    quantile_range : tuple (q_min, q_max), 0.0 < q_min < q_max < 100.0\n        Default: (25.0, 75.0) = (1st quantile, 3rd quantile) = IQR\n        Quantile range used to calculate ``scale_``.\n\n        .. versionadded:: 0.18\n\n    copy : boolean, optional, default is True\n        set to False to perform inplace row normalization and avoid a\n        copy (if the input is already a numpy array or a scipy.sparse\n        CSR matrix and if axis is 1).\n\n    Notes\n    -----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_centering=False` (in that case, only variance scaling will be\n    performed on the features of the CSR matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSR matrix.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see :ref:`examples/preprocessing/plot_all_scaling.py\n    <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.\n\n    See also\n    --------\n    RobustScaler: Performs centering and scaling using the ``Transformer`` API\n        (e.g. as part of a preprocessing :class:`sklearn.pipeline.Pipeline`).\n    ",inputs:[{name:"X",docstring:"The data to center and scale.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"axis",docstring:"axis used to compute the medians and IQR along. If 0, independently scale each feature, otherwise (if 1) scale each sample.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"with_centering",docstring:"If True, center the data before scaling.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"with_scaling",docstring:"If True, scale the data to unit variance (or equivalently, unit standard deviation).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"quantile_range",docstring:"Default: (25.0, 75.0) = (1st quantile, 3rd quantile) = IQR Quantile range used to calculate ``scale_``.  .. versionadded:: 0.18",param_type:["tuple"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"copy",docstring:"set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR matrix and if axis is 1).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"scale",docstring:"Standardize a dataset along any axis\n\n    Center to the mean and component wise scale to unit variance.\n\n    Read more in the :ref:`User Guide <preprocessing_scaler>`.\n\n    Parameters\n    ----------\n    X : {array-like, sparse matrix}\n        The data to center and scale.\n\n    axis : int (0 by default)\n        axis used to compute the means and standard deviations along. If 0,\n        independently standardize each feature, otherwise (if 1) standardize\n        each sample.\n\n    with_mean : boolean, True by default\n        If True, center the data before scaling.\n\n    with_std : boolean, True by default\n        If True, scale the data to unit variance (or equivalently,\n        unit standard deviation).\n\n    copy : boolean, optional, default True\n        set to False to perform inplace row normalization and avoid a\n        copy (if the input is already a numpy array or a scipy.sparse\n        CSC matrix and if axis is 1).\n\n    Notes\n    -----\n    This implementation will refuse to center scipy.sparse matrices\n    since it would make them non-sparse and would potentially crash the\n    program with memory exhaustion problems.\n\n    Instead the caller is expected to either set explicitly\n    `with_mean=False` (in that case, only variance scaling will be\n    performed on the features of the CSC matrix) or to call `X.toarray()`\n    if he/she expects the materialized dense array to fit in memory.\n\n    To avoid memory copy the caller should pass a CSC matrix.\n\n    NaNs are treated as missing values: disregarded to compute the statistics,\n    and maintained during the data transformation.\n\n    We use a biased estimator for the standard deviation, equivalent to\n    `numpy.std(x, ddof=0)`. Note that the choice of `ddof` is unlikely to\n    affect model performance.\n\n    For a comparison of the different scalers, transformers, and normalizers,\n    see :ref:`examples/preprocessing/plot_all_scaling.py\n    <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.\n\n    See also\n    --------\n    StandardScaler: Performs scaling to unit variance using the``Transformer`` API\n        (e.g. as part of a preprocessing :class:`sklearn.pipeline.Pipeline`).\n\n    ",inputs:[{name:"X",docstring:"The data to center and scale.",param_type:["LIST_VALID_OPTIONS","array"],expected_shape:null,is_optional:!1,default_value:null,options:["array-like","sparse matrix"]},{name:"axis",docstring:"axis used to compute the means and standard deviations along. If 0, independently standardize each feature, otherwise (if 1) standardize each sample.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"with_mean",docstring:"If True, center the data before scaling.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"with_std",docstring:"If True, scale the data to unit variance (or equivalently, unit standard deviation).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"",options:null},{name:"copy",docstring:"set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSC matrix and if axis is 1).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[{name:"MaxAbsScaler",docstring:"Scale each feature by its maximum absolute value.\n\n    This estimator scales and translates each feature individually such\n    that the maximal absolute value of each feature in the\n    training set will be 1.0. It does not shift/center the data, and\n    thus does not destroy any sparsity.",inputs:[{name:"copy",docstring:"Set to False to perform inplace scaling and avoid a copy (if the input is already a numpy array).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[{name:"scale_",docstring:"Per feature relative scaling of the data.",param_type:["array"],returned:!1},{name:"max_abs_",docstring:"Per feature maximum absolute value.",param_type:["array"],returned:!1},{name:"n_samples_seen_",docstring:"The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across ``partial_fit`` calls.",param_type:["int"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_more_tags",docstring:"None",inputs:[],outputs:[]},{name:"_reset",docstring:"Reset internal data-dependent state of the scaler, if necessary.\n\n        __init__ parameters are not touched.\n        ",inputs:[],outputs:[]},{name:"fit",docstring:"Compute the maximum absolute value to be used for later scaling.",inputs:[{name:"X",docstring:"The data used to compute the per-feature minimum and maximum used for later scaling along the features axis.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"fit_transform",docstring:"Fit to data, then transform it.\n\n        Fits transformer to X and y with optional parameters fit_params\n        and returns a transformed version of X.",inputs:[{name:"X",docstring:"Training set.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Target values.",param_type:["array"],expected_shape:"[n_samples]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_new",docstring:"Transformed array.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"inverse_transform",docstring:"Scale back the data to the original representation",inputs:[{name:"X",docstring:"The data that should be transformed back.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"partial_fit",docstring:"Online computation of max absolute value of X for later scaling.\n        All of X is processed as a single batch. This is intended for cases\n        when `fit` is not feasible due to very large number of `n_samples`\n        or because X is read from a continuous stream.",inputs:[{name:"X",docstring:"The data used to compute the mean and standard deviation used for later scaling along the features axis.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Ignored",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"transform",docstring:"Scale the data",inputs:[{name:"X",docstring:"The data that should be scaled.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[]},{name:"MinMaxScaler",docstring:"Transforms features by scaling each feature to a given range.\n\n    This estimator scales and translates each feature individually such\n    that it is in the given range on the training set, e.g. between\n    zero and one.\n\n    The transformation is given by::\n\n        X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))\n        X_scaled = X_std * (max - min) + min\n\n    where min, max = feature_range.\n\n    The transformation is calculated as::\n\n        X_scaled = scale * X + min - X.min(axis=0) * scale\n        where scale = (max - min) / (X.max(axis=0) - X.min(axis=0))\n\n    This transformation is often used as an alternative to zero mean,\n    unit variance scaling.",inputs:[{name:"feature_range",docstring:"Desired range of transformed data.",param_type:["tuple"],expected_shape:null,is_optional:!0,default_value:"(0, 1)",options:null},{name:"copy",docstring:"Set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[{name:"min_",docstring:"Per feature adjustment for minimum. Equivalent to ``min - X.min(axis=0) * self.scale_``",param_type:["array"],returned:!1},{name:"scale_",docstring:"Per feature relative scaling of the data. Equivalent to ``(max - min) / (X.max(axis=0) - X.min(axis=0))``",param_type:["array"],returned:!1},{name:"data_min_",docstring:"Per feature minimum seen in the data",param_type:["array"],returned:!1},{name:"data_max_",docstring:"Per feature maximum seen in the data",param_type:["array"],returned:!1},{name:"data_range_",docstring:"Per feature range ``(data_max_ - data_min_)`` seen in the data",param_type:["array"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_more_tags",docstring:"None",inputs:[],outputs:[]},{name:"_reset",docstring:"Reset internal data-dependent state of the scaler, if necessary.\n\n        __init__ parameters are not touched.\n        ",inputs:[],outputs:[]},{name:"fit",docstring:"Compute the minimum and maximum to be used for later scaling.",inputs:[{name:"X",docstring:"The data used to compute the per-feature minimum and maximum used for later scaling along the features axis.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"fit_transform",docstring:"Fit to data, then transform it.\n\n        Fits transformer to X and y with optional parameters fit_params\n        and returns a transformed version of X.",inputs:[{name:"X",docstring:"Training set.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Target values.",param_type:["array"],expected_shape:"[n_samples]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_new",docstring:"Transformed array.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"inverse_transform",docstring:"Undo the scaling of X according to feature_range.",inputs:[{name:"X",docstring:"Input data that will be transformed. It cannot be sparse.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"partial_fit",docstring:"Online computation of min and max on X for later scaling.\n        All of X is processed as a single batch. This is intended for cases\n        when `fit` is not feasible due to very large number of `n_samples`\n        or because X is read from a continuous stream.",inputs:[{name:"X",docstring:"The data used to compute the mean and standard deviation used for later scaling along the features axis.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Ignored",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"transform",docstring:"Scaling features of X according to feature_range.",inputs:[{name:"X",docstring:"Input data that will be transformed.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[]},{name:"Normalizer",docstring:"Normalize samples individually to unit norm.\n\n    Each sample (i.e. each row of the data matrix) with at least one\n    non zero component is rescaled independently of other samples so\n    that its norm (l1 or l2) equals one.\n\n    This transformer is able to work both with dense numpy arrays and\n    scipy.sparse matrix (use CSR format if you want to avoid the burden of\n    a copy / conversion).\n\n    Scaling inputs to unit norms is a common operation for text\n    classification or clustering for instance. For instance the dot\n    product of two l2-normalized TF-IDF vectors is the cosine similarity\n    of the vectors and is the base similarity metric for the Vector\n    Space Model commonly used by the Information Retrieval community.",inputs:[{name:"norm",docstring:"The norm to use to normalize each non zero sample.",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,is_optional:!0,default_value:"l2",options:["l1","l2","max"]},{name:"copy",docstring:"set to False to perform inplace row normalization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR matrix).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_more_tags",docstring:"None",inputs:[],outputs:[]},{name:"fit",docstring:"Do nothing and return the estimator unchanged\n\n        This method is just there to implement the usual API and hence\n        work in pipelines.",inputs:[{name:"X",docstring:"Data",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"fit_transform",docstring:"Fit to data, then transform it.\n\n        Fits transformer to X and y with optional parameters fit_params\n        and returns a transformed version of X.",inputs:[{name:"X",docstring:"Training set.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Target values.",param_type:["array"],expected_shape:"[n_samples]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_new",docstring:"Transformed array.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"transform",docstring:"Scale each non zero row of X to unit norm",inputs:[{name:"X",docstring:"The data to normalize, row by row. scipy.sparse matrices should be in CSR format to avoid an un-necessary copy.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"copy",docstring:"Copy the input X or not.",param_type:["bool",null],expected_shape:null,is_optional:!0,default_value:"None",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[]},{name:"OneHotEncoder",docstring:"Encode categorical integer features as a one-hot numeric array.\n\n    The input to this transformer should be an array-like of integers or\n    strings, denoting the values taken on by categorical (discrete) features.\n    The features are encoded using a one-hot (aka 'one-of-K' or 'dummy')\n    encoding scheme. This creates a binary column for each category and\n    returns a sparse matrix or dense array.\n\n    By default, the encoder derives the categories based on the unique values\n    in each feature. Alternatively, you can also specify the `categories`\n    manually.\n    The OneHotEncoder previously assumed that the input features take on\n    values in the range [0, max(values)). This behaviour is deprecated.\n\n    This encoding is needed for feeding categorical data to many scikit-learn\n    estimators, notably linear models and SVMs with the standard kernels.\n\n    Note: a one-hot encoding of y labels should use a LabelBinarizer\n    instead.",inputs:[{name:"categories",docstring:"Categories (unique values) per feature:  - 'auto' : Determine categories automatically from the training data. - list : ``categories[i]`` holds the categories expected in the ith   column. The passed categories should not mix strings and numeric   values within a single feature, and should be sorted in case of   numeric values.  The used categories can be found in the ``categories_`` attribute.",param_type:["str","array","list"],expected_shape:null,is_optional:!0,default_value:"auto.",options:null},{name:"drop",docstring:"Specifies a methodology to use to drop one of the categories per feature. This is useful in situations where perfectly collinear features cause problems, such as when feeding the resulting data into a neural network or an unregularized regression.  - None : retain all features (the default). - 'first' : drop the first category in each feature. If only one   category is present, the feature will be dropped entirely. - array : ``drop[i]`` is the category in feature ``X[:, i]`` that   should be dropped.",param_type:["array","list","str"],expected_shape:"(n_features,)",is_optional:!0,default_value:"None",options:null},{name:"sparse",docstring:"Will return sparse matrix if set True else will return an array.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"dtype",docstring:"Desired dtype of output.",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"np.float",options:null},{name:"handle_unknown",docstring:"Whether to raise an error or ignore if an unknown categorical feature is present during transform (default is to raise). When this parameter is set to 'ignore' and an unknown category is encountered during transform, the resulting one-hot encoded columns for this feature will be all zeros. In the inverse transform, an unknown category will be denoted as None.",param_type:["LIST_VALID_OPTIONS"],expected_shape:null,is_optional:!0,default_value:"error",options:["error","ignore"]},{name:"n_values",docstring:"Number of values per feature.  - 'auto' : determine value range from training data. - int : number of categorical values per feature.         Each feature value should be in ``range(n_values)`` - array : ``n_values[i]`` is the number of categorical values in           ``X[:, i]``. Each feature value should be           in ``range(n_values[i])``",param_type:["array","int","str"],expected_shape:null,is_optional:!0,default_value:"auto",options:null},{name:"categorical_features",docstring:"Specify what features are treated as categorical.  - 'all': All features are treated as categorical. - array of indices: Array of categorical feature indices. - mask: Array of length n_features and with dtype=bool.  Non-categorical features are always stacked to the right of the matrix.",param_type:["array","str"],expected_shape:null,is_optional:!0,default_value:"all",options:null}],outputs:[{name:"categories_",docstring:"The categories of each feature determined during fitting (in order of the features in X and corresponding with the output of ``transform``). This includes the category specified in ``drop`` (if any).",param_type:["array","list"],returned:!1},{name:"drop_idx_",docstring:"``drop_idx_[i]`` is\xa0the index in ``categories_[i]`` of the category to be dropped for each feature. None if all the transformed features will be retained.",param_type:["array"],returned:!1},{name:"active_features_",docstring:"Indices for active features, meaning values that actually occur in the training set. Only available when n_values is ``'auto'``.  .. deprecated:: 0.20     The ``active_features_`` attribute was deprecated in version     0.20 and will be removed in 0.22.",param_type:["array"],returned:!1},{name:"feature_indices_",docstring:"Indices to feature ranges. Feature ``i`` in the original data is mapped to features from ``feature_indices_[i]`` to ``feature_indices_[i+1]`` (and then potentially masked by ``active_features_`` afterwards)  .. deprecated:: 0.20     The ``feature_indices_`` attribute was deprecated in version     0.20 and will be removed in 0.22.",param_type:["array"],returned:!1},{name:"n_values_",docstring:"Maximum number of values per feature.  .. deprecated:: 0.20     The ``n_values_`` attribute was deprecated in version     0.20 and will be removed in 0.22.",param_type:["array"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_check_X",docstring:"\n        Perform custom check_array:\n        - convert list of strings to object dtype\n        - check for missing values for object dtype data (check_array does\n          not do that)\n        - return list of features (arrays): this list of features is\n          constructed feature by feature to preserve the data types\n          of pandas DataFrame columns, as otherwise information is lost\n          and cannot be used, eg for the `categories_` attribute.\n\n        ",inputs:[],outputs:[]},{name:"_compute_drop_idx",docstring:"None",inputs:[],outputs:[]},{name:"_fit",docstring:"None",inputs:[],outputs:[]},{name:"_get_feature",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_handle_deprecations",docstring:"None",inputs:[],outputs:[]},{name:"_legacy_fit_transform",docstring:"Assumes X contains only categorical features.",inputs:[],outputs:[]},{name:"_legacy_transform",docstring:"Assumes X contains only categorical features.",inputs:[],outputs:[]},{name:"_transform",docstring:"None",inputs:[],outputs:[]},{name:"_transform_new",docstring:"New implementation assuming categorical input",inputs:[],outputs:[]},{name:"_validate_keywords",docstring:"None",inputs:[],outputs:[]},{name:"fit",docstring:"Fit OneHotEncoder to X.",inputs:[{name:"X",docstring:"The data to determine the categories of each feature.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"",docstring:"",param_type:[null],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"fit_transform",docstring:"Fit OneHotEncoder to X, then transform X.\n\n        Equivalent to fit(X).transform(X) but more convenient.",inputs:[{name:"X",docstring:"The data to encode.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_out",docstring:"Transformed input.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"get_feature_names",docstring:"Return feature names for output features.",inputs:[{name:"input_features",docstring:'String names for input features if available. By default, "x0", "x1", ... "xn_features" is used.',param_type:["list"],expected_shape:null,is_optional:!0,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"output_feature_names",docstring:"",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"inverse_transform",docstring:"Convert the back data to the original representation.\n\n        In case unknown categories are encountered (all zeros in the\n        one-hot encoding), ``None`` is used to represent this category.",inputs:[{name:"X",docstring:"The transformed data.",param_type:["array"],expected_shape:"[n_samples, n_encoded_features]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_tr",docstring:"Inverse transformed array.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"transform",docstring:"Transform X using one-hot encoding.",inputs:[{name:"X",docstring:"The data to encode.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_out",docstring:"Transformed input.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[]},{name:"StandardScaler",docstring:"Standardize features by removing the mean and scaling to unit variance\n\n    The standard score of a sample `x` is calculated as:\n\n        z = (x - u) / s\n\n    where `u` is the mean of the training samples or zero if `with_mean=False`,\n    and `s` is the standard deviation of the training samples or one if\n    `with_std=False`.\n\n    Centering and scaling happen independently on each feature by computing\n    the relevant statistics on the samples in the training set. Mean and\n    standard deviation are then stored to be used on later data using the\n    `transform` method.\n\n    Standardization of a dataset is a common requirement for many\n    machine learning estimators: they might behave badly if the\n    individual features do not more or less look like standard normally\n    distributed data (e.g. Gaussian with 0 mean and unit variance).\n\n    For instance many elements used in the objective function of\n    a learning algorithm (such as the RBF kernel of Support Vector\n    Machines or the L1 and L2 regularizers of linear models) assume that\n    all features are centered around 0 and have variance in the same\n    order. If a feature has a variance that is orders of magnitude larger\n    that others, it might dominate the objective function and make the\n    estimator unable to learn from other features correctly as expected.\n\n    This scaler can also be applied to sparse CSR or CSC matrices by passing\n    `with_mean=False` to avoid breaking the sparsity structure of the data.",inputs:[{name:"copy",docstring:"If False, try to avoid a copy and do inplace scaling instead. This is not guaranteed to always work inplace; e.g. if the data is not a NumPy array or scipy.sparse CSR matrix, a copy may still be returned.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"with_mean",docstring:"If True, center the data before scaling. This does not work (and will raise an exception) when attempted on sparse matrices, because centering them entails building a dense matrix which in common use cases is likely to be too large to fit in memory.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null},{name:"with_std",docstring:"If True, scale the data to unit variance (or equivalently, unit standard deviation).",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True",options:null}],outputs:[{name:"scale_",docstring:"Per feature relative scaling of the data. This is calculated using `np.sqrt(var_)`. Equal to ``None`` when ``with_std=False``.  .. versionadded:: 0.17    *scale_*",param_type:["array",null],returned:!1},{name:"mean_",docstring:"The mean value for each feature in the training set. Equal to ``None`` when ``with_mean=False``.",param_type:["array",null],returned:!1},{name:"var_",docstring:"The variance for each feature in the training set. Used to compute `scale_`. Equal to ``None`` when ``with_std=False``.",param_type:["array",null],returned:!1},{name:"n_samples_seen_",docstring:"The number of samples processed by the estimator for each feature. If there are not missing samples, the ``n_samples_seen`` will be an integer, otherwise it will be an array. Will be reset on new calls to fit, but increments across ``partial_fit`` calls.",param_type:["array","int"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_more_tags",docstring:"None",inputs:[],outputs:[]},{name:"_reset",docstring:"Reset internal data-dependent state of the scaler, if necessary.\n\n        __init__ parameters are not touched.\n        ",inputs:[],outputs:[]},{name:"fit",docstring:"Compute the mean and std to be used for later scaling.",inputs:[{name:"X",docstring:"The data used to compute the mean and standard deviation used for later scaling along the features axis.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Ignored",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"fit_transform",docstring:"Fit to data, then transform it.\n\n        Fits transformer to X and y with optional parameters fit_params\n        and returns a transformed version of X.",inputs:[{name:"X",docstring:"Training set.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Target values.",param_type:["array"],expected_shape:"[n_samples]",is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_new",docstring:"Transformed array.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"inverse_transform",docstring:"Scale back the data to the original representation",inputs:[{name:"X",docstring:"The data used to scale along the features axis.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"copy",docstring:"Copy the input X or not.",param_type:["bool",null],expected_shape:null,is_optional:!0,default_value:"None",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"X_tr",docstring:"Transformed array.",param_type:["array"],returned:!0},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"partial_fit",docstring:"Online computation of mean and std on X for later scaling.\n        All of X is processed as a single batch. This is intended for cases\n        when `fit` is not feasible due to very large number of `n_samples`\n        or because X is read from a continuous stream.",inputs:[{name:"X",docstring:"The data used to compute the mean and standard deviation used for later scaling along the features axis.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"y",docstring:"Ignored",param_type:[null],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]},{name:"transform",docstring:"Perform standardization by centering and scaling",inputs:[{name:"X",docstring:"The data used to scale along the features axis.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null,options:null},{name:"copy",docstring:"Copy the input X or not.",param_type:["bool",null],expected_shape:null,is_optional:!0,default_value:"None",options:null},{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:!1,options:null}],outputs:[{name:"obj",docstring:"True/False flag to indicate reusing the same instance instead of creating a new one",param_type:["bool"],returned:!0}]}],nodes:[]}],library:"sklearn",module:"preprocessing"},jm={name:"chemml.wrapper.preprocessing",docstring:"",inputs:[],outputs:[],node_functions:[],nodes:[{name:"SplitColumns",docstring:"\n    This method splits a data matrix by columns.",inputs:[{name:"selection",docstring:"if positive integer, it's the number of columns to be selected from left side of dataframe and returns as first data frame (df1). if negative integer, it's the number of columns to be selected from right side of dataframe and returns as first data frame (df1).",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"1",options:null}],outputs:[],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"fit",display_name:"split_columns",docstring:"\n        The main function to split the input dataframe.",inputs:[{name:"X",docstring:"the input array",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"X1",docstring:"Left part of the split data matrix",param_type:["array"],returned:!0},{name:"X2",docstring:"Right part of the split data matrix",param_type:["array"],returned:!0}]}],nodes:[]},{name:"TrainTestSplit",docstring:"A module to split a data matrix into train and test (or validation) samples",inputs:[{name:"test_fraction",docstring:"The fraction of samples to be selected for the test. If a value not in (0, 1.0) is provided we default to 0.25",param_type:["float"],expected_shape:null,is_optional:!0,default_value:"0.25",options:null}],outputs:[],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"split",display_name:"train_test_split",docstring:"The function to call for performing the split of the data matrix",inputs:[{name:"X",docstring:"the input array",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null,options:null}],outputs:[{name:"X1",docstring:"The training data matrix with ((1 - test_fraction) * n_samples) rows",param_type:["array"],returned:!0},{name:"X2",docstring:"The testing data matrix with (test_fraction * n_samples) rows",param_type:["array"],returned:!0}]}],nodes:[]}],library:"chemml",module:"wrapper.preprocessing"},zm={name:"sklearn.model_selection",docstring:"",inputs:[],outputs:[],node_functions:[{name:"train_test_split",docstring:"Split arrays or matrices into random train and test subsets\n\n    Quick utility that wraps input validation and\n    ``next(ShuffleSplit().split(X, y))`` and application to input data\n    into a single call for splitting (and optionally subsampling) data in a\n    oneliner.",inputs:[{name:"*arrays",docstring:"Allowed inputs are lists, numpy arrays, scipy-sparse matrices or pandas dataframes.",param_type:["list"],expected_shape:null,is_optional:!1,default_value:null},{name:"test_size",docstring:"If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split. If int, represents the absolute number of test samples. If None, the value is set to the complement of the train size. If ``train_size`` is also None, it will be set to 0.25.",param_type:["int","float",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"train_size",docstring:"If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split. If int, represents the absolute number of train samples. If None, the value is automatically set to the complement of the test size.",param_type:["int","float",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"shuffle",docstring:"Whether or not to shuffle the data before splitting. If shuffle=False then stratify must be None.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True"},{name:"stratify",docstring:"If not None, data is split in a stratified fashion, using this as the class labels.",param_type:["array",null],expected_shape:null,is_optional:!0,default_value:"None"}],outputs:[{name:"splitting",docstring:"List containing train-test split of inputs.",param_type:["array","list"],returned:!0}]}],nodes:[{name:"train_test_split",docstring:"Split arrays or matrices into random train and test subsets\n\n    Quick utility that wraps input validation and\n    ``next(ShuffleSplit().split(X, y))`` and application to input data\n    into a single call for splitting (and optionally subsampling) data in a\n    oneliner.",node_functions:[{name:"split2",docstring:"None",inputs:[{name:"*arrays",docstring:"Allowed inputs are lists, numpy arrays, scipy-sparse matrices or pandas dataframes.",param_type:["list"],expected_shape:null,is_optional:!1,default_value:null},{name:"test_size",docstring:"If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split. If int, represents the absolute number of test samples. If None, the value is set to the complement of the train size. If ``train_size`` is also None, it will be set to 0.25.",param_type:["int","float",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"train_size",docstring:"If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split. If int, represents the absolute number of train samples. If None, the value is automatically set to the complement of the test size.",param_type:["int","float",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"shuffle",docstring:"Whether or not to shuffle the data before splitting. If shuffle=False then stratify must be None.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True"},{name:"stratify",docstring:"If not None, data is split in a stratified fashion, using this as the class labels.",param_type:["array",null],expected_shape:null,is_optional:!0,default_value:"None"}],outputs:[{name:"splitting",docstring:"List containing train-test split of inputs.",param_type:["array","list"],returned:!0}]}],inputs:[{name:"*arrays",docstring:"Allowed inputs are lists, numpy arrays, scipy-sparse matrices or pandas dataframes.",param_type:["list"],expected_shape:null,is_optional:!1,default_value:null},{name:"test_size",docstring:"If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split. If int, represents the absolute number of test samples. If None, the value is set to the complement of the train size. If ``train_size`` is also None, it will be set to 0.25.",param_type:["int","float",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"train_size",docstring:"If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split. If int, represents the absolute number of train samples. If None, the value is automatically set to the complement of the test size.",param_type:["int","float",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"shuffle",docstring:"Whether or not to shuffle the data before splitting. If shuffle=False then stratify must be None.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True"},{name:"stratify",docstring:"If not None, data is split in a stratified fashion, using this as the class labels.",param_type:["array",null],expected_shape:null,is_optional:!0,default_value:"None"}],outputs:[{name:"splitting",docstring:"List containing train-test split of inputs.",param_type:["array","list"],returned:!0}]},{name:"GridSearchCV",docstring:'Exhaustive search over specified parameter values for an estimator.\n\n    Important members are fit, predict.\n\n    GridSearchCV implements a "fit" and a "score" method.\n    It also implements "predict", "predict_proba", "decision_function",\n    "transform" and "inverse_transform" if they are implemented in the\n    estimator used.\n\n    The parameters of the estimator used to apply these methods are optimized\n    by cross-validated grid-search over a parameter grid.',inputs:[{name:"estimator",docstring:"This is assumed to implement the scikit-learn estimator interface. Either estimator needs to provide a ``score`` function, or ``scoring`` must be passed.",param_type:["object"],expected_shape:null,is_optional:!1,default_value:null},{name:"param_grid",docstring:"Dictionary with parameters names (string) as keys and lists of parameter settings to try as values, or a list of such dictionaries, in which case the grids spanned by each dictionary in the list are explored. This enables searching over any sequence of parameter settings.",param_type:["dict","list"],expected_shape:null,is_optional:!1,default_value:null},{name:"scoring",docstring:"A single string (see :ref:`scoring_parameter`) or a callable (see :ref:`scoring`) to evaluate the predictions on the test set.  For evaluating multiple metrics, either give a list of (unique) strings or a dict with names as keys and callables as values.  NOTE that when using custom scorers, each scorer should return a single value. Metric functions returning a list/array of values can be wrapped into multiple scorers that return one value each.  See :ref:`multimetric_grid_search` for an example.  If None, the estimator's score method is used.",param_type:["str","dict","list","tuple","callable",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"n_jobs",docstring:"Number of jobs to run in parallel. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.",param_type:["int",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"pre_dispatch",docstring:"Controls the number of jobs that get dispatched during parallel execution. Reducing this number can be useful to avoid an explosion of memory consumption when more jobs get dispatched than CPUs can process. This parameter can be:      - None, in which case all the jobs are immediately       created and spawned. Use this for lightweight and       fast-running jobs, to avoid delays due to on-demand       spawning of the jobs      - An int, giving the exact number of total jobs that are       spawned      - A string, giving an expression as a function of n_jobs,       as in '2*n_jobs'",param_type:["int","str"],expected_shape:null,is_optional:!0,default_value:null},{name:"iid",docstring:"If True, return the average score across folds, weighted by the number of samples in each test set. In this case, the data is assumed to be identically distributed across the folds, and the loss minimized is the total loss per sample, and not the mean loss across the folds. If False, return the average score across folds. Default is True, but will change to False in version 0.22, to correspond to the standard definition of cross-validation.  .. versionchanged:: 0.20     Parameter ``iid`` will change from True to False by default in     version 0.22, and will be removed in 0.24.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"warn"},{name:"cv",docstring:"Determines the cross-validation splitting strategy. Possible inputs for cv are:  - None, to use the default 3-fold cross validation, - integer, to specify the number of folds in a `(Stratified)KFold`, - :term:`CV splitter`, - An iterable yielding (train, test) splits as arrays of indices.  For integer/None inputs, if the estimator is a classifier and ``y`` is either binary or multiclass, :class:`StratifiedKFold` is used. In all other cases, :class:`KFold` is used.  Refer :ref:`User Guide <cross_validation>` for the various cross-validation strategies that can be used here.  .. versionchanged:: 0.20     ``cv`` default value if None will change from 3-fold to 5-fold     in v0.22.",param_type:["int","iter"],expected_shape:null,is_optional:!0,default_value:null},{name:"refit",docstring:"Refit an estimator using the best found parameters on the whole dataset.  For multiple metric evaluation, this needs to be a string denoting the scorer that would be used to find the best parameters for refitting the estimator at the end.  Where there are considerations other than maximum score in choosing a best estimator, ``refit`` can be set to a function which returns the selected ``best_index_`` given ``cv_results_``.  The refitted estimator is made available at the ``best_estimator_`` attribute and permits using ``predict`` directly on this ``GridSearchCV`` instance.  Also for multiple metric evaluation, the attributes ``best_index_``, ``best_score_`` and ``best_params_`` will only be available if ``refit`` is set and all of them will be determined w.r.t this specific scorer. ``best_score_`` is not returned if refit is callable.  See ``scoring`` parameter to know more about multiple metric evaluation.  .. versionchanged:: 0.20     Support for callable added.",param_type:["bool","str","callable"],expected_shape:null,is_optional:!0,default_value:"True"},{name:"verbose",docstring:"Controls the verbosity: the higher, the more messages.",param_type:["int"],expected_shape:null,is_optional:!1,default_value:null},{name:"error_score",docstring:"Value to assign to the score if an error occurs in estimator fitting. If set to 'raise', the error is raised. If a numeric value is given, FitFailedWarning is raised. This parameter does not affect the refit step, which will always raise the error. Default is 'raise' but from version 0.22 it will change to np.nan.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null},{name:"return_train_score",docstring:"If ``False``, the ``cv_results_`` attribute will not include training scores. Computing training scores is used to get insights on how different parameter settings impact the overfitting/underfitting trade-off. However computing the scores on the training set can be computationally expensive and is not strictly required to select the parameters that yield the best generalization performance.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False"}],outputs:[{name:"cv_results_",docstring:"A dict with keys as column headers and values as columns, that can be imported into a pandas ``DataFrame``.  For instance the below given table  +------------+-----------+------------+-----------------+---+---------+ |param_kernel|param_gamma|param_degree|split0_test_score|...|rank_t...| +============+===========+============+=================+===+=========+ |  'poly'    |     --    |      2     |       0.80      |...|    2    | +------------+-----------+------------+-----------------+---+---------+ |  'poly'    |     --    |      3     |       0.70      |...|    4    | +------------+-----------+------------+-----------------+---+---------+ |  'rbf'     |     0.1   |     --     |       0.80      |...|    3    | +------------+-----------+------------+-----------------+---+---------+ |  'rbf'     |     0.2   |     --     |       0.93      |...|    1    | +------------+-----------+------------+-----------------+---+---------+  will be represented by a ``cv_results_`` dict of::      {     'param_kernel': masked_array(data = ['poly', 'poly', 'rbf', 'rbf'],                                  mask = [False False False False]...)     'param_gamma': masked_array(data = [-- -- 0.1 0.2],                                 mask = [ True  True False False]...),     'param_degree': masked_array(data = [2.0 3.0 -- --],                                  mask = [False False  True  True]...),     'split0_test_score'  : [0.80, 0.70, 0.80, 0.93],     'split1_test_score'  : [0.82, 0.50, 0.70, 0.78],     'mean_test_score'    : [0.81, 0.60, 0.75, 0.85],     'std_test_score'     : [0.01, 0.10, 0.05, 0.08],     'rank_test_score'    : [2, 4, 3, 1],     'split0_train_score' : [0.80, 0.92, 0.70, 0.93],     'split1_train_score' : [0.82, 0.55, 0.70, 0.87],     'mean_train_score'   : [0.81, 0.74, 0.70, 0.90],     'std_train_score'    : [0.01, 0.19, 0.00, 0.03],     'mean_fit_time'      : [0.73, 0.63, 0.43, 0.49],     'std_fit_time'       : [0.01, 0.02, 0.01, 0.01],     'mean_score_time'    : [0.01, 0.06, 0.04, 0.04],     'std_score_time'     : [0.00, 0.00, 0.00, 0.01],     'params'             : [{'kernel': 'poly', 'degree': 2}, ...],     }  NOTE  The key ``'params'`` is used to store a list of parameter settings dicts for all the parameter candidates.  The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and ``std_score_time`` are all in seconds.  For multi-metric evaluation, the scores for all the scorers are available in the ``cv_results_`` dict at the keys ending with that scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown above. ('split0_test_precision', 'mean_train_precision' etc.)",param_type:["array","dict"],returned:!1},{name:"best_estimator_",docstring:"Estimator that was chosen by the search, i.e. estimator which gave highest score (or smallest loss if specified) on the left out data. Not available if ``refit=False``.  See ``refit`` parameter for more information on allowed values.",param_type:["dict"],returned:!1},{name:"best_score_",docstring:"Mean cross-validated score of the best_estimator  For multi-metric evaluation, this is present only if ``refit`` is specified.",param_type:["float"],returned:!1},{name:"best_params_",docstring:"Parameter setting that gave the best results on the hold out data.  For multi-metric evaluation, this is present only if ``refit`` is specified.",param_type:["dict"],returned:!1},{name:"best_index_",docstring:"The index (of the ``cv_results_`` arrays) which corresponds to the best candidate parameter setting.  The dict at ``search.cv_results_['params'][search.best_index_]`` gives the parameter setting for the best model, that gives the highest mean score (``search.best_score_``).  For multi-metric evaluation, this is present only if ``refit`` is specified.",param_type:["int"],returned:!1},{name:"scorer_",docstring:"Scorer function used on the held out data to choose the best parameters for the model.  For multi-metric evaluation, this attribute holds the validated ``scoring`` dict which maps the scorer key to the scorer callable.",param_type:["dict"],returned:!1},{name:"n_splits_",docstring:"The number of cross-validation splits (folds/iterations).",param_type:["int"],returned:!1},{name:"refit_time_",docstring:"Seconds used for refitting the best model on the whole dataset.  This is present only if ``refit`` is not False.",param_type:["float"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_check_is_fitted",docstring:"None",inputs:[],outputs:[]},{name:"_format_results",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_run_search",docstring:"Search all candidates in param_grid",inputs:[],outputs:[]},{name:"decision_function",docstring:"Call decision_function on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``decision_function``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"fit",docstring:'Run fit with all sets of parameters.\n\n        Parameters\n        ----------\n\n        X : array-like, shape = [n_samples, n_features]\n            Training vector, where n_samples is the number of samples and\n            n_features is the number of features.\n\n        y : array-like, shape = [n_samples] or [n_samples, n_output], optional\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        groups : array-like, with shape (n_samples,), optional\n            Group labels for the samples used while splitting the dataset into\n            train/test set. Only used in conjunction with a "Group" `cv`\n            instance (e.g., `GroupKFold`).\n\n        **fit_params : dict of string -> object\n            Parameters passed to the ``fit`` method of the estimator\n        ',inputs:[{name:"X",docstring:"Training vector, where n_samples is the number of samples and n_features is the number of features.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null},{name:"y",docstring:"Target relative to X for classification or regression; None for unsupervised learning.",param_type:["array"],expected_shape:"[n_samples] or [n_samples, n_output], optional",is_optional:!0,default_value:null},{name:"groups",docstring:'Group labels for the samples used while splitting the dataset into train/test set. Only used in conjunction with a "Group" `cv` instance (e.g., `GroupKFold`).',param_type:["array"],expected_shape:"(n_samples,), optional",is_optional:!0,default_value:null},{name:"**fit_params",docstring:"Parameters passed to the ``fit`` method of the estimator",param_type:["object","str","dict"],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"get_params",docstring:"Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : boolean, optional\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.\n\n        Returns\n        -------\n        params : mapping of string to any\n            Parameter names mapped to their values.\n        ",inputs:[{name:"deep",docstring:"If True, will return the parameters for this estimator and contained subobjects that are estimators.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:null}],outputs:[{name:"params",docstring:"Parameter names mapped to their values.",param_type:["str"],returned:!0}]},{name:"inverse_transform",docstring:"Call inverse_transform on the estimator with the best found params.\n\n        Only available if the underlying estimator implements\n        ``inverse_transform`` and ``refit=True``.\n\n        Parameters\n        ----------\n        Xt : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"Xt",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"predict",docstring:"Call predict on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"predict_log_proba",docstring:"Call predict_log_proba on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict_log_proba``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"predict_proba",docstring:"Call predict_proba on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict_proba``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"score",docstring:"Returns the score on the given data, if the estimator has been refit.\n\n        This uses the score defined by ``scoring`` where provided, and the\n        ``best_estimator_.score`` method otherwise.\n\n        Parameters\n        ----------\n        X : array-like, shape = [n_samples, n_features]\n            Input data, where n_samples is the number of samples and\n            n_features is the number of features.\n\n        y : array-like, shape = [n_samples] or [n_samples, n_output], optional\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        Returns\n        -------\n        score : float\n        ",inputs:[{name:"X",docstring:"Input data, where n_samples is the number of samples and n_features is the number of features.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null},{name:"y",docstring:"Target relative to X for classification or regression; None for unsupervised learning.",param_type:["array"],expected_shape:"[n_samples] or [n_samples, n_output], optional",is_optional:!0,default_value:null}],outputs:[{name:"score",docstring:"",param_type:["float"],returned:!0}]},{name:"set_params",docstring:"Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as pipelines). The latter have parameters of the form\n        ``<component>__<parameter>`` so that it's possible to update each\n        component of a nested object.\n\n        Returns\n        -------\n        self\n        ",inputs:[],outputs:[{name:"",docstring:"",param_type:[null],returned:!0}]},{name:"transform",docstring:"Call transform on the estimator with the best found parameters.\n\n        Only available if the underlying estimator supports ``transform`` and\n        ``refit=True``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]}],nodes:[]},{name:"RandomizedSearchCV",docstring:"Randomized search on hyper parameters.\n\n    RandomizedSearchCV implements a \"fit\" and a \"score\" method.\n    It also implements \"predict\", \"predict_proba\", \"decision_function\",\n    \"transform\" and \"inverse_transform\" if they are implemented in the\n    estimator used.\n\n    The parameters of the estimator used to apply these methods are optimized\n    by cross-validated search over parameter settings.\n\n    In contrast to GridSearchCV, not all parameter values are tried out, but\n    rather a fixed number of parameter settings is sampled from the specified\n    distributions. The number of parameter settings that are tried is\n    given by n_iter.\n\n    If all parameters are presented as a list,\n    sampling without replacement is performed. If at least one parameter\n    is given as a distribution, sampling with replacement is used.\n    It is highly recommended to use continuous distributions for continuous\n    parameters.\n\n    Note that before SciPy 0.16, the ``scipy.stats.distributions`` do not\n    accept a custom RNG instance and always use the singleton RNG from\n    ``numpy.random``. Hence setting ``random_state`` will not guarantee a\n    deterministic iteration whenever ``scipy.stats`` distributions are used to\n    define the parameter search space.\n\n    Read more in the :ref:`User Guide <randomized_parameter_search>`.\n\n    Parameters\n    ----------\n    estimator : estimator object.\n        A object of that type is instantiated for each grid point.\n        This is assumed to implement the scikit-learn estimator interface.\n        Either estimator needs to provide a ``score`` function,\n        or ``scoring`` must be passed.\n\n    param_distributions : dict\n        Dictionary with parameters names (string) as keys and distributions\n        or lists of parameters to try. Distributions must provide a ``rvs``\n        method for sampling (such as those from scipy.stats.distributions).\n        If a list is given, it is sampled uniformly.\n\n    n_iter : int, default=10\n        Number of parameter settings that are sampled. n_iter trades\n        off runtime vs quality of the solution.\n\n    scoring : string, callable, list/tuple, dict or None, default: None\n        A single string (see :ref:`scoring_parameter`) or a callable\n        (see :ref:`scoring`) to evaluate the predictions on the test set.\n\n        For evaluating multiple metrics, either give a list of (unique) strings\n        or a dict with names as keys and callables as values.\n\n        NOTE that when using custom scorers, each scorer should return a single\n        value. Metric functions returning a list/array of values can be wrapped\n        into multiple scorers that return one value each.\n\n        See :ref:`multimetric_grid_search` for an example.\n\n        If None, the estimator's score method is used.\n\n    n_jobs : int or None, optional (default=None)\n        Number of jobs to run in parallel.\n        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. See :term:`Glossary <n_jobs>`\n        for more details.\n\n    pre_dispatch : int, or string, optional\n        Controls the number of jobs that get dispatched during parallel\n        execution. Reducing this number can be useful to avoid an\n        explosion of memory consumption when more jobs get dispatched\n        than CPUs can process. This parameter can be:\n\n            - None, in which case all the jobs are immediately\n              created and spawned. Use this for lightweight and\n              fast-running jobs, to avoid delays due to on-demand\n              spawning of the jobs\n\n            - An int, giving the exact number of total jobs that are\n              spawned\n\n            - A string, giving an expression as a function of n_jobs,\n              as in '2*n_jobs'\n\n    iid : boolean, default='warn'\n        If True, return the average score across folds, weighted by the number\n        of samples in each test set. In this case, the data is assumed to be\n        identically distributed across the folds, and the loss minimized is\n        the total loss per sample, and not the mean loss across the folds. If\n        False, return the average score across folds. Default is True, but\n        will change to False in version 0.22, to correspond to the standard\n        definition of cross-validation.\n\n        .. versionchanged:: 0.20\n            Parameter ``iid`` will change from True to False by default in\n            version 0.22, and will be removed in 0.24.\n\n    cv : int, cross-validation generator or an iterable, optional\n        Determines the cross-validation splitting strategy.\n        Possible inputs for cv are:\n\n        - None, to use the default 3-fold cross validation,\n        - integer, to specify the number of folds in a `(Stratified)KFold`,\n        - :term:`CV splitter`,\n        - An iterable yielding (train, test) splits as arrays of indices.\n\n        For integer/None inputs, if the estimator is a classifier and ``y`` is\n        either binary or multiclass, :class:`StratifiedKFold` is used. In all\n        other cases, :class:`KFold` is used.\n\n        Refer :ref:`User Guide <cross_validation>` for the various\n        cross-validation strategies that can be used here.\n\n        .. versionchanged:: 0.20\n            ``cv`` default value if None will change from 3-fold to 5-fold\n            in v0.22.\n\n    refit : boolean, string, or callable, default=True\n        Refit an estimator using the best found parameters on the whole\n        dataset.\n\n        For multiple metric evaluation, this needs to be a string denoting the\n        scorer that would be used to find the best parameters for refitting\n        the estimator at the end.\n\n        Where there are considerations other than maximum score in\n        choosing a best estimator, ``refit`` can be set to a function which\n        returns the selected ``best_index_`` given the ``cv_results``.\n\n        The refitted estimator is made available at the ``best_estimator_``\n        attribute and permits using ``predict`` directly on this\n        ``RandomizedSearchCV`` instance.\n\n        Also for multiple metric evaluation, the attributes ``best_index_``,\n        ``best_score_`` and ``best_params_`` will only be available if\n        ``refit`` is set and all of them will be determined w.r.t this specific\n        scorer. When refit is callable, ``best_score_`` is disabled.\n\n        See ``scoring`` parameter to know more about multiple metric\n        evaluation.\n\n        .. versionchanged:: 0.20\n            Support for callable added.\n\n    verbose : integer\n        Controls the verbosity: the higher, the more messages.\n\n    random_state : int, RandomState instance or None, optional, default=None\n        Pseudo random number generator state used for random uniform sampling\n        from lists of possible values instead of scipy.stats distributions.\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    error_score : 'raise' or numeric\n        Value to assign to the score if an error occurs in estimator fitting.\n        If set to 'raise', the error is raised. If a numeric value is given,\n        FitFailedWarning is raised. This parameter does not affect the refit\n        step, which will always raise the error. Default is 'raise' but from\n        version 0.22 it will change to np.nan.\n\n    return_train_score : boolean, default=False\n        If ``False``, the ``cv_results_`` attribute will not include training\n        scores.\n        Computing training scores is used to get insights on how different\n        parameter settings impact the overfitting/underfitting trade-off.\n        However computing the scores on the training set can be computationally\n        expensive and is not strictly required to select the parameters that\n        yield the best generalization performance.\n\n    Attributes\n    ----------\n    cv_results_ : dict of numpy (masked) ndarrays\n        A dict with keys as column headers and values as columns, that can be\n        imported into a pandas ``DataFrame``.\n\n        For instance the below given table\n\n        +--------------+-------------+-------------------+---+---------------+\n        | param_kernel | param_gamma | split0_test_score |...|rank_test_score|\n        +==============+=============+===================+===+===============+\n        |    'rbf'     |     0.1     |       0.80        |...|       2       |\n        +--------------+-------------+-------------------+---+---------------+\n        |    'rbf'     |     0.2     |       0.90        |...|       1       |\n        +--------------+-------------+-------------------+---+---------------+\n        |    'rbf'     |     0.3     |       0.70        |...|       1       |\n        +--------------+-------------+-------------------+---+---------------+\n\n        will be represented by a ``cv_results_`` dict of::\n\n            {\n            'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],\n                                          mask = False),\n            'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),\n            'split0_test_score'  : [0.80, 0.90, 0.70],\n            'split1_test_score'  : [0.82, 0.50, 0.70],\n            'mean_test_score'    : [0.81, 0.70, 0.70],\n            'std_test_score'     : [0.01, 0.20, 0.00],\n            'rank_test_score'    : [3, 1, 1],\n            'split0_train_score' : [0.80, 0.92, 0.70],\n            'split1_train_score' : [0.82, 0.55, 0.70],\n            'mean_train_score'   : [0.81, 0.74, 0.70],\n            'std_train_score'    : [0.01, 0.19, 0.00],\n            'mean_fit_time'      : [0.73, 0.63, 0.43],\n            'std_fit_time'       : [0.01, 0.02, 0.01],\n            'mean_score_time'    : [0.01, 0.06, 0.04],\n            'std_score_time'     : [0.00, 0.00, 0.00],\n            'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],\n            }\n\n        NOTE\n\n        The key ``'params'`` is used to store a list of parameter\n        settings dicts for all the parameter candidates.\n\n        The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and\n        ``std_score_time`` are all in seconds.\n\n        For multi-metric evaluation, the scores for all the scorers are\n        available in the ``cv_results_`` dict at the keys ending with that\n        scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown\n        above. ('split0_test_precision', 'mean_train_precision' etc.)\n\n    best_estimator_ : estimator or dict\n        Estimator that was chosen by the search, i.e. estimator\n        which gave highest score (or smallest loss if specified)\n        on the left out data. Not available if ``refit=False``.\n\n        For multi-metric evaluation, this attribute is present only if\n        ``refit`` is specified.\n\n        See ``refit`` parameter for more information on allowed values.\n\n    best_score_ : float\n        Mean cross-validated score of the best_estimator.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    best_params_ : dict\n        Parameter setting that gave the best results on the hold out data.\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    best_index_ : int\n        The index (of the ``cv_results_`` arrays) which corresponds to the best\n        candidate parameter setting.\n\n        The dict at ``search.cv_results_['params'][search.best_index_]`` gives\n        the parameter setting for the best model, that gives the highest\n        mean score (``search.best_score_``).\n\n        For multi-metric evaluation, this is not available if ``refit`` is\n        ``False``. See ``refit`` parameter for more information.\n\n    scorer_ : function or a dict\n        Scorer function used on the held out data to choose the best\n        parameters for the model.\n\n        For multi-metric evaluation, this attribute holds the validated\n        ``scoring`` dict which maps the scorer key to the scorer callable.\n\n    n_splits_ : int\n        The number of cross-validation splits (folds/iterations).\n\n    refit_time_ : float\n        Seconds used for refitting the best model on the whole dataset.\n\n        This is present only if ``refit`` is not False.\n\n    Notes\n    -----\n    The parameters selected are those that maximize the score of the held-out\n    data, according to the scoring parameter.\n\n    If `n_jobs` was set to a value higher than one, the data is copied for each\n    parameter setting(and not `n_jobs` times). This is done for efficiency\n    reasons if individual jobs take very little time, but may raise errors if\n    the dataset is large and not enough memory is available.  A workaround in\n    this case is to set `pre_dispatch`. Then, the memory is copied only\n    `pre_dispatch` many times. A reasonable value for `pre_dispatch` is `2 *\n    n_jobs`.\n\n    See Also\n    --------\n    :class:`GridSearchCV`:\n        Does exhaustive search over a grid of parameters.\n\n    :class:`ParameterSampler`:\n        A generator over parameter settings, constructed from\n        param_distributions.\n\n    ",inputs:[{name:"estimator",docstring:"A object of that type is instantiated for each grid point. This is assumed to implement the scikit-learn estimator interface. Either estimator needs to provide a ``score`` function, or ``scoring`` must be passed.",param_type:["object"],expected_shape:null,is_optional:!1,default_value:null},{name:"param_distributions",docstring:"Dictionary with parameters names (string) as keys and distributions or lists of parameters to try. Distributions must provide a ``rvs`` method for sampling (such as those from scipy.stats.distributions). If a list is given, it is sampled uniformly.",param_type:["dict"],expected_shape:null,is_optional:!1,default_value:null},{name:"n_iter",docstring:"Number of parameter settings that are sampled. n_iter trades off runtime vs quality of the solution.",param_type:["int"],expected_shape:null,is_optional:!0,default_value:"10"},{name:"scoring",docstring:"A single string (see :ref:`scoring_parameter`) or a callable (see :ref:`scoring`) to evaluate the predictions on the test set.  For evaluating multiple metrics, either give a list of (unique) strings or a dict with names as keys and callables as values.  NOTE that when using custom scorers, each scorer should return a single value. Metric functions returning a list/array of values can be wrapped into multiple scorers that return one value each.  See :ref:`multimetric_grid_search` for an example.  If None, the estimator's score method is used.",param_type:["str","dict","list","tuple","callable",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"n_jobs",docstring:"Number of jobs to run in parallel. ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. ``-1`` means using all processors. See :term:`Glossary <n_jobs>` for more details.",param_type:["int",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"pre_dispatch",docstring:"Controls the number of jobs that get dispatched during parallel execution. Reducing this number can be useful to avoid an explosion of memory consumption when more jobs get dispatched than CPUs can process. This parameter can be:      - None, in which case all the jobs are immediately       created and spawned. Use this for lightweight and       fast-running jobs, to avoid delays due to on-demand       spawning of the jobs      - An int, giving the exact number of total jobs that are       spawned      - A string, giving an expression as a function of n_jobs,       as in '2*n_jobs'",param_type:["int","str"],expected_shape:null,is_optional:!0,default_value:null},{name:"iid",docstring:"If True, return the average score across folds, weighted by the number of samples in each test set. In this case, the data is assumed to be identically distributed across the folds, and the loss minimized is the total loss per sample, and not the mean loss across the folds. If False, return the average score across folds. Default is True, but will change to False in version 0.22, to correspond to the standard definition of cross-validation.  .. versionchanged:: 0.20     Parameter ``iid`` will change from True to False by default in     version 0.22, and will be removed in 0.24.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"warn"},{name:"cv",docstring:"Determines the cross-validation splitting strategy. Possible inputs for cv are:  - None, to use the default 3-fold cross validation, - integer, to specify the number of folds in a `(Stratified)KFold`, - :term:`CV splitter`, - An iterable yielding (train, test) splits as arrays of indices.  For integer/None inputs, if the estimator is a classifier and ``y`` is either binary or multiclass, :class:`StratifiedKFold` is used. In all other cases, :class:`KFold` is used.  Refer :ref:`User Guide <cross_validation>` for the various cross-validation strategies that can be used here.  .. versionchanged:: 0.20     ``cv`` default value if None will change from 3-fold to 5-fold     in v0.22.",param_type:["int","iter"],expected_shape:null,is_optional:!0,default_value:null},{name:"refit",docstring:"Refit an estimator using the best found parameters on the whole dataset.  For multiple metric evaluation, this needs to be a string denoting the scorer that would be used to find the best parameters for refitting the estimator at the end.  Where there are considerations other than maximum score in choosing a best estimator, ``refit`` can be set to a function which returns the selected ``best_index_`` given the ``cv_results``.  The refitted estimator is made available at the ``best_estimator_`` attribute and permits using ``predict`` directly on this ``RandomizedSearchCV`` instance.  Also for multiple metric evaluation, the attributes ``best_index_``, ``best_score_`` and ``best_params_`` will only be available if ``refit`` is set and all of them will be determined w.r.t this specific scorer. When refit is callable, ``best_score_`` is disabled.  See ``scoring`` parameter to know more about multiple metric evaluation.  .. versionchanged:: 0.20     Support for callable added.",param_type:["bool","str","callable"],expected_shape:null,is_optional:!0,default_value:"True"},{name:"verbose",docstring:"Controls the verbosity: the higher, the more messages.",param_type:["int"],expected_shape:null,is_optional:!1,default_value:null},{name:"random_state",docstring:"Pseudo random number generator state used for random uniform sampling from lists of possible values instead of scipy.stats distributions. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by `np.random`.",param_type:["int",null],expected_shape:null,is_optional:!0,default_value:"None"},{name:"error_score",docstring:"Value to assign to the score if an error occurs in estimator fitting. If set to 'raise', the error is raised. If a numeric value is given, FitFailedWarning is raised. This parameter does not affect the refit step, which will always raise the error. Default is 'raise' but from version 0.22 it will change to np.nan.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null},{name:"return_train_score",docstring:"If ``False``, the ``cv_results_`` attribute will not include training scores. Computing training scores is used to get insights on how different parameter settings impact the overfitting/underfitting trade-off. However computing the scores on the training set can be computationally expensive and is not strictly required to select the parameters that yield the best generalization performance.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False"}],outputs:[{name:"cv_results_",docstring:"A dict with keys as column headers and values as columns, that can be imported into a pandas ``DataFrame``.  For instance the below given table  +--------------+-------------+-------------------+---+---------------+ | param_kernel | param_gamma | split0_test_score |...|rank_test_score| +==============+=============+===================+===+===============+ |    'rbf'     |     0.1     |       0.80        |...|       2       | +--------------+-------------+-------------------+---+---------------+ |    'rbf'     |     0.2     |       0.90        |...|       1       | +--------------+-------------+-------------------+---+---------------+ |    'rbf'     |     0.3     |       0.70        |...|       1       | +--------------+-------------+-------------------+---+---------------+  will be represented by a ``cv_results_`` dict of::      {     'param_kernel' : masked_array(data = ['rbf', 'rbf', 'rbf'],                                   mask = False),     'param_gamma'  : masked_array(data = [0.1 0.2 0.3], mask = False),     'split0_test_score'  : [0.80, 0.90, 0.70],     'split1_test_score'  : [0.82, 0.50, 0.70],     'mean_test_score'    : [0.81, 0.70, 0.70],     'std_test_score'     : [0.01, 0.20, 0.00],     'rank_test_score'    : [3, 1, 1],     'split0_train_score' : [0.80, 0.92, 0.70],     'split1_train_score' : [0.82, 0.55, 0.70],     'mean_train_score'   : [0.81, 0.74, 0.70],     'std_train_score'    : [0.01, 0.19, 0.00],     'mean_fit_time'      : [0.73, 0.63, 0.43],     'std_fit_time'       : [0.01, 0.02, 0.01],     'mean_score_time'    : [0.01, 0.06, 0.04],     'std_score_time'     : [0.00, 0.00, 0.00],     'params'             : [{'kernel' : 'rbf', 'gamma' : 0.1}, ...],     }  NOTE  The key ``'params'`` is used to store a list of parameter settings dicts for all the parameter candidates.  The ``mean_fit_time``, ``std_fit_time``, ``mean_score_time`` and ``std_score_time`` are all in seconds.  For multi-metric evaluation, the scores for all the scorers are available in the ``cv_results_`` dict at the keys ending with that scorer's name (``'_<scorer_name>'``) instead of ``'_score'`` shown above. ('split0_test_precision', 'mean_train_precision' etc.)",param_type:["array","dict"],returned:!1},{name:"best_estimator_",docstring:"Estimator that was chosen by the search, i.e. estimator which gave highest score (or smallest loss if specified) on the left out data. Not available if ``refit=False``.  For multi-metric evaluation, this attribute is present only if ``refit`` is specified.  See ``refit`` parameter for more information on allowed values.",param_type:["dict"],returned:!1},{name:"best_score_",docstring:"Mean cross-validated score of the best_estimator.  For multi-metric evaluation, this is not available if ``refit`` is ``False``. See ``refit`` parameter for more information.",param_type:["float"],returned:!1},{name:"best_params_",docstring:"Parameter setting that gave the best results on the hold out data.  For multi-metric evaluation, this is not available if ``refit`` is ``False``. See ``refit`` parameter for more information.",param_type:["dict"],returned:!1},{name:"best_index_",docstring:"The index (of the ``cv_results_`` arrays) which corresponds to the best candidate parameter setting.  The dict at ``search.cv_results_['params'][search.best_index_]`` gives the parameter setting for the best model, that gives the highest mean score (``search.best_score_``).  For multi-metric evaluation, this is not available if ``refit`` is ``False``. See ``refit`` parameter for more information.",param_type:["int"],returned:!1},{name:"scorer_",docstring:"Scorer function used on the held out data to choose the best parameters for the model.  For multi-metric evaluation, this attribute holds the validated ``scoring`` dict which maps the scorer key to the scorer callable.",param_type:["dict"],returned:!1},{name:"n_splits_",docstring:"The number of cross-validation splits (folds/iterations).",param_type:["int"],returned:!1},{name:"refit_time_",docstring:"Seconds used for refitting the best model on the whole dataset.  This is present only if ``refit`` is not False.",param_type:["float"],returned:!1}],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"_check_is_fitted",docstring:"None",inputs:[],outputs:[]},{name:"_format_results",docstring:"None",inputs:[],outputs:[]},{name:"_get_param_names",docstring:"Get parameter names for the estimator",inputs:[],outputs:[]},{name:"_get_tags",docstring:"None",inputs:[],outputs:[]},{name:"_run_search",docstring:"Search n_iter candidates from param_distributions",inputs:[],outputs:[]},{name:"decision_function",docstring:"Call decision_function on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``decision_function``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"fit",docstring:'Run fit with all sets of parameters.\n\n        Parameters\n        ----------\n\n        X : array-like, shape = [n_samples, n_features]\n            Training vector, where n_samples is the number of samples and\n            n_features is the number of features.\n\n        y : array-like, shape = [n_samples] or [n_samples, n_output], optional\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        groups : array-like, with shape (n_samples,), optional\n            Group labels for the samples used while splitting the dataset into\n            train/test set. Only used in conjunction with a "Group" `cv`\n            instance (e.g., `GroupKFold`).\n\n        **fit_params : dict of string -> object\n            Parameters passed to the ``fit`` method of the estimator\n        ',inputs:[{name:"X",docstring:"Training vector, where n_samples is the number of samples and n_features is the number of features.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null},{name:"y",docstring:"Target relative to X for classification or regression; None for unsupervised learning.",param_type:["array"],expected_shape:"[n_samples] or [n_samples, n_output], optional",is_optional:!0,default_value:null},{name:"groups",docstring:'Group labels for the samples used while splitting the dataset into train/test set. Only used in conjunction with a "Group" `cv` instance (e.g., `GroupKFold`).',param_type:["array"],expected_shape:"(n_samples,), optional",is_optional:!0,default_value:null},{name:"**fit_params",docstring:"Parameters passed to the ``fit`` method of the estimator",param_type:["object","str","dict"],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"get_params",docstring:"Get parameters for this estimator.\n\n        Parameters\n        ----------\n        deep : boolean, optional\n            If True, will return the parameters for this estimator and\n            contained subobjects that are estimators.\n\n        Returns\n        -------\n        params : mapping of string to any\n            Parameter names mapped to their values.\n        ",inputs:[{name:"deep",docstring:"If True, will return the parameters for this estimator and contained subobjects that are estimators.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:null}],outputs:[{name:"params",docstring:"Parameter names mapped to their values.",param_type:["str"],returned:!0}]},{name:"inverse_transform",docstring:"Call inverse_transform on the estimator with the best found params.\n\n        Only available if the underlying estimator implements\n        ``inverse_transform`` and ``refit=True``.\n\n        Parameters\n        ----------\n        Xt : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"Xt",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"predict",docstring:"Call predict on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"predict_log_proba",docstring:"Call predict_log_proba on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict_log_proba``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"predict_proba",docstring:"Call predict_proba on the estimator with the best found parameters.\n\n        Only available if ``refit=True`` and the underlying estimator supports\n        ``predict_proba``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]},{name:"score",docstring:"Returns the score on the given data, if the estimator has been refit.\n\n        This uses the score defined by ``scoring`` where provided, and the\n        ``best_estimator_.score`` method otherwise.\n\n        Parameters\n        ----------\n        X : array-like, shape = [n_samples, n_features]\n            Input data, where n_samples is the number of samples and\n            n_features is the number of features.\n\n        y : array-like, shape = [n_samples] or [n_samples, n_output], optional\n            Target relative to X for classification or regression;\n            None for unsupervised learning.\n\n        Returns\n        -------\n        score : float\n        ",inputs:[{name:"X",docstring:"Input data, where n_samples is the number of samples and n_features is the number of features.",param_type:["array"],expected_shape:"[n_samples, n_features]",is_optional:!1,default_value:null},{name:"y",docstring:"Target relative to X for classification or regression; None for unsupervised learning.",param_type:["array"],expected_shape:"[n_samples] or [n_samples, n_output], optional",is_optional:!0,default_value:null}],outputs:[{name:"score",docstring:"",param_type:["float"],returned:!0}]},{name:"set_params",docstring:"Set the parameters of this estimator.\n\n        The method works on simple estimators as well as on nested objects\n        (such as pipelines). The latter have parameters of the form\n        ``<component>__<parameter>`` so that it's possible to update each\n        component of a nested object.\n\n        Returns\n        -------\n        self\n        ",inputs:[],outputs:[{name:"",docstring:"",param_type:[null],returned:!0}]},{name:"transform",docstring:"Call transform on the estimator with the best found parameters.\n\n        Only available if the underlying estimator supports ``transform`` and\n        ``refit=True``.\n\n        Parameters\n        ----------\n        X : indexable, length n_samples\n            Must fulfill the input assumptions of the\n            underlying estimator.\n\n        ",inputs:[{name:"X",docstring:"Must fulfill the input assumptions of the underlying estimator.",param_type:[null],expected_shape:null,is_optional:!1,default_value:null}],outputs:[]}],nodes:[]}],library:"sklearn",module:"model_selection"},Lm={name:"sklearn.metrics",docstring:"",inputs:[],outputs:[],node_functions:[],nodes:[{name:"Regression Metrics",docstring:"Module to provide functions for most common metrics to evaluate Regression Models",inputs:[],outputs:[],node_functions:[{name:"r2_score",docstring:"R^2 (coefficient of determination) regression score function.\n\n    Best possible score is 1.0 and it can be negative (because the\n    model can be arbitrarily worse). A constant model that always\n    predicts the expected value of y, disregarding the input features,\n    would get a R^2 score of 0.0.",inputs:[{name:"y_true",docstring:"Ground truth (correct) target values.",param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",is_optional:!1,default_value:null},{name:"y_pred",docstring:"Estimated target values.",param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",is_optional:!1,default_value:null},{name:"sample_weight",docstring:"Sample weights.",param_type:["array"],expected_shape:"(n_samples), optional",is_optional:!0,default_value:null},{name:"multioutput",docstring:"Defines aggregating of multiple output scores. Array-like value defines weights used to average scores. Default is \"uniform_average\".  'raw_values' :     Returns a full set of scores in case of multioutput input.  'uniform_average' :     Scores of all outputs are averaged with uniform weight.  'variance_weighted' :     Scores of all outputs are averaged, weighted by the variances     of each individual output.",param_type:["array","LIST_VALID_OPTIONS",null],expected_shape:"(n_outputs)",is_optional:!0,default_value:"uniform_average",options:["raw_values","uniform_average","variance_weighted"]}],outputs:[{name:"z",docstring:"The R^2 score or ndarray of scores if 'multioutput' is 'raw_values'.",param_type:["array","float"],returned:!0}]},{name:"mean_absolute_error",docstring:"Mean absolute error regression loss",inputs:[{name:"y_true",docstring:"Ground truth (correct) target values.",param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",is_optional:!1,default_value:null},{name:"y_pred",docstring:"Estimated target values.",param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",is_optional:!1,default_value:null},{name:"sample_weight",docstring:"Sample weights.",param_type:["array"],expected_shape:"(n_samples), optional",is_optional:!0,default_value:null},{name:"multioutput",docstring:"Defines aggregating of multiple output scores. Array-like value defines weights used to average scores. Default is \"uniform_average\".  'raw_values' :     Returns a full set of scores in case of multioutput input.  'uniform_average' :     Scores of all outputs are averaged with uniform weight.",param_type:["array","LIST_VALID_OPTIONS",null],expected_shape:"(n_outputs)",is_optional:!0,default_value:"uniform_average",options:["raw_values","uniform_average"]}],outputs:[{name:"loss",docstring:"If multioutput is 'raw_values', then mean absolute error is returned for each output separately. If multioutput is 'uniform_average' or an ndarray of weights, then the weighted average of all output errors is returned.  MAE output is non-negative floating point. The best value is 0.0.",param_type:["array","float"],returned:!0}]},{name:"mean_squared_error",docstring:"Mean squared error regression loss",inputs:[{name:"y_true",docstring:"Ground truth (correct) target values.",param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",is_optional:!1,default_value:null},{name:"y_pred",docstring:"Estimated target values.",param_type:["array"],expected_shape:"(n_samples) or (n_samples, n_outputs)",is_optional:!1,default_value:null},{name:"sample_weight",docstring:"Sample weights.",param_type:["array"],expected_shape:"(n_samples), optional",is_optional:!0,default_value:null},{name:"multioutput",docstring:"Defines aggregating of multiple output scores. Array-like value defines weights used to average scores. Default is \"uniform_average\".  'raw_values' :     Returns a full set of scores in case of multioutput input.  'uniform_average' :     Scores of all outputs are averaged with uniform weight.",param_type:["array","LIST_VALID_OPTIONS",null],expected_shape:"(n_outputs)",is_optional:!0,default_value:"uniform_average",options:["raw_values","uniform_average"]}],outputs:[{name:"loss",docstring:"A non-negative floating point value (the best value is 0.0), or an array of floating point values, one for each individual target.",param_type:["array","float"],returned:!0}]}],nodes:[],placeholder:!0},{name:"Classification Metrics",docstring:"Module to provide functions for most common metrics to evaluate Classification Models",inputs:[],outputs:[],node_functions:[{name:"accuracy_score",docstring:"Accuracy classification score.\n\n    In multilabel classification, this function computes subset accuracy:\n    the set of labels predicted for a sample must *exactly* match the\n    corresponding set of labels in y_true.",inputs:[{name:"y_true",docstring:"Ground truth (correct) labels.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null},{name:"y_pred",docstring:"Predicted labels, as returned by a classifier.",param_type:["array"],expected_shape:null,is_optional:!1,default_value:null},{name:"normalize",docstring:"If ``False``, return the number of correctly classified samples. Otherwise, return the fraction of correctly classified samples.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"True"},{name:"sample_weight",docstring:"Sample weights.",param_type:["array"],expected_shape:"[n_samples], optional",is_optional:!0,default_value:null}],outputs:[{name:"score",docstring:"If ``normalize == True``, return the fraction of correctly classified samples (float), else returns the number of correctly classified samples (int).  The best performance is 1 with ``normalize == True`` and the number of samples with ``normalize == False``.",param_type:["float"],returned:!0}]},{name:"confusion_matrix",docstring:"Compute confusion matrix to evaluate the accuracy of a classification\n\n    By definition a confusion matrix :math:`C` is such that :math:`C_{i, j}`\n    is equal to the number of observations known to be in group :math:`i` but\n    predicted to be in group :math:`j`.\n\n    Thus in binary classification, the count of true negatives is\n    :math:`C_{0,0}`, false negatives is :math:`C_{1,0}`, true positives is\n    :math:`C_{1,1}` and false positives is :math:`C_{0,1}`.",inputs:[{name:"y_true",docstring:"Ground truth (correct) target values.",param_type:["array"],expected_shape:"[n_samples]",is_optional:!1,default_value:null},{name:"y_pred",docstring:"Estimated targets as returned by a classifier.",param_type:["array"],expected_shape:"[n_samples]",is_optional:!1,default_value:null},{name:"labels",docstring:"List of labels to index the matrix. This may be used to reorder or select a subset of labels. If none is given, those that appear at least once in ``y_true`` or ``y_pred`` are used in sorted order.",param_type:["array"],expected_shape:"[n_classes], optional",is_optional:!0,default_value:null},{name:"sample_weight",docstring:"Sample weights.",param_type:["array"],expected_shape:"[n_samples], optional",is_optional:!0,default_value:null}],outputs:[{name:"C",docstring:"Confusion matrix",param_type:["array"],returned:!0}]}],nodes:[],placeholder:!0}],library:"sklearn",module:"metrics"},Xm={name:"chemml.wrapper.preprocessing",docstring:"",inputs:[],outputs:[],node_functions:[],nodes:[{name:"SaveCSV",docstring:"\n    Write pandas DataFrame to a comma-seprated-values(CSV) file.",inputs:[{name:"file_path",docstring:"The path for the CSV file",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"record_time",docstring:"If True, the current time will be added to the file name.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null},{name:"index",docstring:"If True, the index of the dataframe will be also stored as the first column.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null},{name:"header",docstring:"If True, the header of the dataframe will be stored.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null}],outputs:[],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"write",display_name:"write",docstring:"\n        Write DataFrame to a comma-seprated-values CSV) file.",inputs:[{name:"df",docstring:"The input pandas dataframe",param_type:["dataframe"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"main_directory",docstring:"if there is a main directory for entire chemml wrapper project",param_type:["str"],expected_shape:null,is_optional:!0,default_value:"",options:null}],outputs:[]}],nodes:[]},{name:"SaveFile",docstring:"\n    Write any input data to a file in string format.\n    This is good for making text files and keeping track of intermediate data.",inputs:[{name:"file_path",docstring:"The path for the CSV file",param_type:["str"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"record_time",docstring:"If True, the current time will be added to the file name.",param_type:["bool"],expected_shape:null,is_optional:!0,default_value:"False",options:null}],outputs:[],node_functions:[{name:"__init__",docstring:"None",inputs:[],outputs:[]},{name:"write",display_name:"write",docstring:"\n        This function Write an input data X to a file as a string.",inputs:[{name:"df",docstring:"The input pandas dataframe",param_type:["dataframe"],expected_shape:null,is_optional:!1,default_value:null,options:null},{name:"main_directory",docstring:"if there is a main directory for entire chemml wrapper project",param_type:["str"],expected_shape:null,is_optional:!0,default_value:"",options:null}],outputs:[]}],nodes:[]}],library:"chemml",module:"wrapper.preprocessing"};function Um(e,t){if(1&e){const e=Lr();Nr(0,"div",19),Ur("click",(function(){qt(e);const n=t.index,o=t.$implicit;return Hr(2).selectNodeType(n,o.name)})),ls(1),jr()}if(2&e){const e=t.$implicit,n=t.index,o=Hr(2);Gr("id","node_",n,"'"),Er("ngClass",o.select_node_type==n?"selected_button":""),Or("value",e.name),Io(1),us(e.name)}}function Bm(e,t){if(1&e){const e=Lr();Nr(0,"div",20),Ur("click",(function(){qt(e);const n=t.index,o=t.$implicit;return Hr(2).selectClassMethod(n,o.name)})),ls(1),jr()}if(2&e){const e=t.$implicit,n=t.index,o=Hr(2);Gr("id","class_method_",n,""),Er("ngClass",o.select_method_type==n?"selected_button":""),Or("value",e.name),Io(1),us(e.name)}}function Vm(e,t){if(1&e){const e=Lr();Nr(0,"div",25),Nr(1,"input",26),Ur("change",(function(t){qt(e);const n=Hr().$implicit;return Hr(2).getParameterValue(t,n.name)})),jr(),Nr(2,"div",27),ls(3," Select a CSV file. "),jr(),Nr(4,"div",28),ls(5,"Select File"),jr(),zr(6,"p",29),jr()}}function Hm(e,t){if(1&e){const e=Lr();Nr(0,"div",30),Nr(1,"input",31),Ur("focusout",(function(t){qt(e);const n=Hr().$implicit;return Hr(2).getParameterValue(t,n.name)})),jr(),jr()}if(2&e){const e=Hr(),t=e.index,n=e.$implicit;Io(1),Gr("id","parameter_",t,""),Er("placeholder",null!=n.default_value?n.default_value:"Enter Value")}}function qm(e,t){if(1&e&&(Nr(0,"div",21),Nr(1,"div",22),ls(2),li(3,"titlecase"),jr(),Fr(4,Vm,7,0,"div",23),Fr(5,Hm,2,2,"div",24),jr()),2&e){const e=t.$implicit;Io(2),us(ui(3,3,e.name)),Io(2),Er("ngIf","object"==e.param_type[0]),Io(1),Er("ngIf","object"!=e.param_type[0])}}function Gm(e,t){if(1&e){const e=Lr();Nr(0,"div",1),Nr(1,"div",2),Nr(2,"div",3),Ur("click",(function(){return qt(e),Hr().show=!1})),zr(3,"img",4),jr(),Nr(4,"div",5),Nr(5,"p",6),ls(6),li(7,"uppercase"),jr(),Nr(8,"div"),ls(9," Properties "),jr(),jr(),Nr(10,"div",7),Nr(11,"div",8),ls(12,"Data"),jr(),Nr(13,"div",9),ls(14,"Preview"),jr(),jr(),Nr(15,"div",10),Nr(16,"div",11),Nr(17,"div",12),ls(18,"Node Type"),jr(),Fr(19,Um,2,4,"div",13),jr(),Nr(20,"div",11),Nr(21,"div",12),ls(22,"Class Type"),jr(),Fr(23,Bm,2,4,"div",14),jr(),Nr(24,"div",11),Nr(25,"div",12),ls(26,"Base Parameters"),jr(),Fr(27,qm,6,5,"div",15),jr(),jr(),Nr(28,"div",16),Nr(29,"div",17),ls(30,"Visualize Output From Node"),jr(),Nr(31,"div",18),Ur("click",(function(){return qt(e),Hr().saveConfig()})),ls(32,"Done"),jr(),jr(),jr(),jr()}if(2&e){const e=Hr();Io(6),cs(" ",ui(7,4,e.tooltype)," "),Io(13),Er("ngForOf",e.nodes),Io(4),Er("ngForOf",e.filter_methods()),Io(4),Er("ngForOf",e.input_parameters)}}let Wm=(()=>{class e{constructor(e){this.currentProjectService=e,this.jsonToolTypeMap={csv:{json:Om,parsing_method:0},"chemical-data":{json:Im,parsing_method:0},"svm-model":{json:Fm,parsing_method:1},"linear-model":{json:Dm,parsing_method:1},"nn-model":{json:Am,parsing_method:1},"dim-reduction":{json:Em,parsing_method:1},"chemml-represent":{json:Rm,parsing_method:1},"preprocessing-node":{json:Nm,parsing_method:1},"data-splitting":{json:jm,parsing_method:1},"model-selection":{json:zm,parsing_method:1},"model-metrics":{json:Lm,parsing_method:1},"helper-functions":{json:Xm,parsing_method:1}},this.nodeJson={inputs:{},library:"",method:{inputs:{},name:"",outputs:{}},module:"",name:"",outputs:{}},this.currentProjectService.chemMLJsonChange.subscribe(e=>{this.chemMLJson=e}),this.chemMLJson=this.currentProjectService.getCurrentChemMLJson(),this.show=!1,this.select_node_type=0,this.select_method_type=0}ngOnInit(){console.log(this.jsonToolTypeMap,this.tooltype),this.toolConfigParamtersUi=this.jsonToolTypeMap[this.tooltype].json,0==this.jsonToolTypeMap[this.tooltype].parsing_method?(this.nodes=this.toolConfigParamtersUi.node_functions,this.class_methods=this.toolConfigParamtersUi.node_functions[this.select_node_type].outputs,this.input_parameters=this.toolConfigParamtersUi.node_functions[this.select_node_type].inputs):(1==this.jsonToolTypeMap[this.tooltype].parsing_method||2==this.jsonToolTypeMap[this.tooltype].parsing_method)&&(this.nodes=this.toolConfigParamtersUi.nodes,this.class_methods=this.toolConfigParamtersUi.nodes[this.select_node_type].node_functions,this.input_parameters=this.toolConfigParamtersUi.nodes[this.select_node_type].inputs),this.selectNodeType(0,this.nodes[0].name),this.selectClassMethod(0,this.filter_methods()[0].name),this.nodeJson.library=this.toolConfigParamtersUi.library,this.nodeJson.module=this.toolConfigParamtersUi.module}filter_methods(){return this.class_methods.filter(e=>"_"!=e.name.charAt(0))}selectNodeType(e,t){this.select_node_type=e,this.nodeJson.name=t,console.log(this.nodeJson),0==this.jsonToolTypeMap[this.tooltype].parsing_method?(this.class_methods=this.toolConfigParamtersUi.node_functions[this.select_node_type].outputs,this.input_parameters=this.toolConfigParamtersUi.node_functions[this.select_node_type].inputs):1==this.jsonToolTypeMap[this.tooltype].parsing_method&&(this.class_methods=this.toolConfigParamtersUi.nodes[this.select_node_type].node_functions,this.input_parameters=this.toolConfigParamtersUi.nodes[this.select_node_type].inputs,console.log(this.input_parameters))}selectClassMethod(e,t){this.select_method_type=e,this.nodeJson.method.name=t,console.log(this.nodeJson)}getParameterValue(e,t){this.nodeJson.inputs[t]=e.target.value,console.log(this.nodeJson)}saveConfig(){this.show=!1;var e={};e[this.toolid]=this.nodeJson,console.log("FINAL CONFIG FOR NODE: ",this.toolid,e),console.log("Current Json",JSON.stringify(this.chemMLJson)),this.chemMLJson.nodes[this.toolid]=this.nodeJson}}return e.\u0275fac=function(t){return new(t||e)(Dr(xm))},e.\u0275cmp=lt({type:e,selectors:[["app-tool-config"]],inputs:{show:"show",tooltype:"tooltype",tool:"tool",toolid:"toolid"},decls:1,vars:1,consts:[["id","propwrap",4,"ngIf"],["id","propwrap"],["id","properties"],["id","close",3,"click"],["src","assets/close.svg"],["id","header2"],["id","tooltype"],["id","propswitch"],["id","dataprop"],["id","alertprop"],["id","proplist"],[1,"config-block"],[1,"config-title"],["class","node-function-name",3,"ngClass","id","click",4,"ngFor","ngForOf"],["class","node-function-name",3,"id","ngClass","click",4,"ngFor","ngForOf"],["class","base_parameters_container",4,"ngFor","ngForOf"],[1,"tool-config-footer"],["id","removeblock"],["id","visualize_btn",3,"click"],[1,"node-function-name",3,"ngClass","id","click"],[1,"node-function-name",3,"id","ngClass","click"],[1,"base_parameters_container"],[1,"parameter_name"],["style","width: 105%;",4,"ngIf"],["class","paramInput",4,"ngIf"],[2,"width","105%"],["type","file","id","csv_load","value","./temp/Boston.csv","hidden","","multiple","",3,"change"],["id","input_filename"],["onclick","document.getElementById('csv_load').click()","type","file","id","myfile","name","myfile",1,"select_file_btn"],["id","filename"],[1,"paramInput"],["type","text",1,"input_text",3,"placeholder","id","focusout"]],template:function(e,t){1&e&&Fr(0,Gm,33,6,"div",0),2&e&&Er("ngIf",t.show)},directives:[ku,Cu,xu],pipes:[Fu,Iu],styles:['#propwrap[_ngcontent-%COMP%]{right:0;top:70px;width:40%;height:90%;overflow:hidden;z-index:1000}#properties[_ngcontent-%COMP%], #propwrap[_ngcontent-%COMP%]{position:absolute;padding-left:20px}#properties[_ngcontent-%COMP%]{height:100%;width:85%;background-color:#fff;right:-9%;opacity:1;padding-right:0;z-index:2;box-shadow:0 2px 25px #eae6e6;transition:all .25s cubic-bezier(.05,.03,.35,1);border-left:5px solid #f1f1f1}.config-block[_ngcontent-%COMP%]{clear:both;display:block;padding-top:3%!important;padding-right:8%;margin-bottom:12%}.itson[_ngcontent-%COMP%]{z-index:2!important}#tooltype[_ngcontent-%COMP%]{width:auto;display:inline-block;margin-bottom:2%;background-color:#6d6d6f;color:#fff;border-radius:60px;border-radius:33px;font-size:.8em;padding:1.2% 2.5% .8%}.paramName[_ngcontent-%COMP%]{font-family:Roboto;font-weight:700;font-size:20px;margin-bottom:1%}.paramInput[_ngcontent-%COMP%]{display:inline-block;width:100%}.expanded[_ngcontent-%COMP%]{right:0!important;opacity:1!important;box-shadow:-4px 0 40px rgba(26,26,73,.05);z-index:2}#header2[_ngcontent-%COMP%]{font-size:20px;font-family:Roboto;font-weight:700;color:#393c44;margin-top:19px}#close[_ngcontent-%COMP%]{margin-top:9px;margin-right:9px;position:absolute;right:10%;z-index:9999;transition:all .25s cubic-bezier(.05,.03,.35,1);border-radius:9px;border:2px solid #fff;padding:3px 5px 5px 6px}#close[_ngcontent-%COMP%]:hover{cursor:pointer;border:2px solid #e9e8ef;background-color:#fbfbfb}.paramContainer[_ngcontent-%COMP%]{margin:1% 1% 2%}.select_file_btn[_ngcontent-%COMP%]{display:inline-block;width:26%;padding:1.65%;border:4px solid #227ce8;border-radius:0;color:#fff;font-family:Roboto;background-color:#227ce8;font-size:1em;text-align:center;cursor:pointer;border-top-right-radius:8px;border-bottom-right-radius:8px}#proplist[_ngcontent-%COMP%]{height:65%;overflow:scroll;padding-right:11%;padding-left:3%;margin-bottom:0}.tool-config-footer[_ngcontent-%COMP%]{position:absolute;bottom:5%;z-index:1000;padding-right:4%!important;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;width:91%;padding:3%;clear:both;left:0;background-color:#fff;border-top:1px solid #e2e2e2}.parameter_name[_ngcontent-%COMP%]{padding-top:3%;padding-bottom:1%}.input_text[_ngcontent-%COMP%], .parameter_name[_ngcontent-%COMP%]{font-size:1.2em;font-family:Roboto}.input_text[_ngcontent-%COMP%]{padding:2%;width:100%;display:inline-block;border-radius:0;background-color:#fff;border:1px solid #e2e2e2;outline:None!important}.config-title[_ngcontent-%COMP%]{font-size:20px;font-weight:700;color:#393c44}.config-title[_ngcontent-%COMP%], .node-function-name[_ngcontent-%COMP%]{font-family:Roboto;margin-bottom:1%}.node-function-name[_ngcontent-%COMP%]{background-color:#f1f4fc;border-radius:50px;font-size:1.1em;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;padding:1.5% 3%;display:inline-block;cursor:pointer;float:left;margin-right:2%;margin-top:2%;color:#525252;border-radius:29px;border:1px solid #e8e8ef;transition:.2s}.node-function-name[_ngcontent-%COMP%]:hover{background-color:#fbfbfb}.selected_button[_ngcontent-%COMP%]{color:#fff!important;background-color:#217ce8!important}#propswitch[_ngcontent-%COMP%]{border-bottom:1px solid #e8e8ef;width:100%;margin-top:10px;margin-left:-20px;margin-bottom:30px}#dataprop[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#393c44;width:44%;height:48px;line-height:48px;display:inline-block;float:left;margin-left:20px}#dataprop[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}#alertprop[_ngcontent-%COMP%]{font-weight:500;color:#808292;font-size:14px;height:48px;line-height:48px;width:44%;text-align:center;float:left}#alertprop[_ngcontent-%COMP%], .inputlabel[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto}.inputlabel[_ngcontent-%COMP%]{font-size:1.1em;color:#253134;font-weight:800}.dropme[_ngcontent-%COMP%]{background-color:#fff;border-radius:5px;border:1px solid #e8e8ef;box-shadow:0 2px 8px rgba(34,34,87,.05);font-family:Roboto;font-size:14px;color:#253134;text-indent:20px;height:40px;line-height:40px;width:287px;margin-bottom:25px}.dropme[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:17px;float:right;margin-right:15px}.checkus[_ngcontent-%COMP%]{margin-bottom:10px}.checkus[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;margin-left:10px}#divisionthing[_ngcontent-%COMP%]{height:1px;width:100%;background-color:#e8e8ef;position:absolute;right:0;bottom:85px}#removeblock[_ngcontent-%COMP%]{width:287px;color:#253134}#removeblock[_ngcontent-%COMP%], #visualize_btn[_ngcontent-%COMP%]{border-radius:5px;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;height:38px;line-height:38px;border:1px solid #e8e8ef;transition:all .3s cubic-bezier(.05,.03,.35,1);display:inline-block}#visualize_btn[_ngcontent-%COMP%]{width:15%;color:#fff;right:12%;background-color:#247ce8;cursor:pointer;float:right}#input_filename[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto;border:1px solid #e2e2e2;padding:2%;width:70%}']}),e})();function $m(e,t){if(1&e){const e=Lr();Nr(0,"div",19),Ur("click",(function(){qt(e);const n=t.index,o=t.$implicit;return Hr(2).selectOutputType(n,o.name)})),ls(1),jr()}if(2&e){const e=t.$implicit,n=t.index,o=Hr(2);Gr("id","node_",n,"'"),Er("ngClass",o.select_output_type==n?"selected_button":""),Or("value",e.name),Io(1),us(e.name)}}function Zm(e,t){if(1&e){const e=Lr();Nr(0,"div",19),Ur("click",(function(){qt(e);const n=t.index,o=t.$implicit,a=Hr(),r=a.index,s=a.$implicit;return Hr(2).selectInputType(r,n,s.name,o.name)})),ls(1),jr()}if(2&e){const e=t.$implicit,n=t.index,o=Hr().index,a=Hr(2);Gr("id","node_",n,"'"),Er("ngClass",a.select_input_type[o]==n?"selected_button":""),Or("value",e.name),Io(1),us(e.name)}}function Km(e,t){if(1&e&&(Nr(0,"div",20),Nr(1,"div",21),ls(2),jr(),Fr(3,Zm,2,4,"div",14),jr()),2&e){const e=t.$implicit,n=Hr(2);Io(2),cs(" ",e.name," "),Io(1),Er("ngForOf",n.parentOutputs)}}function Jm(e,t){if(1&e){const e=Lr();Nr(0,"div",1),Nr(1,"div",2),Nr(2,"div",3),Ur("click",(function(){return qt(e),Hr().show=!1})),zr(3,"img",4),jr(),Nr(4,"div",5),Nr(5,"p",6),ls(6),li(7,"uppercase"),li(8,"uppercase"),jr(),Nr(9,"div"),ls(10," Properties "),jr(),jr(),Nr(11,"div",7),Nr(12,"div",8),ls(13,"Data"),jr(),Nr(14,"div",9),ls(15,"Preview"),jr(),Nr(16,"div",10),ls(17,"Logs"),jr(),jr(),Nr(18,"div",11),Nr(19,"div",12),Nr(20,"div",13),ls(21,"Parent Node Outputs"),jr(),Fr(22,$m,2,4,"div",14),jr(),Nr(23,"div",12),Nr(24,"div",13),ls(25,"Child Node Inputs"),jr(),Fr(26,Km,4,2,"div",15),jr(),jr(),zr(27,"div",16),Nr(28,"div",17),ls(29,"Visualize Output From Node"),jr(),Nr(30,"div",18),Ur("click",(function(){return qt(e),Hr().show=!1})),ls(31,"Done"),jr(),jr(),jr()}if(2&e){const e=Hr();Io(6),ps(" ",ui(7,4,e.parentToolType)," - ",ui(8,6,e.childToolType)," "),Io(16),Er("ngForOf",e.parentOutputs),Io(4),Er("ngForOf",e.childInputs)}}let Qm=(()=>{class e{constructor(e){this.currentProjectService=e,this.input_parameters=[],this.jsonToolTypeMap={csv:{json:Om,parsing_method:0},"chemical-data":{json:Im,parsing_method:0},"svm-model":{json:Fm,parsing_method:1},"linear-model":{json:Dm,parsing_method:1},"nn-model":{json:Am,parsing_method:1},"dim-reduction":{json:Em,parsing_method:1},"chemml-represent":{json:Rm,parsing_method:1},"preprocessing-node":{json:Nm,parsing_method:1},"data-splitting":{json:jm,parsing_method:1},"model-selection":{json:zm,parsing_method:1},"model-metrics":{json:Lm,parsing_method:1},"helper-functions":{json:Xm,parsing_method:1}},this.select_input_type=[],this.currentProjectService.chemMLJsonChange.subscribe(e=>{this.chemMLJson=e}),this.chemMLJson=this.currentProjectService.getCurrentChemMLJson()}ngOnInit(){this.select_output_type=0,this.parentToolType=this.parentId.split("_")[1],this.childToolType=this.childId.split("_")[1];var e=this.chemMLJson.nodes[this.parentId],t=this.chemMLJson.nodes[this.childId];if(0==this.jsonToolTypeMap[this.parentToolType].parsing_method)for(var n=this.jsonToolTypeMap[this.parentToolType].json.node_functions,o=0;o<n.length;o++)if(n[o].name==e.name){this.parentOutputs=n[o].outputs;break}if(1==this.jsonToolTypeMap[this.parentToolType].parsing_method){var a=this.jsonToolTypeMap[this.parentToolType].json.nodes;for(console.log(a),o=0;o<a.length;o++)if(console.log(e),a[o].name==e.name){n=a[o].node_functions;break}for(console.log(n),o=0;o<n.length;o++)if(n[o].name==e.method.name){this.parentOutputs=n[o].outputs;break}}if(1==this.jsonToolTypeMap[this.childToolType].parsing_method){for(console.log(this.jsonToolTypeMap[this.childToolType].json.nodes,this.jsonToolTypeMap[this.childToolType].json.nodes[t.name],t.name),a=this.jsonToolTypeMap[this.childToolType].json.nodes,o=0;o<a.length;o++)if(a[o].name==t.name){n=a[o].node_functions;break}for(o=0;o<n.length;o++)if(n[o].name==t.method.name){this.childInputs=n[o].inputs;break}for(o=0;o<this.childInputs.length;o++)this.select_input_type.push(0)}console.log(this.parentOutputs,this.childInputs)}selectOutputType(e,t){this.select_output_type=e,"data"==t&&(t="df"),"csv"!=this.parentToolType&&"chemical-data"!=this.parentToolType||(this.chemMLJson.nodes[this.parentId].outputs[t]=!0),"csv"==this.parentToolType?(this.chemMLJson.nodes[this.parentId].inputs.filepath_or_buffer="./temp/Boston.csv",this.chemMLJson.nodes[this.parentId].module=""):this.chemMLJson.nodes[this.parentId].method.outputs[t]=!0,console.log(this.chemMLJson)}selectInputType(e,t,n,o){this.select_input_type[e]=t,"data"==o&&(o="df"),"helper-functions"==this.childToolType&&(n="X"),this.chemMLJson.nodes[this.childId].method.inputs[n]="@"+this.parentId+"@"+o,console.log(e,t),console.log(this.chemMLJson)}}return e.\u0275fac=function(t){return new(t||e)(Dr(xm))},e.\u0275cmp=lt({type:e,selectors:[["app-input-output-config"]],inputs:{parentId:"parentId",childId:"childId",show:"show"},decls:1,vars:1,consts:[["id","propwrap",4,"ngIf"],["id","propwrap"],["id","properties"],["id","close",3,"click"],["src","assets/close.svg"],["id","header2"],["id","tooltype"],["id","propswitch"],["id","dataprop"],["id","alertprop"],["id","logsprop"],["id","proplist"],[1,"config-block"],[1,"config-title"],["class","node-function-name",3,"ngClass","id","click",4,"ngFor","ngForOf"],["class","config-input",4,"ngFor","ngForOf"],["id","divisionthing"],["id","removeblock"],["id","visualize_btn",3,"click"],[1,"node-function-name",3,"ngClass","id","click"],[1,"config-input"],[1,"config-subtitle"]],template:function(e,t){1&e&&Fr(0,Jm,32,8,"div",0),2&e&&Er("ngIf",t.show)},directives:[ku,Cu,xu],pipes:[Fu],styles:['#propwrap[_ngcontent-%COMP%]{right:0;top:0;width:40%;overflow:hidden;z-index:1000}#properties[_ngcontent-%COMP%], #propwrap[_ngcontent-%COMP%]{position:absolute;height:100%;padding-left:20px}#properties[_ngcontent-%COMP%]{width:100%;background-color:#fff;right:-9%;opacity:1;padding-right:0;z-index:2;box-shadow:0 2px 25px #eae6e6;transition:all .25s cubic-bezier(.05,.03,.35,1);border-left:5px solid #f1f1f1}.config-block[_ngcontent-%COMP%]{clear:both;display:block;padding-top:3%!important;padding-right:8%}.itson[_ngcontent-%COMP%]{z-index:2!important}#tooltype[_ngcontent-%COMP%]{width:auto;display:inline-block;margin-bottom:2%;background-color:#6d6d6f;color:#fff;border-radius:33px;padding:1.2% 2.5% .8%;font-size:.8em}.paramName[_ngcontent-%COMP%]{font-family:Roboto;font-weight:700;font-size:20px;margin-bottom:1%}.paramInput[_ngcontent-%COMP%]{display:inline-block;width:100%}.expanded[_ngcontent-%COMP%]{right:0!important;opacity:1!important;box-shadow:-4px 0 40px rgba(26,26,73,.05);z-index:2}#header2[_ngcontent-%COMP%]{font-size:20px;font-family:Roboto;font-weight:700;color:#393c44;margin-top:101px}#close[_ngcontent-%COMP%]{margin-top:100px;position:absolute;right:10%;z-index:9999;transition:all .25s cubic-bezier(.05,.03,.35,1);border-radius:9px;border:2px solid #fff;padding:9px 9px 4px}#close[_ngcontent-%COMP%]:hover{cursor:pointer;border:2px solid #e9e8ef;background-color:#fbfbfb}.paramContainer[_ngcontent-%COMP%]{margin:1% 1% 2%}.select_file_btn[_ngcontent-%COMP%]{display:inline-block;width:17%;padding:1.65%;border:4px solid #227ce8;border-radius:0;color:#fff;font-family:Roboto;background-color:#227ce8;font-size:1em;text-align:center;cursor:pointer;border-top-right-radius:8px;border-bottom-right-radius:8px}#proplist[_ngcontent-%COMP%]{height:68%;overflow:scroll;padding-right:11%;padding-left:3%}.parameter_name[_ngcontent-%COMP%]{padding-top:3%;padding-bottom:1%}.input_text[_ngcontent-%COMP%], .parameter_name[_ngcontent-%COMP%]{font-size:1.2em;font-family:Roboto}.input_text[_ngcontent-%COMP%]{padding:2%;width:100%;display:inline-block;border-radius:0;background-color:#fff;border:1px solid #e2e2e2;outline:None!important}.config-input[_ngcontent-%COMP%]{margin-top:2%;display:block;height:110px;border-top:1px solid #e2e2e2;padding-top:3%}.config-subtitle[_ngcontent-%COMP%]{font-weight:600}.config-title[_ngcontent-%COMP%]{font-size:20px;font-weight:700;color:#393c44}.config-title[_ngcontent-%COMP%], .node-function-name[_ngcontent-%COMP%]{font-family:Roboto;margin-bottom:1%}.node-function-name[_ngcontent-%COMP%]{background-color:#f1f4fc;border-radius:50px;font-size:1.1em;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;padding:1.5% 3%;display:inline-block;cursor:pointer;float:left;margin-right:2%;margin-top:2%;color:#525252;border-radius:29px;border:1px solid #e8e8ef;transition:.2s}.node-function-name[_ngcontent-%COMP%]:hover{background-color:#fbfbfb}.selected_button[_ngcontent-%COMP%]{color:#fff!important;background-color:#217ce8!important}#propswitch[_ngcontent-%COMP%]{border-bottom:1px solid #e8e8ef;width:100%;margin-top:10px;margin-left:-20px;margin-bottom:30px}#dataprop[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#393c44;width:29.33333%;height:48px;line-height:48px;display:inline-block;float:left;margin-left:20px}#dataprop[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}#alertprop[_ngcontent-%COMP%]{float:left}#alertprop[_ngcontent-%COMP%], #logsprop[_ngcontent-%COMP%]{font-weight:500;color:#808292;font-size:14px;height:48px;line-height:48px;width:29.33333%;text-align:center}#alertprop[_ngcontent-%COMP%], #logsprop[_ngcontent-%COMP%], .inputlabel[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto}.inputlabel[_ngcontent-%COMP%]{font-size:1.1em;color:#253134;font-weight:800}.dropme[_ngcontent-%COMP%]{background-color:#fff;border-radius:5px;border:1px solid #e8e8ef;box-shadow:0 2px 8px rgba(34,34,87,.05);font-family:Roboto;font-size:14px;color:#253134;text-indent:20px;height:40px;line-height:40px;width:287px;margin-bottom:25px}.dropme[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:17px;float:right;margin-right:15px}.checkus[_ngcontent-%COMP%]{margin-bottom:10px}.checkus[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;margin-left:10px}#divisionthing[_ngcontent-%COMP%]{height:1px;width:100%;background-color:#e8e8ef;position:absolute;right:0;bottom:85px}#removeblock[_ngcontent-%COMP%]{width:287px;color:#253134}#removeblock[_ngcontent-%COMP%], #visualize_btn[_ngcontent-%COMP%]{border-radius:5px;position:absolute;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;height:38px;line-height:38px;border:1px solid #e8e8ef;transition:all .3s cubic-bezier(.05,.03,.35,1)}#visualize_btn[_ngcontent-%COMP%]{width:15%;color:#fff;right:12%;background-color:#247ce8;cursor:pointer}#input_filename[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto;border:1px solid #e2e2e2;padding:2%;width:74%}']}),e})();function Ym(e,t){if(1&e&&(Nr(0,"div",18),ls(1),jr()),2&e){const e=t.$implicit;qr("id",e),Io(1),us(e)}}function ef(e,t){if(1&e&&(Nr(0,"div",18),ls(1),jr()),2&e){const e=t.$implicit;qr("id",e),Io(1),us(e)}}let tf=(()=>{class e{constructor(e,t){this.currentProjectService=e,this.dataServiceService=t,this.emitter=new di,this.imageFiles=[],this.documentFiles=[],this.image_extensions=["png","jpg","jpeg","svg"],this.document_extensions=["pdf","csv","txt","tsv"]}ngOnInit(){this.dataServiceService.getProjectFiles(this.currentProject.project_name).subscribe(e=>{for(var t in this.projectFiles=e.data,this.projectFiles)console.log(this.projectFiles[t].split(".").pop()),this.image_extensions.indexOf(this.projectFiles[t].split(".").pop())>-1?this.imageFiles.push(this.projectFiles[t]):this.documentFiles.push(this.projectFiles[t]);console.log(e)})}closeMenu(){this.emitter.emit(this.show)}selectFiles(){document.getElementById("file-input").click()}UploadFiles(e){console.log(e,this.currentProject.project_name),this.filesToUpload=e;for(var t=0;t<this.filesToUpload.length;t++)console.log("Files Upload: ",this.filesToUpload[t]),this.dataServiceService.postFile(this.filesToUpload[t],this.currentProject.project_name).subscribe(e=>{e.type===Qh.UploadProgress&&(this.fileUploadProgress=Math.round(100*e.loaded/e.total),console.log(this.fileUploadProgress)),this.reRenderMenu()})}reRenderMenu(){this.imageFiles=[],this.documentFiles=[],this.dataServiceService.getProjectFiles(this.currentProject.project_name).subscribe(e=>{for(var t in this.projectFiles=e.data,this.projectFiles)console.log(this.projectFiles[t].split(".").pop()),this.image_extensions.indexOf(this.projectFiles[t].split(".").pop())>-1?this.imageFiles.push(this.projectFiles[t]):this.documentFiles.push(this.projectFiles[t]);console.log(e)})}}return e.\u0275fac=function(t){return new(t||e)(Dr(xm),Dr(vm))},e.\u0275cmp=lt({type:e,selectors:[["app-left-files-bar-component"]],inputs:{show:"show",currentProject:"currentProject"},outputs:{emitter:"emitter"},decls:29,vars:2,consts:[[1,"container"],[1,"close-btn",3,"click"],[1,"header"],["clas","title"],[1,"sub-title"],[1,"btns-menu"],["id","file",1,"upload-btn",3,"click"],["id","file-input","type","file","name","name","hidden","","multiple","",3,"change"],[1,"tabs-menu"],["id","propswitch"],["id","projectfilesprop",1,"tab"],["id","samplefilesprop",1,"tab"],[1,"body"],[1,"body-element"],["id","documentType",1,"file-type"],[1,"files-body"],["class","file",3,"id",4,"ngFor","ngForOf"],["id","imageType",1,"file-type"],[1,"file",3,"id"]],template:function(e,t){1&e&&(Nr(0,"div",0),Nr(1,"div",1),Ur("click",(function(){return t.closeMenu()})),ls(2," X "),jr(),Nr(3,"div",2),Nr(4,"div",3),ls(5," Files "),jr(),Nr(6,"div",4),ls(7," Upload files here to import them to your project "),jr(),jr(),Nr(8,"div",5),Nr(9,"div",6),Ur("click",(function(){return t.selectFiles()})),ls(10," Upload Files "),jr(),Nr(11,"input",7),Ur("change",(function(e){return t.UploadFiles(e.target.files)})),jr(),jr(),Nr(12,"div",8),Nr(13,"div",9),Nr(14,"div",10),ls(15,"Project Files"),jr(),Nr(16,"div",11),ls(17,"Sample Files"),jr(),jr(),jr(),Nr(18,"div",12),Nr(19,"div",13),Nr(20,"div",14),ls(21," Documents "),jr(),Nr(22,"div",15),Fr(23,Ym,2,2,"div",16),jr(),jr(),Nr(24,"div",13),Nr(25,"div",17),ls(26," Images "),jr(),Nr(27,"div",15),Fr(28,ef,2,2,"div",16),jr(),jr(),jr(),jr()),2&e&&(Io(23),Er("ngForOf",t.documentFiles),Io(5),Er("ngForOf",t.imageFiles))},directives:[Cu],styles:['.container[_ngcontent-%COMP%]{position:absolute;top:70px;height:86%;width:22%;background-color:#fff;z-index:1000;border-right:1px solid #e2e2e2;padding:0}.header[_ngcontent-%COMP%]{font-size:1.5em;font-family:Roboto;padding:3% 3% 3% 5%;background-color:#f1f4fc;color:#3f4248;border-bottom:1px solid rgba(238,34,238,.13);font-weight:800}.sub-title[_ngcontent-%COMP%]{padding-top:1%;font-size:.6em;font-family:Roboto;color:#747474;font-weight:200}#propswitch[_ngcontent-%COMP%]{width:100%;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;padding:2% 1% 1%}.upload-btn[_ngcontent-%COMP%]{width:80%;text-align:center;padding:4%;margin:5% 11% 2%;border:2px solid #217ce8;border-radius:6px;color:#217ce8;font-weight:500;font-family:Roboto;cursor:pointer;transition:.5s}.upload-btn[_ngcontent-%COMP%]:hover{background-color:#217ce8;color:#fff}#projectfilesprop[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#393c44;width:46%;height:48px;line-height:48px;display:inline-block;float:left;margin-left:20px}#projectfilesprop[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}.close-btn[_ngcontent-%COMP%]{position:absolute;top:0;right:0;padding:1.2% 3% 1.1%;background-color:#b9b9b9;color:#fff;border-radius:3px;margin:2%;font-size:12px;font-weight:500;font-family:cursive;cursor:pointer}.close-btn[_ngcontent-%COMP%]:hover{background-color:#9f9f9f}.body[_ngcontent-%COMP%]{clear:both;padding:1% 5% 5%;overflow:scroll;height:66%}.body-element[_ngcontent-%COMP%]{margin-top:3%}.file[_ngcontent-%COMP%]{padding:2% 2% 2% 4%;border-bottom:1px solid #e2e2e2;cursor:pointer}.file[_ngcontent-%COMP%]:hover{background-color:#e2e2e2}.file-type[_ngcontent-%COMP%]{clear:both;font-size:15px;margin-bottom:3%;margin-top:8%}#samplefilesprop[_ngcontent-%COMP%], .file-type[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500}#samplefilesprop[_ngcontent-%COMP%]{display:inline-block;color:#808292;font-size:14px;height:48px;line-height:48px;width:46%;text-align:center;float:left}']}),e})(),nf=(()=>{class e{constructor(e,t){this.dataServiceService=e,this.currentProjectService=t,this.closeBoxEmit=new di,this.currentProjectService.execChange.subscribe(e=>{this.currentProject=e})}closeBox(){this.closeBoxEmit.emit()}ngOnInit(){}createProject(e){this.dataServiceService.createProject(e).subscribe(e=>{this.currentProject=e.data,this.currentProjectService.updateProjectInfo(this.currentProject)}),this.closeBox()}}return e.\u0275fac=function(t){return new(t||e)(Dr(vm),Dr(xm))},e.\u0275cmp=lt({type:e,selectors:[["app-new-project-box"]],outputs:{closeBoxEmit:"closeBoxEmit"},decls:10,vars:0,consts:[[1,"overlay"],[1,"np-box-container"],[1,"title"],["placeholder","Name for your project","type","text",1,"input_text"],["projectname",""],[1,"submit-btn",3,"click"],[1,"close-btn",3,"click"]],template:function(e,t){if(1&e){const e=Lr();zr(0,"div",0),Nr(1,"div",1),Nr(2,"div",2),ls(3,"Start New Project"),jr(),zr(4,"input",3,4),Nr(6,"div",5),Ur("click",(function(){qt(e);const n=At(Ut.lFrame.contextLView,5);return t.createProject(n.value)})),ls(7,"Create Project"),jr(),Nr(8,"div",6),Ur("click",(function(){return t.closeBox()})),ls(9,"Cancel"),jr(),jr()}},styles:[".np-box-container[_ngcontent-%COMP%]{position:absolute;left:42%;top:40%;background-color:#fff;padding:2%;border-radius:11px;box-shadow:2px 2px 25px 2px #292929;z-index:1000;border-top:19px solid #227ce8}.title[_ngcontent-%COMP%]{font-family:Roboto;font-weight:800;font-size:19px;margin-bottom:8%;color:#393c44}.overlay[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;background-color:rgba(0,0,0,.72);z-index:999}.input_text[_ngcontent-%COMP%]{width:318px;height:40px;border:1px solid #e8e8ef;box-sizing:border-box;box-shadow:0 2px 8px rgba(34,34,87,.05);border-radius:5px;text-indent:35px;font-size:20px;width:100%;color:#393c44;padding:8% 3%}.input_text[_ngcontent-%COMP%], .submit-btn[_ngcontent-%COMP%]{background-color:#fff;font-family:Roboto}.submit-btn[_ngcontent-%COMP%]{font-weight:800;color:#217ce8;border-radius:5px;border:2px solid #217ce8;margin-top:8%;font-size:14px;padding:1% 5%;float:right;display:inline-block;vertical-align:top;text-align:center;line-height:38px;transition:all .2s cubic-bezier(.05,.03,.35,1);cursor:pointer}.submit-btn[_ngcontent-%COMP%]:hover{color:#fff;background-color:#217ce8}.close-btn[_ngcontent-%COMP%]{font-family:Roboto;font-weight:800;color:#9c9c9c;background-color:#fff;border-radius:5px;border:2px solid #9c9c9c;margin-top:8%;font-size:14px;padding:1% 5%;float:left;display:inline-block;vertical-align:top;text-align:center;line-height:38px;transition:all .2s cubic-bezier(.05,.03,.35,1);cursor:pointer}.close-btn[_ngcontent-%COMP%]:hover{color:#fff;background-color:#9c9c9c}"]}),e})();function of(e,t){if(1&e){const e=Lr();Nr(0,"div",13),Ur("click",(function(){qt(e);const n=t.index,o=t.$implicit;return Hr().selectProject("project_"+n,o)})),Nr(1,"span",14),ls(2),jr(),Nr(3,"span",9),ls(4),li(5,"timePipe"),jr(),jr()}if(2&e){const e=t.$implicit,n=t.index;Gr("id","project_",n,""),Or("data-index",n),Io(2),us(e.project_name),Io(2),us(ui(5,4,e.created_date.$date))}}let af=(()=>{class e{constructor(e,t){this.dataServiceService=e,this.currentProjectService=t,this.closeBoxEmit=new di}closeBox(){this.closeBoxEmit.emit()}createProject(){console.log("Create a new project")}ngOnInit(){this.getProjects()}getProjects(){this.dataServiceService.getProjects().subscribe(e=>{this.projectsList=e.data,this.renderList=this.projectsList,console.log(e)})}selectProject(e,t){let n=document.getElementById(e),o=n.parentElement;for(var a=0;a<o.children.length;a++)if(console.log(o.children[a].classList),o.children[a].classList.contains("selectedProject")){o.children[a].classList.remove("selectedProject"),o.children[a].classList.add("project_list_item");break}this.selectedProject=t,n.classList.remove("project_list_item"),n.classList.add("selectedProject")}searchFilter(e){let t=e.srcElement.value;0!=t.length?(this.renderList=[],this.projectsList.forEach(e=>{e.project_name.includes(t)&&this.renderList.push(e)})):this.renderList=this.projectsList}openProject(){this.currentProjectService.updateProjectInfo(this.selectedProject),this.closeBox()}}return e.\u0275fac=function(t){return new(t||e)(Dr(vm),Dr(xm))},e.\u0275cmp=lt({type:e,selectors:[["app-open-project"]],outputs:{closeBoxEmit:"closeBoxEmit"},decls:19,vars:1,consts:[[1,"overlay"],[1,"np-box-container"],[1,"title"],[1,"btm_container"],["id","search"],["src","assets/search.svg"],["type","text","placeholder","Search Pipeline Toolbox",3,"keydown"],[1,"project_list_container"],[1,"project_list_header",2,"cursor","default"],[1,"created_date"],["class","project_list_item",3,"id","click",4,"ngFor","ngForOf"],[1,"submit-btn",3,"click"],[1,"close-btn",3,"click"],[1,"project_list_item",3,"id","click"],[1,"project_name"]],template:function(e,t){1&e&&(zr(0,"div",0),Nr(1,"div",1),Nr(2,"div",2),ls(3,"Select a project"),jr(),Nr(4,"div",3),Nr(5,"div",4),zr(6,"img",5),Nr(7,"input",6),Ur("keydown",(function(e){return t.searchFilter(e)})),jr(),jr(),Nr(8,"div",7),Nr(9,"div",8),Nr(10,"span"),ls(11,"Project Name"),jr(),Nr(12,"span",9),ls(13,"Created Date"),jr(),jr(),Fr(14,of,6,6,"div",10),jr(),Nr(15,"div",11),Ur("click",(function(){return t.openProject()})),ls(16,"Open Project"),jr(),Nr(17,"div",12),Ur("click",(function(){return t.closeBox()})),ls(18,"Cancel"),jr(),jr(),jr()),2&e&&(Io(14),Er("ngForOf",t.renderList))},directives:[Cu],pipes:[Tm],styles:[".np-box-container[_ngcontent-%COMP%]{position:absolute;left:39%;top:24%;background-color:#fff;border-radius:11px;box-shadow:2px 2px 25px 2px #292929;z-index:1000;width:33%;padding-bottom:2%}.title[_ngcontent-%COMP%]{font-weight:800;border-top:20px solid #277fe8;font-size:21px;color:#393c44;border-top-left-radius:11px;border-top-right-radius:11px;padding:6% 6% 2%}#search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], .title[_ngcontent-%COMP%]{font-family:Roboto;background-color:#fff}#search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;height:40px;border:1px solid #e8e8ef;box-sizing:border-box;box-shadow:0 2px 8px rgba(34,34,87,.05);border-radius:5px;text-indent:35px;font-size:16px}#search[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;margin-top:10px;width:18px;margin-left:12px}#search[_ngcontent-%COMP%]{margin-left:3%;margin-right:3%}.project_list_container[_ngcontent-%COMP%]{margin:3% 3% 5%;height:340px;overflow:scroll}.btm_container[_ngcontent-%COMP%]{padding:2%}.overlay[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;background-color:rgba(0,0,0,.72);z-index:999;overflow:hidden;top:0;bottom:0;left:0}.selectedProject[_ngcontent-%COMP%]{margin:0;background-color:#2f85e9;color:#fff;border-radius:5px;font-weight:900;border:6px solid #2f85e9}.project_list_item[_ngcontent-%COMP%], .selectedProject[_ngcontent-%COMP%]{font-family:Roboto;padding:2%;cursor:pointer}.project_list_item[_ngcontent-%COMP%]{border-bottom:1px solid #e2e2e2}.created_date[_ngcontent-%COMP%]{float:right}.project_name[_ngcontent-%COMP%]{font-family:Roboto}.project_list_header[_ngcontent-%COMP%]{font-family:Roboto;padding:2%;border-bottom:1px solid #e2e2e2;cursor:pointer;font-weight:500}.project_list_item[_ngcontent-%COMP%]:hover{background-color:#1744be}.input_text[_ngcontent-%COMP%]{width:318px;height:40px;border:1px solid #e8e8ef;box-sizing:border-box;box-shadow:0 2px 8px rgba(34,34,87,.05);border-radius:5px;text-indent:35px;font-size:20px;width:100%;color:#393c44;padding:8% 3%}.input_text[_ngcontent-%COMP%], .submit-btn[_ngcontent-%COMP%]{background-color:#fff;font-family:Roboto}.submit-btn[_ngcontent-%COMP%]{margin-right:4%;font-weight:800;color:#217ce8;border-radius:5px;border:2px solid #217ce8;font-size:14px;padding:1% 5%;float:right;display:inline-block;vertical-align:top;text-align:center;line-height:38px;transition:all .2s cubic-bezier(.05,.03,.35,1);cursor:pointer}.submit-btn[_ngcontent-%COMP%]:hover{color:#fff;background-color:#217ce8}.close-btn[_ngcontent-%COMP%]{margin-left:4%;font-family:Roboto;font-weight:800;color:#9c9c9c;background-color:#fff;border-radius:5px;border:2px solid #9c9c9c;font-size:14px;padding:1% 5%;float:left;display:inline-block;vertical-align:top;text-align:center;line-height:38px;transition:all .2s cubic-bezier(.05,.03,.35,1);cursor:pointer}.close-btn[_ngcontent-%COMP%]:hover{color:#fff;background-color:#9c9c9c}"]}),e})(),rf=(()=>{class e{constructor(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=lt({type:e,selectors:[["app-toolbox-component"]],inputs:{description:"description",title:"title",toot_type:"toot_type",tool:"tool"},decls:15,vars:15,consts:[[1,"blockelem","create-flowy","noselect",3,"id"],["type","hidden","name","blockelemtype","value","4",1,"blockelemtype",3,"id"],[1,"tool_header",3,"id"],[1,"grabme",3,"id"],["src","assets/grabme.svg",3,"id"],[1,"blockin",3,"id"],[1,"blockico",3,"id"],[3,"id","src"],[1,"blocktext",3,"id"],[1,"blocktitle",3,"id"],[1,"blockdesc",3,"id"],[1,"tool_footer",3,"id"]],template:function(e,t){1&e&&(Nr(0,"div",0),zr(1,"input",1),zr(2,"div",2),Nr(3,"div",3),zr(4,"img",4),jr(),Nr(5,"div",5),Nr(6,"div",6),zr(7,"span"),zr(8,"img",7),jr(),Nr(9,"div",8),Nr(10,"p",9),ls(11),jr(),Nr(12,"p",10),ls(13),jr(),jr(),jr(),zr(14,"div",11),jr()),2&e&&(Gr("id","tool_",t.tool,""),Io(1),Gr("id","tool_",t.tool,""),Io(1),Gr("id","tool_",t.tool,""),Io(1),Gr("id","tool_",t.tool,""),Io(1),Gr("id","tool_",t.tool,""),Io(1),Gr("id","tool_",t.tool,""),Io(1),Gr("id","tool_",t.tool,""),Io(2),Gr("id","tool_",t.tool,""),Gr("src","assets/tool_",t.tool,".svg",co),Io(1),Gr("id","tool_",t.tool,""),Io(1),Gr("id","tool_",t.tool,""),Io(1),us(t.title),Io(1),Gr("id","tool_",t.tool,""),Io(1),us(t.description),Io(1),Gr("id","tool_",t.tool,""))},styles:[".tool_header[_ngcontent-%COMP%]{display:None;height:11px;border-bottom:1px solid #f1f4fc;border-top-left-radius:45px;cursor:pointer;border-top-right-radius:45px}.tool_header[_ngcontent-%COMP%]:hover{background-color:#217ce8}.tool_footer[_ngcontent-%COMP%]{display:None;height:11px;border-top:1px solid #f1f4fc;border-bottom-left-radius:45px;cursor:pointer;border-bottom-right-radius:45px}.tool_footer[_ngcontent-%COMP%]:hover{background-color:#217ce8}#blocklist[_ngcontent-%COMP%]{height:calc(100% - 195px);overflow:auto}.blockelem[_ngcontent-%COMP%]:first-child{margin-top:20px}.blockelem[_ngcontent-%COMP%]{width:350px;transition-property:box-shadow,height;transition-duration:.2s;background-color:#fff;transition-timing-function:cubic-bezier(.05,.03,.35,1);border-radius:12px;box-sizing:border-box}.blockico[_ngcontent-%COMP%], .grabme[_ngcontent-%COMP%]{display:inline-block}.grabme[_ngcontent-%COMP%]{height:97px;width:7%;background-color:#fff;padding:10% 2% 2%;vertical-align:middle}.blockelem[_ngcontent-%COMP%]:hover{box-shadow:0 4px 30px rgba(22,33,74,.08);border-radius:12px;background-color:#fff;cursor:pointer}.grabme[_ngcontent-%COMP%]:hover{background-color:#f1f4fc}.noselect[_ngcontent-%COMP%]{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.blockin[_ngcontent-%COMP%]{display:inline-block;vertical-align:top;margin-left:12px;padding-top:3%}.blockico[_ngcontent-%COMP%]{width:36px;height:36px;background-color:#f1f4fc;border-radius:5px;text-align:center;white-space:nowrap}.blockico[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{height:100%;width:0}.blockico[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .blockico[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.blockico[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-left:auto;width:52%;margin-right:auto}.blocktext[_ngcontent-%COMP%]{display:inline-block;width:220px;vertical-align:top;margin-left:12px}.blocktitle[_ngcontent-%COMP%]{margin:0!important;padding:0!important;font-family:Roboto;font-weight:500;font-size:16px;color:#393c44}.blockdesc[_ngcontent-%COMP%]{margin-top:5px;font-family:Roboto;color:#808292;font-size:14px;line-height:21px;width:233px}.blockdisabled[_ngcontent-%COMP%]{background-color:#f0f2f9;opacity:.5}#proplist[_ngcontent-%COMP%]{height:calc(100% - 305px);overflow:auto;margin-top:-30px;padding-top:13px}.blockintree[_ngcontent-%COMP%]{box-shadow:1px 2px 15px #e2e2e2;margin-bottom:20%;border-radius:12px}"]}),e})(),sf=(()=>{class e{constructor(){this.is_toolbox_show=0,this.selectedToolSet="Data"}toolbox_show(){0==this.is_toolbox_show?(document.getElementById("leftcard").style.left="-18%",this.is_toolbox_show=180,document.getElementById("close_img").style.transform="rotate("+this.is_toolbox_show+"deg)",console.log(document.getElementById("close_img").style.transform,"rotate("+this.is_toolbox_show+"deg);")):(document.getElementById("leftcard").style.left="0%",this.is_toolbox_show=0,document.getElementById("close_img").style.transform="rotate("+this.is_toolbox_show+"deg)")}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=lt({type:e,selectors:[["app-toolbox"]],decls:40,vars:12,consts:[["id","leftcard"],["id","closecard",3,"click"],["id","close_img","src","assets/closeleft.svg"],["id","header"],["id","search"],["src","assets/search.svg"],["type","text","placeholder","Search Pipeline Toolbox"],["id","subnav"],["id","actions",1,"side",3,"ngClass","click"],["id","loggers",1,"side",3,"ngClass","click"],[1,"toolset_container"],["tooltype","Represent",1,"toolset-holder",3,"hidden"],["tooltype","Represent","tool","dim-reduction","title","Dimentionality Reduction","description","Drag the tool to perform FactorAnalysis, PCA etc."],["tooltype","Represent","tool","chemml-represent","title","Chemical Representation","description","Drag the tool to represent data using chemml chemical representations"],["tooltype","Data",1,"toolset-holder",3,"hidden"],["tooltype","Data","tool","csv","title","Import data from CSV","description","Drag the button to add a CSV Data tool to the pipeline"],["tooltype","Data","tool","chemical-data","title","Import chemical data","description","Drag the button to add a chemistry Data tool to the pipeline"],["tooltype","Preprocessing",1,"toolset-holder",3,"hidden"],["tooltype","Preprocessing","tool","preprocessing-node","title","Preprocessing","description","Perform preprocessing like scaling each feature"],["tooltype","Preprocessing","tool","data-splitting","title","Data Splitting","description","Split your data for test, training and validation"],["tooltype","Model",1,"toolset-holder",3,"hidden"],["tooltype","Model","tool","linear-model","title","Linear Model","description","Drag the button to add a Linear Model"],["tooltype","Model","tool","nn-model","title","Neural Network","description","Drag the button to add a Neural Network"],["tooltype","Model","tool","svm-model","title","Support Vector Machines","description","Drag the button to add a Support Vector Machines"],["tooltype","Optimize","tool","model-selection","title","Model Selection","description","Drag the button to add a search and evaluate models"],["tooltype","Optimize","tool","model-metrics","title","Model Metrics","description","Drag the button to add a select metrics"],["tooltype","Helper",1,"toolset-holder",3,"hidden"],["tooltype","Helper","tool","helper-functions","title","Saving Results","description","Drag this tool to save your results in a file"]],template:function(e,t){1&e&&(Nr(0,"div",0),Nr(1,"div",1),Ur("click",(function(){return t.toolbox_show()})),zr(2,"img",2),jr(),Nr(3,"p",3),ls(4,"Pipeline Toolbox"),jr(),Nr(5,"div",4),zr(6,"img",5),zr(7,"input",6),jr(),Nr(8,"div",7),Nr(9,"div",8),Ur("click",(function(){return t.selectedToolSet="Data"})),ls(10,"Data"),jr(),Nr(11,"div",8),Ur("click",(function(){return t.selectedToolSet="Represent"})),ls(12,"Represent"),jr(),Nr(13,"div",8),Ur("click",(function(){return t.selectedToolSet="Preprocessing"})),ls(14,"Prepare"),jr(),Nr(15,"div",9),Ur("click",(function(){return t.selectedToolSet="Model"})),ls(16,"Model"),jr(),Nr(17,"div",9),Ur("click",(function(){return t.selectedToolSet="Optimize"})),ls(18,"Optimize"),jr(),Nr(19,"div",9),Ur("click",(function(){return t.selectedToolSet="Helper"})),ls(20,"Helper Functions"),jr(),jr(),Nr(21,"div",10),Nr(22,"div",11),zr(23,"app-toolbox-component",12),zr(24,"app-toolbox-component",13),jr(),Nr(25,"div",14),zr(26,"app-toolbox-component",15),zr(27,"app-toolbox-component",16),jr(),Nr(28,"div",17),zr(29,"app-toolbox-component",18),zr(30,"app-toolbox-component",19),jr(),Nr(31,"div",20),zr(32,"app-toolbox-component",21),zr(33,"app-toolbox-component",22),zr(34,"app-toolbox-component",23),jr(),Nr(35,"div",20),zr(36,"app-toolbox-component",24),zr(37,"app-toolbox-component",25),jr(),Nr(38,"div",26),zr(39,"app-toolbox-component",27),jr(),jr(),jr()),2&e&&(Io(9),Er("ngClass","Data"===t.selectedToolSet?"navactive":"navdisabled"),Io(2),Er("ngClass","Represent"===t.selectedToolSet?"navactive":"navdisabled"),Io(2),Er("ngClass","Preprocessing"===t.selectedToolSet?"navactive":"navdisabled"),Io(2),Er("ngClass","Model"===t.selectedToolSet?"navactive":"navdisabled"),Io(2),Er("ngClass","Optimize"===t.selectedToolSet?"navactive":"navdisabled"),Io(2),Er("ngClass","Helper"===t.selectedToolSet?"navactive":"navdisabled"),Io(3),Er("hidden","Represent"!==t.selectedToolSet),Io(3),Er("hidden","Data"!==t.selectedToolSet),Io(3),Er("hidden","Preprocessing"!==t.selectedToolSet),Io(3),Er("hidden","Model"!==t.selectedToolSet),Io(4),Er("hidden","Optimize"!==t.selectedToolSet),Io(3),Er("hidden","Helper"!==t.selectedToolSet))},directives:[xu,rf],styles:['body[_ngcontent-%COMP%], html[_ngcontent-%COMP%]{margin:0;padding:0;overflow:hidden;background-image:url(/tile.fbe7a47e69fceb215897.png);background-repeat:repeat;background-size:30px 30px;background-color:#fbfbfb;height:100%}.side[_ngcontent-%COMP%]{width:25%!important;margin-left:10%!important}.select_file_btn[_ngcontent-%COMP%]{display:inline-block;border-radius:5px;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;width:287px;height:38px;line-height:38px;color:#253134;border:1px solid #e8e8ef;transition:all .3s cubic-bezier(.05,.03,.35,1)}.select_file_btn[_ngcontent-%COMP%]:hover{background-color:#217ce8;color:#fff}.items[_ngcontent-%COMP%]{display:inline-block;background-color:#237ce8;color:#fff;border-radius:26px;font-family:Roboto;padding:11px 1%;margin:15px 15px 15px 2%}.visualize[_ngcontent-%COMP%]{height:90%;background-color:#fff;padding:0;border-radius:15px;margin:9% 3% 5%}.axis[_ngcontent-%COMP%]   line[_ngcontent-%COMP%], .axis[_ngcontent-%COMP%]   path[_ngcontent-%COMP%]{fill:none;stroke:#000;shape-rendering:crispEdges}.axis[_ngcontent-%COMP%]   text[_ngcontent-%COMP%]{font-family:sans-serif;font-size:11px}#navigation[_ngcontent-%COMP%]{border-radius:18px;height:71px;background-color:#fff;border-bottom:1px solid #e8e8ef;width:96%;display:table;box-sizing:border-box;position:fixed;top:0;margin:2%}#back[_ngcontent-%COMP%]{width:40px;height:40px;border-radius:100px;background-color:#f1f4fc;text-align:center;display:inline-block;vertical-align:top;margin-top:15px;margin-right:10px}#back[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:13px}#names[_ngcontent-%COMP%]{display:inline-block;vertical-align:top}#title[_ngcontent-%COMP%]{font-weight:500;font-size:16px;color:#393c44;margin-bottom:0}#subtitle[_ngcontent-%COMP%], #title[_ngcontent-%COMP%]{font-family:Roboto}#subtitle[_ngcontent-%COMP%]{color:#808292;font-size:14px;margin-top:5px}#leftside[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle;margin-left:20px}#centerswitch[_ngcontent-%COMP%]{position:absolute;width:222px;left:50%;margin-left:-111px;top:15px}#leftswitch[_ngcontent-%COMP%]{border:1px solid #e8e8ef;background-color:#fbfbfb;width:111px;border-radius:5px 0 0 5px;color:#393c44}#leftswitch[_ngcontent-%COMP%], #rightswitch[_ngcontent-%COMP%]{height:39px;line-height:39px;font-family:Roboto;display:inline-block;font-size:14px;text-align:center}#rightswitch[_ngcontent-%COMP%]{color:#808292;border-radius:0 5px 5px 0;width:102px;margin-left:-5px}#discard[_ngcontent-%COMP%], #rightswitch[_ngcontent-%COMP%]{border:1px solid #e8e8ef}#discard[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;color:#a6a6b3;width:95px;height:38px;border-radius:5px;text-align:center;line-height:38px;display:inline-block;vertical-align:top;transition:all .2s cubic-bezier(.05,.03,.35,1)}#discard[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7}#publish[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;color:#217ce8;background-color:#fff;width:143px;height:38px;margin-left:10px;display:inline-block;vertical-align:top;text-align:center;line-height:38px;margin-right:20px;transition:all .2s cubic-bezier(.05,.03,.35,1)}#publish[_ngcontent-%COMP%], #publish[_ngcontent-%COMP%]:hover{border-radius:5px;border:2px solid #217ce8}#publish[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7;background-color:#217ce8;color:#fff}#buttonsright[_ngcontent-%COMP%]{float:right;margin-top:15px}#close_img[_ngcontent-%COMP%]{transition:1.2s;transform:rotate(0deg);cursor:pointer}#leftcard[_ngcontent-%COMP%]{transition:.5s;width:370px;border:1px solid #e8e8ef;padding-top:1%;left:0;padding-left:20px;height:60%;position:absolute;z-index:2;vertical-align:middle;margin-top:8%;border-radius:16px;margin-left:2%;box-shadow:2px 2px 25px 2px #e2e2e2;padding-bottom:1%}#leftcard[_ngcontent-%COMP%], #search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{background-color:#fff;box-sizing:border-box}#search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:318px;height:40px;border:1px solid #e8e8ef;box-shadow:0 2px 8px rgba(34,34,87,.05);border-radius:5px;text-indent:35px;font-family:Roboto;font-size:16px}[_ngcontent-%COMP%]::-moz-placeholder{color:#c9c9d5}[_ngcontent-%COMP%]::-ms-input-placeholder{color:#c9c9d5}[_ngcontent-%COMP%]::placeholder{color:#c9c9d5}#search[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;margin-top:10px;width:18px;margin-left:12px}#header[_ngcontent-%COMP%]{font-size:20px;font-family:Roboto;font-weight:700;color:#393c44;z-index:1000!important}#subnav[_ngcontent-%COMP%]{border-bottom:1px solid #e8e8ef;width:calc(100% + 20px);margin-left:-20px;margin-top:10px;overflow:scroll;display:flex;border-top:1px solid #e8e8ef}.navdisabled[_ngcontent-%COMP%]{transition:all .3s cubic-bezier(.05,.03,.35,1)}.navdisabled[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.5}.navactive[_ngcontent-%COMP%]{color:#393c44!important}#triggers[_ngcontent-%COMP%]{margin-left:20px;font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#808292;width:29.33333%;height:48px;line-height:48px;display:inline-block;float:left}.navactive[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}#actions[_ngcontent-%COMP%]{float:left}#actions[_ngcontent-%COMP%], #loggers[_ngcontent-%COMP%]{display:inline-block;font-weight:500;color:#808292;height:48px;line-height:48px;width:29.33333%;text-align:center}#actions[_ngcontent-%COMP%], #footer[_ngcontent-%COMP%], #loggers[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px}#footer[_ngcontent-%COMP%]{position:absolute;left:0;padding-left:20px;line-height:40px;bottom:0;width:362px;border:1px solid #e8e8ef;height:67px;box-sizing:border-box;background-color:#fff}#footer[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none;color:#393c44;transition:all .2s cubic-bezier(.05,.03,.35,1)}#footer[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{opacity:.5}#footer[_ngcontent-%COMP%]   p[_ngcontent-%COMP%], #footer[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#808292}#footer[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{display:inline-block}#footer[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-left:5px;margin-right:5px}#closecard[_ngcontent-%COMP%]{position:absolute;margin-left:347px;background-color:#fff;border-radius:0 5px 5px 0;border-bottom:1px solid #e8e8ef;border-right:1px solid #e8e8ef;border-top:1px solid #e8e8ef;width:53px;height:53px;text-align:center;z-index:10;top:9%}#closecard[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:15px}.toolset_container[_ngcontent-%COMP%]{padding-bottom:8%;height:63%;clear:both;overflow:scroll}#canvas[_ngcontent-%COMP%]{position:absolute;width:calc(100% - 361px);height:calc(100% - 71px);top:71px;left:361px;z-index:0;overflow:auto}#header[_ngcontent-%COMP%]{margin-left:1%!important}#search[_ngcontent-%COMP%]{margin-bottom:7%!important}#propwrap[_ngcontent-%COMP%]{right:0;width:95%;overflow:hidden;z-index:-2}#properties[_ngcontent-%COMP%], #propwrap[_ngcontent-%COMP%]{position:absolute;top:0;height:100%;padding-left:20px}#properties[_ngcontent-%COMP%]{width:70%;background-color:#fff;right:-150px;opacity:0;z-index:2;box-shadow:-4px 0 40px rgba(26,26,73,0);transition:all .25s cubic-bezier(.05,.03,.35,1)}.itson[_ngcontent-%COMP%]{z-index:2!important}.expanded[_ngcontent-%COMP%]{right:0!important;opacity:1!important;box-shadow:-4px 0 40px rgba(26,26,73,.05);z-index:2}#header2[_ngcontent-%COMP%]{font-size:20px;font-family:Roboto;font-weight:700;color:#393c44;margin-top:101px}#close[_ngcontent-%COMP%]{margin-top:100px;position:absolute;right:20px;z-index:9999;transition:all .25s cubic-bezier(.05,.03,.35,1)}#close[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7}#propswitch[_ngcontent-%COMP%]{border-bottom:1px solid #e8e8ef;width:100%;margin-top:10px;margin-left:-20px;margin-bottom:30px}#dataprop[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#393c44;width:29.33333%;height:48px;line-height:48px;display:inline-block;float:left;margin-left:20px}#dataprop[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}#alertprop[_ngcontent-%COMP%]{float:left}#alertprop[_ngcontent-%COMP%], #logsprop[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto;font-weight:500;color:#808292;font-size:14px;height:48px;line-height:48px;width:29.33333%;text-align:center}.dropme[_ngcontent-%COMP%], .inputlabel[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;color:#253134}.dropme[_ngcontent-%COMP%]{background-color:#fff;border-radius:5px;border:1px solid #e8e8ef;box-shadow:0 2px 8px rgba(34,34,87,.05);text-indent:20px;height:40px;line-height:40px;width:287px;margin-bottom:25px}.dropme[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:17px;float:right;margin-right:15px}.checkus[_ngcontent-%COMP%]{margin-bottom:10px}.checkus[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;margin-left:10px}#divisionthing[_ngcontent-%COMP%]{height:1px;width:100%;background-color:#e8e8ef;position:absolute;right:0;bottom:80}#removeblock[_ngcontent-%COMP%]{width:287px;color:#253134}#removeblock[_ngcontent-%COMP%], #visualize_btn[_ngcontent-%COMP%]{border-radius:5px;position:absolute;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;height:38px;line-height:38px;border:1px solid #e8e8ef;transition:all .3s cubic-bezier(.05,.03,.35,1)}#visualize_btn[_ngcontent-%COMP%]{width:23%;color:#fff;right:21px;background-color:#247ce8}#table_preview[_ngcontent-%COMP%]{font-family:Trebuchet MS,Arial,Helvetica,sans-serif;border-collapse:collapse;width:81%;margin-left:2%}#customers[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], #table_preview[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{border:1px solid #ddd;padding:8px}#table_preview[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:nth-child(2n){background-color:#f2f2f2}#table_preview[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover{background-color:#ddd}#table_preview[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{padding-top:12px;padding-bottom:12px;text-align:left;background-color:#247ce8;color:#fff;text-align:center}#visualize_btn[_ngcontent-%COMP%]:hover{border-radius:5px;position:absolute;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;width:23%;height:38px;line-height:38px;color:#247ce8;right:21px;border:1px solid #e8e8ef;background-color:#fff;transition:all .3s cubic-bezier(.05,.03,.35,1)}#filename[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto;margin-left:2%;font-weight:800}#removeblock[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.5}.noselect[_ngcontent-%COMP%]{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.blockyname[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;color:#253134;margin-left:8px;font-size:16px}.blockyleft[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .blockyname[_ngcontent-%COMP%], .blockyright[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.blockyright[_ngcontent-%COMP%]{float:right;margin-right:20px;margin-top:10px;width:28px;height:28px;border-radius:5px;text-align:center;background-color:#fff;transition:all .3s cubic-bezier(.05,.03,.35,1);z-index:10}.blockyright[_ngcontent-%COMP%]:hover{background-color:#f1f4fc;cursor:pointer}.blockyright[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:12px}.blockyleft[_ngcontent-%COMP%]{display:inline-block;margin-left:20px}.blockydiv[_ngcontent-%COMP%]{width:100%;height:1px;background-color:#e9e9ef}.blockyinfo[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;color:#808292;margin-top:15px;text-indent:20px;margin-bottom:20px}.blockyinfo[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#253134;font-weight:500;display:inline-block;border-bottom:1px solid #d3dcea;line-height:20px;text-indent:0}.block[_ngcontent-%COMP%]{width:40%!important;background-color:#fff;margin-top:0!important;box-shadow:0 4px 30px rgba(22,33,74,.05)}.selectedblock[_ngcontent-%COMP%]{border:2px solid #217ce8;box-shadow:0 4px 30px rgba(22,33,74,.08)}.custom-select[_ngcontent-%COMP%]{position:relative;font-family:Arial}.custom-select[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]{display:none}.select-selected[_ngcontent-%COMP%]{background-color:#1e90ff}.select-selected[_ngcontent-%COMP%]:after{position:absolute;content:"";top:14px;right:10px;width:0;height:0;border:6px solid transparent;border-top-color:#fff}.select-selected.select-arrow-active[_ngcontent-%COMP%]:after{border-color:transparent transparent #fff;top:7px}.select-items[_ngcontent-%COMP%]   div[_ngcontent-%COMP%], .select-selected[_ngcontent-%COMP%]{color:#fff;padding:8px 16px;border:1px solid transparent;border-bottom-color:rgba(0,0,0,.1);cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.select-items[_ngcontent-%COMP%]{position:absolute;background-color:#1e90ff;top:100%;left:0;right:0;z-index:99}.select-hide[_ngcontent-%COMP%]{display:none}.same-as-selected[_ngcontent-%COMP%], .select-items[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.1)}@media only screen and (max-width:832px){#centerswitch[_ngcontent-%COMP%]{display:none}}@media only screen and (max-width:560px){#names[_ngcontent-%COMP%]{display:none}}']}),e})();function lf(e,t){if(1&e&&(Nr(0,"div",6),Nr(1,"div",7),Nr(2,"div",8),ls(3),jr(),Nr(4,"div",9),ls(5),jr(),zr(6,"div",10),Nr(7,"div",11),ls(8),li(9,"date"),jr(),zr(10,"div",12),jr(),jr()),2&e){const e=t.$implicit,n=t.index;Io(3),cs(" Result ",n+1," "),Io(2),cs(" ",e.run_status," "),Io(3),cs(" ",e.scheduled_time?function(e,t,n,o){const a=Vt(),r=At(a,e);return pi(a,ci(a,e)?function(e,t,n,o,a,r,s){const i=t+n;return Mr(e,i,a,r)?Pr(e,i+2,s?o.call(s,a,r):o(a,r)):ii(e,i+2)}(a,Jt(),t,r.transform,n,o,r):r.transform(n,o))}(9,3,e.scheduled_time.$date,"mmmm dS, yyyy, HH:mm:ss TT"):"Execution Time"," ")}}let uf=(()=>{class e{constructor(e,t){this.currentProjectService=e,this.dataServiceService=t,this.results=[]}ngAfterViewInit(){this.dataServiceService.getResults(this.project_name).subscribe(e=>{for(var t=e.data,n=Object.keys(t),o=0;o<n.length;o++)this.results.push(t[n[o]]);console.log(this.results)})}}return e.\u0275fac=function(t){return new(t||e)(Dr(xm),Dr(vm))},e.\u0275cmp=lt({type:e,selectors:[["app-results-page-component"]],inputs:{project_name:"project_name"},decls:8,vars:1,consts:[[1,"background"],["id","main_container",1,"main_container"],[1,"header"],[1,"close"],[1,"runs"],["class","body",4,"ngFor","ngForOf"],[1,"body"],[1,"run_row"],[1,"title"],[1,"status"],[1,"expand_icon"],[1,"schedule_time"],[1,"run_result_body"]],template:function(e,t){1&e&&(Nr(0,"div",0),Nr(1,"div",1),Nr(2,"div",2),ls(3," Results "),Nr(4,"div",3),ls(5," X "),jr(),jr(),Nr(6,"div",4),Fr(7,lf,11,6,"div",5),jr(),jr(),jr()),2&e&&(Io(7),Er("ngForOf",t.results))},directives:[Cu],pipes:[Du],styles:[".main_container[_ngcontent-%COMP%]{position:absolute;top:10%;left:25%;background-color:#fff;border-radius:18px;border:1px solid #e2e2e2;box-shadow:0 0 20px 0 #5f5b5b;width:50%;overflow:hidden;height:600px}.runs[_ngcontent-%COMP%]{overflow:scroll;height:86%}.close[_ngcontent-%COMP%]{font-family:cursive;cursor:pointer}.schedule_time[_ngcontent-%COMP%]{font-size:.9em;margin-top:1%}.time[_ngcontent-%COMP%]{font-family:Roboto;font-size:1.2em;font-weight:500}.status[_ngcontent-%COMP%], .title[_ngcontent-%COMP%]{font-size:1.2em;font-weight:500;display:inline-block}.status[_ngcontent-%COMP%]{float:right;background-color:#00c100;color:#fff;padding:1% 2%;border-radius:45px;border:3px solid #009e00}.background[_ngcontent-%COMP%]{position:absolute;top:0;left:0;padding:1%;width:100%;height:100%;background-color:rgba(60,60,60,.72);z-index:100}.header[_ngcontent-%COMP%]{font-size:20px;font-weight:800;padding:3% 3% 2%}.body[_ngcontent-%COMP%], .header[_ngcontent-%COMP%]{font-family:Roboto;border-bottom:1px solid #e2e2e2}.body[_ngcontent-%COMP%]{background-color:#f7f7f7}.body[_ngcontent-%COMP%], .run_row[_ngcontent-%COMP%]{padding:1%}"]}),e})();const cf=["appenHere"],pf=["inputOutputAppend"];function df(e,t){if(1&e){const e=Lr();Nr(0,"app-landing-page",12),Ur("closeBoxEmit",(function(){return qt(e),Hr().showLandingPage=!1})),jr()}}function hf(e,t){1&e&&(Nr(0,"div",13),zr(1,"img",14),Nr(2,"div",15),zr(3,"img",16),Nr(4,"p",17),ls(5," MaDE@UB Machine Learning Toolkit "),jr(),jr(),jr())}function mf(e,t){if(1&e){const e=Lr();Nr(0,"app-left-files-bar-component",18),Ur("emitter",(function(t){return qt(e),Hr().closeFilesMenu(t)})),jr()}if(2&e){const e=Hr();Er("currentProject",e.currentProject)("show",e.showFilesMenu)}}function ff(e,t){if(1&e){const e=Lr();Nr(0,"div",19),Nr(1,"div",20),Nr(2,"div",21),Nr(3,"div",22),Ur("click",(function(){return qt(e),Hr().showFilesMenu=!0})),zr(4,"img",23),jr(),Nr(5,"div",24),Nr(6,"p",25),ls(7),jr(),Nr(8,"p",26),ls(9,"Portal"),jr(),jr(),jr(),jr(),Nr(10,"nav-button",27),Ur("callFunction",(function(t){return qt(e),Hr().goHome(t)})),jr(),Nr(11,"nav-button",28),Ur("callFunction",(function(t){return qt(e),Hr().newProject(t)})),jr(),Nr(12,"nav-button",29),Ur("callFunction",(function(t){return qt(e),Hr().openProject(t)})),jr(),Nr(13,"nav-button",30),Ur("callFunction",(function(t){return qt(e),Hr().openResultsPage(t)})),jr(),Nr(14,"div",31),Nr(15,"div",32),Ur("click",(function(){return qt(e),Hr().runPipeline()})),ls(16,"Run Pipeline"),jr(),jr(),jr()}if(2&e){const e=Hr();Io(7),us(e.projectName)}}function gf(e,t){1&e&&zr(0,"div",33,34)}function _f(e,t){if(1&e){const e=Lr();Nr(0,"app-new-project-box",35),Ur("closeBoxEmit",(function(){return qt(e),Hr().showNewProjectBox=!1})),jr()}}function yf(e,t){if(1&e){const e=Lr();Nr(0,"app-open-project",35),Ur("closeBoxEmit",(function(){return qt(e),Hr().openProjectBox=!1})),jr()}}function bf(e,t){1&e&&zr(0,"app-toolbox")}function vf(e,t){1&e&&zr(0,"app-results-page-component",36),2&e&&Er("project_name",Hr().projectName)}let xf=(()=>{class e{constructor(e,t,n,o,a){this.elementRef=e,this.CFR=t,this.currentProjectService=n,this.dataServiceService=o,this.router=a,this.title="chemmlAngluar",this.toolConfigMapping=[],this.showNewProjectBox=!1,this.openProjectBox=!1,this.showFilesMenu=!1,this.showLandingPage=!1,this.inputOutputConfigMapping=[],this.showResultsPage=!1,this.exitMainPage=!1,this.arrowClicking=(e,t)=>{if(console.log("This arrow has been clicked",e,t),e in this.inputOutputConfigMapping)if(t in this.inputOutputConfigMapping[e])(n=this.inputOutputConfigMapping[e][t]).instance.show=!0;else{let o=this.CFR.resolveComponentFactory(Qm);this.inputOutputComponentRef=this.inputOutputTarget.createComponent(o),this.inputOutputConfigMapping[e][t]=this.inputOutputComponentRef;var n=this.inputOutputConfigMapping[e][t];this.inputOutputComponentRef.instance.parentId=t,this.inputOutputComponentRef.instance.childId=e,n.instance.show=!0}else{let o=this.CFR.resolveComponentFactory(Qm);this.inputOutputComponentRef=this.inputOutputTarget.createComponent(o),this.inputOutputConfigMapping[e]=[],this.inputOutputConfigMapping[e][t]=this.inputOutputComponentRef,n=this.inputOutputConfigMapping[e][t],this.inputOutputComponentRef.instance.parentId=t,this.inputOutputComponentRef.instance.childId=e,console.log(this.inputOutputConfigMapping)}},this.release=()=>{console.log("RELEASE")},this.rearrange=()=>!0,this.snapping=(e,t,n)=>{if(console.log("Snapping",e,t,n),e.classList.add("blockintree"),e.querySelector(".tool_header").style.display="block",e.querySelector(".tool_footer").style.display="block",!(e.id in this.toolConfigMapping)){let t=this.CFR.resolveComponentFactory(Wm);this.componentRef=this.target.createComponent(t),e.id+="_"+this.globalCounter,this.globalCounter+=1,this.toolConfigMapping[e.id]=this.componentRef,this.componentRef.instance.toolid=e.id;let n=e.id.split("_");n=n[n.length-2],console.log(n),this.componentRef.instance.tooltype=n;for(var o=e.childNodes,a=0;a<o.length;a++)o[a].id=e.id}return t||(console.log(e),console.log(n)),!0},this.router.events.subscribe(e=>{e instanceof rp&&(console.log("ROUTER EVENT",e),"/portal"==e.url&&(this.showLandingPage=!0,this.exitMainPage=!0)),e instanceof lp&&console.log(e.error)})}ngAfterViewInit(){this.currentProjectService.chemMLJsonChange.subscribe(e=>{this.chemMLJson=e}),this.chemMLJson=this.currentProjectService.getCurrentChemMLJson(),this.globalCounter=0,this.currentProjectService.execChange.subscribe(e=>{this.currentProject=e,this.projectName=this.currentProject.project_name}),this.currentProject=this.currentProjectService.getCurrentProject(),this.projectName=this.currentProject.project_name,this.currentProjectService.updateProjectInfo(this.currentProject),this.elementRef.nativeElement.addEventListener("click",e=>{let t=e.target.id,n=e.target.classList;if("tool"==t.substring(0,4)&&n.contains("grabme")&&(console.log(e.target),console.log(t,this.toolConfigMapping),t in this.toolConfigMapping)){let e=this.toolConfigMapping[t];e.instance.show=!0,console.log("Opening Tool-config of block: ",e.instance.type)}}),flowy(document.getElementById("canvas"),this.drag,this.release,this.arrowClicking,this.snapping,this.rearrange)}reRender(){this.elementRef.nativeElement.addEventListener("click",e=>{let t=e.target.id;if("tool"==t.substring(0,4)&&(console.log(e.target),console.log(t,this.toolConfigMapping),t in this.toolConfigMapping)){let e=this.toolConfigMapping[t];e.instance.show=!0,console.log("Opening Tool-config of block: ",e.instance.type)}}),flowy(document.getElementById("canvas"),this.drag,this.release,this.arrowClicking,this.snapping)}drag(e){console.log("DRAG",e)}openProject(e){console.log(e),this.openProjectBox=!0}goHome(e){console.log(e)}openResultsPage(e){this.showResultsPage=!0}newProject(e){console.log(e),this.showNewProjectBox=!0,console.log("Calling URL: ",Uh.newProject)}runPipeline(){this.currentProjectService.updateProjectInfo(this.currentProject),this.dataServiceService.runPipeline(this.projectName,this.chemMLJson).subscribe(e=>{console.log("Pipeline Result:",e),alert(e.data.error)})}closeFilesMenu(e){console.log("DATA PRINT",e),1==e&&(this.showFilesMenu=!1)}}return e.\u0275fac=function(t){return new(t||e)(Dr(gs),Dr(fs),Dr(xm),Dr(vm),Dr(bh))},e.\u0275cmp=lt({type:e,selectors:[["app-root"]],viewQuery:function(e,t){var n;1&e&&(Ti(cf,!0,Bs),Ti(pf,!0,Bs)),2&e&&(Ci(n=ki())&&(t.target=n.first),Ci(n=ki())&&(t.inputOutputTarget=n.first))},decls:15,vars:10,consts:[[3,"closeBoxEmit",4,"ngIf"],["id","header",4,"ngIf"],[3,"currentProject","show","emitter",4,"ngIf"],["id","navigation",4,"ngIf"],["id","canvas",3,"ngClass"],["class","config_box",4,"ngIf"],["id","new_project_box",3,"closeBoxEmit",4,"ngIf"],[1,"input_output_toolConfig"],["inputOutputAppend",""],[1,"botton"],[4,"ngIf"],[3,"project_name",4,"ngIf"],[3,"closeBoxEmit"],["id","header"],["src","../../assets/University_at_Buffalo_logo.svg.png",1,"ub_logo"],[1,"header-left"],["src","../../assets/nsf_logo.png",1,"nsf_logo"],[1,"made_logo"],[3,"currentProject","show","emitter"],["id","navigation"],["id","leftside"],["id","details"],["id","back",3,"click"],["src","assets/open-menu.svg"],["id","names"],["id","title"],["id","subtitle"],["description","Home",1,"button",3,"callFunction"],["description","New Project",1,"button",3,"callFunction"],["description","Open Project",1,"button",3,"callFunction"],["description","Results",1,"button",3,"callFunction"],["id","buttonsright"],["id","publish",3,"click"],[1,"config_box"],["appenHere",""],["id","new_project_box",3,"closeBoxEmit"],[3,"project_name"]],template:function(e,t){1&e&&(Fr(0,df,1,0,"app-landing-page",0),Nr(1,"div"),Fr(2,hf,6,0,"div",1),Fr(3,mf,1,2,"app-left-files-bar-component",2),Fr(4,ff,17,1,"div",3),zr(5,"div",4),Fr(6,gf,2,0,"div",5),Fr(7,_f,1,0,"app-new-project-box",6),Fr(8,yf,1,0,"app-open-project",6),zr(9,"div",7,8),zr(11,"div",9),Fr(12,bf,1,0,"app-toolbox",10),zr(13,"app-global-footer"),Fr(14,vf,1,1,"app-results-page-component",11),jr()),2&e&&(Er("ngIf",t.showLandingPage),Io(2),Er("ngIf",!t.showLandingPage),Io(1),Er("ngIf",t.showFilesMenu),Io(1),Er("ngIf",!t.showLandingPage&&t.exitMainPage),Io(1),Er("ngClass",t.showLandingPage?"not_show_canvas":"show_canvas"),Io(1),Er("ngIf",!t.showLandingPage),Io(1),Er("ngIf",t.showNewProjectBox),Io(1),Er("ngIf",t.openProjectBox),Io(4),Er("ngIf",!t.showLandingPage),Io(2),Er("ngIf",t.showResultsPage))},directives:[ku,xu,Cm,Pm,tf,wm,nf,af,sf,uf],styles:['.side[_ngcontent-%COMP%]{width:25%!important;margin-left:10%!important}.select_file_btn[_ngcontent-%COMP%]{display:inline-block;border-radius:5px;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;width:287px;height:38px;line-height:38px;color:#253134;border:1px solid #e8e8ef;transition:all .3s cubic-bezier(.05,.03,.35,1)}.select_file_btn[_ngcontent-%COMP%]:hover{background-color:#217ce8;color:#fff}.items[_ngcontent-%COMP%]{display:inline-block;background-color:#237ce8;color:#fff;border-radius:26px;font-family:Roboto;padding:11px 1%;margin:15px 15px 15px 2%}.visualize[_ngcontent-%COMP%]{height:90%;background-color:#fff;padding:0;border-radius:15px;margin:9% 3% 5%}.axis[_ngcontent-%COMP%]   line[_ngcontent-%COMP%], .axis[_ngcontent-%COMP%]   path[_ngcontent-%COMP%]{fill:none;stroke:#000;shape-rendering:crispEdges}.axis[_ngcontent-%COMP%]   text[_ngcontent-%COMP%]{font-family:sans-serif;font-size:11px}#navigation[_ngcontent-%COMP%]{border-radius:18px;height:71px;background-color:#fff;border-bottom:1px solid #e8e8ef;width:96%;display:table;box-sizing:border-box;position:fixed;top:0;z-index:100;margin:5% 2% 2%}#back[_ngcontent-%COMP%]{width:40px;height:40px;border-radius:100px;background-color:#f1f4fc;text-align:center;display:inline-block;vertical-align:top;border:3px solid #f1f4fc;margin-top:17px;margin-right:10px;cursor:pointer}#back[_ngcontent-%COMP%]:hover{background-color:#fff}#back[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:15%;width:60%}#names[_ngcontent-%COMP%]{display:inline-block;vertical-align:top;margin-top:6%}#title[_ngcontent-%COMP%]{font-weight:500;font-size:16px;color:#393c44;margin-bottom:0;margin-top:5%}#subtitle[_ngcontent-%COMP%], #title[_ngcontent-%COMP%]{font-family:Roboto}#subtitle[_ngcontent-%COMP%]{color:#808292;font-size:14px;margin-top:0}#leftside[_ngcontent-%COMP%]{margin-right:2%;display:inline-block;vertical-align:middle;margin-left:20px}#centerswitch[_ngcontent-%COMP%]{position:absolute;width:222px;left:50%;margin-left:-111px;top:15px}#leftswitch[_ngcontent-%COMP%]{border:1px solid #e8e8ef;background-color:#fbfbfb;width:111px;border-radius:5px 0 0 5px;color:#393c44}#leftswitch[_ngcontent-%COMP%], #rightswitch[_ngcontent-%COMP%]{height:39px;line-height:39px;font-family:Roboto;display:inline-block;font-size:14px;text-align:center}#rightswitch[_ngcontent-%COMP%]{color:#808292;border-radius:0 5px 5px 0;width:102px;margin-left:-5px}#discard[_ngcontent-%COMP%], #rightswitch[_ngcontent-%COMP%]{border:1px solid #e8e8ef}#discard[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;color:#a6a6b3;width:95px;height:38px;border-radius:5px;text-align:center;line-height:38px;display:inline-block;vertical-align:top;transition:all .2s cubic-bezier(.05,.03,.35,1)}#discard[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7}#publish[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;color:#217ce8;background-color:#fff;width:auto;padding-left:23px;padding-right:23px;height:45px;padding-top:1%;margin-left:18px;display:inline-block;vertical-align:top;text-align:center;line-height:38px;margin-right:20px;transition:all .2s cubic-bezier(.05,.03,.35,1)}#publish[_ngcontent-%COMP%], #publish[_ngcontent-%COMP%]:hover{border-radius:5px;border:2px solid #217ce8}#publish[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7;background-color:#217ce8;color:#fff}#buttonsright[_ngcontent-%COMP%]{float:right;margin-top:15px}#leftcard[_ngcontent-%COMP%]{width:370px;border:1px solid #e8e8ef;padding-top:3%;padding-left:20px;height:auto;position:absolute;z-index:2;vertical-align:middle;margin-top:9%;border-radius:16px;margin-left:2%;box-shadow:2px 2px 25px 2px #e2e2e2;transition:.5s;padding-bottom:5%}#leftcard[_ngcontent-%COMP%], #search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{background-color:#fff;box-sizing:border-box}#search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:318px;height:40px;border:1px solid #e8e8ef;box-shadow:0 2px 8px rgba(34,34,87,.05);border-radius:5px;text-indent:35px;font-family:Roboto;font-size:16px}[_ngcontent-%COMP%]::-moz-placeholder{color:#c9c9d5}[_ngcontent-%COMP%]::-ms-input-placeholder{color:#c9c9d5}[_ngcontent-%COMP%]::placeholder{color:#c9c9d5}#search[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:absolute;margin-top:10px;width:18px;margin-left:12px}#header[_ngcontent-%COMP%]{padding:1% 2%;background-color:#fff;border-bottom:1px solid #e2e2e2;z-index:1000}.ub_logo[_ngcontent-%COMP%]{width:8%;display:inline-block}.made_logo[_ngcontent-%COMP%]{display:inline-block!important;float:right!important;margin:0!important;font-family:Roboto!important;font-weight:800!important;font-size:1.3em!important;color:#393c44!important;width:108%!important;padding-left:5%!important;border-left:2px solid #d4d4d4!important}.tool_header[_ngcontent-%COMP%]{height:11px;background-color:#f1f4fc;border-top-left-radius:45px;border-top-right-radius:45px}.tool_header[_ngcontent-%COMP%]:hover{background-color:#217ce8}.tool_footer[_ngcontent-%COMP%]{height:11px;background-color:#f1f4fc;border-bottom-left-radius:45px;border-bottom-right-radius:45px}.tool_footer[_ngcontent-%COMP%]:hover{background-color:#217ce8}.show_canvas[_ngcontent-%COMP%]{display:block;z-index:0!important}.not_show_canvas[_ngcontent-%COMP%]{display:none;z-index:-1000!important}.nsf_logo[_ngcontent-%COMP%]{width:65px!important;position:absolute!important;top:-12px!important;left:-101px!important;padding-right:10px!important}.header-left[_ngcontent-%COMP%]{display:inline-block;float:right;position:relative}#subnav[_ngcontent-%COMP%]{border-bottom:1px solid #e8e8ef;width:calc(100% + 20px);margin-left:-20px;margin-top:10px;overflow:scroll;display:flex;border-top:1px solid #e8e8ef}.navdisabled[_ngcontent-%COMP%]{transition:all .3s cubic-bezier(.05,.03,.35,1)}.navdisabled[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.5}.navactive[_ngcontent-%COMP%]{color:#393c44!important}#triggers[_ngcontent-%COMP%]{margin-left:20px;font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#808292;width:29.33333%;height:48px;line-height:48px;display:inline-block;float:left}.navactive[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}#actions[_ngcontent-%COMP%]{float:left}#actions[_ngcontent-%COMP%], #loggers[_ngcontent-%COMP%]{display:inline-block;font-weight:500;color:#808292;height:48px;line-height:48px;width:29.33333%;text-align:center}#actions[_ngcontent-%COMP%], #footer[_ngcontent-%COMP%], #loggers[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px}#footer[_ngcontent-%COMP%]{position:absolute;left:0;padding-left:20px;line-height:40px;bottom:0;width:362px;border:1px solid #e8e8ef;height:67px;box-sizing:border-box;background-color:#fff}#footer[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none;color:#393c44;transition:all .2s cubic-bezier(.05,.03,.35,1)}#footer[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{opacity:.5}#footer[_ngcontent-%COMP%]   p[_ngcontent-%COMP%], #footer[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#808292}#footer[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{display:inline-block}#footer[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-left:5px;margin-right:5px}.blockelem[_ngcontent-%COMP%]:first-child{margin-top:20px}.block[_ngcontent-%COMP%], .blockintree[_ngcontent-%COMP%]{padding-top:10px;width:350px;border:1px solid transparent;transition-property:box-shadow,height;transition-duration:.2s;transition-timing-function:cubic-bezier(.05,.03,.35,1);border-radius:5px;box-shadow:11px 11px 30px #e2e2e2;box-sizing:border-box}.blockintree[_ngcontent-%COMP%]{background-color:#fff;margin-bottom:20%}.blockelem[_ngcontent-%COMP%]{padding-top:10px;width:350px;border:1px solid transparent;transition-property:box-shadow,height;transition-duration:.2s;transition-timing-function:cubic-bezier(.05,.03,.35,1);border-radius:5px;box-shadow:0 0 30px rgba(22,33,74,0);box-sizing:border-box;margin-bottom:20%}.blockelem[_ngcontent-%COMP%]:hover{box-shadow:0 4px 30px rgba(22,33,74,.08);border-radius:5px;background-color:#fff;cursor:pointer}.blockico[_ngcontent-%COMP%], .grabme[_ngcontent-%COMP%]{display:inline-block}.grabme[_ngcontent-%COMP%]{margin-top:10px;margin-left:10px;margin-bottom:-14px;width:15px}#blocklist[_ngcontent-%COMP%]{height:calc(100% - 220px);overflow:auto}#proplist[_ngcontent-%COMP%]{height:calc(100% - 305px);overflow:auto;margin-top:-30px;padding-top:13px}.blockin[_ngcontent-%COMP%]{display:inline-block;vertical-align:top;margin-left:12px}.blockico[_ngcontent-%COMP%]{width:36px;height:36px;background-color:#f1f4fc;border-radius:5px;text-align:center;white-space:nowrap}.blockico[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{height:100%;width:0}.blockico[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .blockico[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.blockico[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-left:auto;margin-right:auto;width:52%}.blocktext[_ngcontent-%COMP%]{display:inline-block;width:220px;vertical-align:top;margin-left:12px}.blocktitle[_ngcontent-%COMP%]{margin:0!important;padding:0!important;font-family:Roboto;font-weight:500;font-size:16px;color:#393c44}.blockdesc[_ngcontent-%COMP%]{margin-top:5px;font-family:Roboto;color:#808292;font-size:14px;line-height:21px}.blockdisabled[_ngcontent-%COMP%]{background-color:#f0f2f9;opacity:.5}#closecard[_ngcontent-%COMP%]{position:absolute;margin-left:348px;background-color:#fff;border-radius:0 5px 5px 0;border-bottom:1px solid #e8e8ef;border-right:1px solid #e8e8ef;border-top:1px solid #e8e8ef;width:53px;height:53px;text-align:center;z-index:10}#closecard[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:15px}#canvas[_ngcontent-%COMP%]{position:absolute;width:calc(100% - 361px);height:calc(100% - 184px);top:184px;left:361px;z-index:0;overflow:auto}#search[_ngcontent-%COMP%]{margin-bottom:7%!important}#propwrap[_ngcontent-%COMP%]{right:0;width:40%;overflow:hidden;z-index:-2}#properties[_ngcontent-%COMP%], #propwrap[_ngcontent-%COMP%]{position:absolute;top:0;height:100%;padding-left:20px}#properties[_ngcontent-%COMP%]{width:70%;background-color:#fff;right:-150px;opacity:0;z-index:2;box-shadow:-4px 0 40px rgba(26,26,73,0);transition:all .25s cubic-bezier(.05,.03,.35,1)}.itson[_ngcontent-%COMP%]{z-index:2!important}.expanded[_ngcontent-%COMP%]{right:0!important;opacity:1!important;box-shadow:-4px 0 40px rgba(26,26,73,.05);z-index:2}#header2[_ngcontent-%COMP%]{font-size:20px;font-family:Roboto;font-weight:700;color:#393c44;margin-top:101px}#close[_ngcontent-%COMP%]{margin-top:100px;position:absolute;right:20px;z-index:9999;transition:all .25s cubic-bezier(.05,.03,.35,1)}#close[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.7}#propswitch[_ngcontent-%COMP%]{border-bottom:1px solid #e8e8ef;width:100%;margin-top:10px;margin-left:-20px;margin-bottom:30px}#dataprop[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;font-size:14px;text-align:center;color:#393c44;width:29.33333%;height:48px;line-height:48px;display:inline-block;float:left;margin-left:20px}#dataprop[_ngcontent-%COMP%]:after{display:block;content:"";width:100%;height:4px;background-color:#217ce8;margin-top:-4px}#alertprop[_ngcontent-%COMP%]{float:left}#alertprop[_ngcontent-%COMP%], #logsprop[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto;font-weight:500;color:#808292;font-size:14px;height:48px;line-height:48px;width:29.33333%;text-align:center}.dropme[_ngcontent-%COMP%], .inputlabel[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;color:#253134}.dropme[_ngcontent-%COMP%]{background-color:#fff;border-radius:5px;border:1px solid #e8e8ef;box-shadow:0 2px 8px rgba(34,34,87,.05);text-indent:20px;height:40px;line-height:40px;width:287px;margin-bottom:25px}.dropme[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:17px;float:right;margin-right:15px}.checkus[_ngcontent-%COMP%]{margin-bottom:10px}.checkus[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.checkus[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;margin-left:10px}#divisionthing[_ngcontent-%COMP%]{height:1px;width:100%;background-color:#e8e8ef;position:absolute;right:0;bottom:80}#removeblock[_ngcontent-%COMP%]{width:287px;color:#253134}#removeblock[_ngcontent-%COMP%], #visualize_btn[_ngcontent-%COMP%]{border-radius:5px;position:absolute;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;height:38px;line-height:38px;border:1px solid #e8e8ef;transition:all .3s cubic-bezier(.05,.03,.35,1)}#visualize_btn[_ngcontent-%COMP%]{width:23%;color:#fff;right:21px;background-color:#247ce8}#table_preview[_ngcontent-%COMP%]{font-family:Trebuchet MS,Arial,Helvetica,sans-serif;border-collapse:collapse;width:81%;margin-left:2%}#customers[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], #table_preview[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{border:1px solid #ddd;padding:8px}#table_preview[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:nth-child(2n){background-color:#f2f2f2}#table_preview[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover{background-color:#ddd}#table_preview[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{padding-top:12px;padding-bottom:12px;text-align:left;background-color:#247ce8;color:#fff;text-align:center}#visualize_btn[_ngcontent-%COMP%]:hover{border-radius:5px;position:absolute;bottom:20px;font-family:Roboto;font-size:14px;text-align:center;width:23%;height:38px;line-height:38px;color:#247ce8;right:21px;border:1px solid #e8e8ef;background-color:#fff;transition:all .3s cubic-bezier(.05,.03,.35,1)}#filename[_ngcontent-%COMP%]{display:inline-block;font-family:Roboto;margin-left:2%;font-weight:800}#removeblock[_ngcontent-%COMP%]:hover{cursor:pointer;opacity:.5}.noselect[_ngcontent-%COMP%]{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.blockyname[_ngcontent-%COMP%]{font-family:Roboto;font-weight:500;color:#253134;margin-left:8px;font-size:16px}.blockyleft[_ngcontent-%COMP%]   img[_ngcontent-%COMP%], .blockyname[_ngcontent-%COMP%], .blockyright[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle}.blockyright[_ngcontent-%COMP%]{float:right;margin-right:20px;margin-top:10px;width:28px;height:28px;border-radius:5px;text-align:center;background-color:#fff;transition:all .3s cubic-bezier(.05,.03,.35,1);z-index:10}.blockyright[_ngcontent-%COMP%]:hover{background-color:#f1f4fc;cursor:pointer}.blockyright[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{margin-top:12px}.blockyleft[_ngcontent-%COMP%]{display:inline-block;margin-left:20px}.blockydiv[_ngcontent-%COMP%]{width:100%;height:1px;background-color:#e9e9ef}.blockyinfo[_ngcontent-%COMP%]{font-family:Roboto;font-size:14px;color:#808292;margin-top:15px;text-indent:20px;margin-bottom:20px}.blockyinfo[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{color:#253134;font-weight:500;display:inline-block;border-bottom:1px solid #d3dcea;line-height:20px;text-indent:0}.block[_ngcontent-%COMP%]{width:40%!important;background-color:#fff;margin-top:0!important;box-shadow:0 4px 30px rgba(22,33,74,.05)}.selectedblock[_ngcontent-%COMP%]{border:2px solid #217ce8;box-shadow:0 4px 30px rgba(22,33,74,.08)}.custom-select[_ngcontent-%COMP%]{position:relative;font-family:Arial}.custom-select[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]{display:none}.select-selected[_ngcontent-%COMP%]{background-color:#1e90ff}.select-selected[_ngcontent-%COMP%]:after{position:absolute;content:"";top:14px;right:10px;width:0;height:0;border:6px solid transparent;border-top-color:#fff}.select-selected.select-arrow-active[_ngcontent-%COMP%]:after{border-color:transparent transparent #fff;top:7px}.select-items[_ngcontent-%COMP%]   div[_ngcontent-%COMP%], .select-selected[_ngcontent-%COMP%]{color:#fff;padding:8px 16px;border:1px solid transparent;border-bottom-color:rgba(0,0,0,.1);cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.select-items[_ngcontent-%COMP%]{position:absolute;background-color:#1e90ff;top:100%;left:0;right:0;z-index:99}.select-hide[_ngcontent-%COMP%]{display:none}.same-as-selected[_ngcontent-%COMP%], .select-items[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:hover{background-color:rgba(0,0,0,.1)}@media only screen and (max-width:832px){#centerswitch[_ngcontent-%COMP%]{display:none}}@media only screen and (max-width:560px){#names[_ngcontent-%COMP%]{display:none}}']}),e})(),wf=(()=>{class e{}return e.\u0275mod=dt({type:e,bootstrap:[xf]}),e.\u0275inj=ue({factory:function(t){return new(t||e)},providers:[],imports:[[uc,Mm,bm]]}),e})();(function(){if(ro)throw new Error("Cannot enable prod mode after platform setup.");ao=!1})(),ic().bootstrapModule(wf).catch(e=>console.error(e))},zn8P:function(e,t){function n(e){return Promise.resolve().then((function(){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}))}n.keys=function(){return[]},n.resolve=n,e.exports=n,n.id="zn8P"}},[[0,0]]]);